! function(t, e) { "function" == typeof define && define.amd ? define([], e) : "object" == typeof module && module.exports ? module.exports = e() : t.echarts = e() }(this, function() {
    var t, e;
    ! function() {
        function i(t, e) {
            if (!e) return t;
            if (0 === t.indexOf(".")) {
                var i = e.split("/"),
                    n = t.split("/"),
                    r = i.length - 1,
                    a = n.length,
                    o = 0,
                    s = 0;
                t: for (var l = 0; a > l; l++) switch (n[l]) {
                    case "..":
                        if (!(r > o)) break t;
                        o++, s++;
                        break;
                    case ".":
                        s++;
                        break;
                    default:
                        break t }
                return i.length = r - o, n = n.slice(s), i.concat(n).join("/") }
            return t }

        function n(t) {
            function e(e, o) {
                if ("string" == typeof e) {
                    var s = n[e];
                    return s || (s = a(i(e, t)), n[e] = s), s }
                e instanceof Array && (o = o || function() {}, o.apply(this, r(e, o, t))) }
            var n = {};
            return e }

        function r(e, n, r) {
            for (var s = [], l = o[r], c = 0, u = Math.min(e.length, n.length); u > c; c++) {
                var h, d = i(e[c], r);
                switch (d) {
                    case "require":
                        h = l && l.require || t;
                        break;
                    case "exports":
                        h = l.exports;
                        break;
                    case "module":
                        h = l;
                        break;
                    default:
                        h = a(d) }
                s.push(h) }
            return s }

        function a(t) {
            var e = o[t];
            if (!e) throw new Error("No " + t);
            if (!e.defined) {
                var i = e.factory,
                    n = i.apply(this, r(e.deps || [], i, t)); "undefined" != typeof n && (e.exports = n), e.defined = 1 }
            return e.exports }
        var o = {};
        e = function(t, e, i) { o[t] = { id: t, deps: e, factory: i, defined: 0, exports: {}, require: n(t) } }, t = n("") }();
    var i = "buildPath",
        n = "../core/util",
        r = "undefined",
        a = "parent",
        o = "stroke",
        s = "lineWidth",
        l = "applyTransform",
        c = "ecModel",
        u = "option",
        h = "../../util/number",
        d = "rotation",
        f = "inside",
        p = "getName",
        m = "toFixed",
        v = "parsePercent",
        g = "setHoverStyle",
        y = "emphasis",
        x = "getItemVisual",
        _ = "normal",
        b = "../../echarts",
        w = "category",
        M = "getComponent",
        S = "dimensions",
        T = "getItemModel",
        C = "updateProps",
        A = "ordinal",
        k = "getItemGraphicEl",
        L = "updateData",
        z = "eachItemGraphicEl",
        P = "animation",
        D = "getItemLayout",
        I = "getAxis",
        O = "radius",
        R = "getBaseAxis",
        B = "../../util/graphic",
        E = "concat",
        V = "getContext",
        N = "createElement",
        F = "getExtent",
        G = "contain",
        Z = "opacity",
        H = "setStyle",
        W = "position",
        q = "center",
        j = "middle",
        U = "getBoundingRect",
        X = "getTextColor",
        Y = "getFont",
        $ = "textAlign",
        Q = "textStyle",
        K = "coordinateSystem",
        J = "removeAll",
        te = "inherits",
        ee = "number",
        ie = "function",
        ne = "indexOf",
        re = "isArray",
        ae = "replace",
        oe = "traverse",
        se = "zlevel",
        le = "getDataParams",
        ce = "seriesIndex",
        ue = "dataIndex",
        he = "target",
        de = "mouseout",
        fe = "mouseover",
        pe = "splice",
        me = "series",
        ve = "eachSeries",
        ge = "trigger",
        ye = "length",
        xe = "defaults",
        _e = "dispatchAction",
        be = "extend",
        we = "remove",
        Me = "isObject",
        Se = "updateLayout",
        Te = "update",
        Ce = "create",
        Ae = "height",
        ke = "bottom",
        Le = "ignore",
        ze = "eachComponent",
        Pe = "canvasSupported",
        De = "getHeight",
        Ie = "getWidth",
        Oe = "getModel",
        Re = "resize",
        Be = "string",
        Ee = "prototype",
        Ve = "toLowerCase",
        Ne = "transform",
        Fe = "zrender/core/vector",
        Ge = "filter",
        Ze = "getData",
        He = "zrender/core/util",
        We = "require";
    e("echarts/chart/line", [We, He, "../echarts", "./line/LineSeries", "./line/LineView", "../visual/symbol", "../layout/points", "../processor/dataSample", "../component/grid"], function(t) {
        var e = t(He),
            i = t("../echarts");
        t("./line/LineSeries"), t("./line/LineView"), i.registerVisualCoding("chart", e.curry(t("../visual/symbol"), "line", "circle", "line")), i.registerLayout(e.curry(t("../layout/points"), "line")), i.registerProcessor("statistic", e.curry(t("../processor/dataSample"), "line")), t("../component/grid") }), e("echarts/chart/bar", [We, He, "../coord/cartesian/Grid", "./bar/BarSeries", "./bar/BarView", "../layout/barGrid", "../echarts", "../component/grid"], function(t) {
        var e = t(He);
        t("../coord/cartesian/Grid"), t("./bar/BarSeries"), t("./bar/BarView");
        var i = t("../layout/barGrid"),
            n = t("../echarts");
        n.registerLayout(e.curry(i, "bar")), n.registerVisualCoding("chart", function(t) { t.eachSeriesByType("bar", function(t) {
                var e = t[Ze]();
                e.setVisual("legendSymbol", "roundRect") }) }), t("../component/grid") }), e("echarts/chart/pie", [We, He, "../echarts", "./pie/PieSeries", "./pie/PieView", "../action/createDataSelectAction", "../visual/dataColor", "./pie/pieLayout", "../processor/dataFilter"], function(t) {
        var e = t(He),
            i = t("../echarts");
        t("./pie/PieSeries"), t("./pie/PieView"), t("../action/createDataSelectAction")("pie", [{ type: "pieToggleSelect", event: "pieselectchanged", method: "toggleSelected" }, { type: "pieSelect", event: "pieselected", method: "select" }, { type: "pieUnSelect", event: "pieunselected", method: "unSelect" }]), i.registerVisualCoding("chart", e.curry(t("../visual/dataColor"), "pie")), i.registerLayout(e.curry(t("./pie/pieLayout"), "pie")), i.registerProcessor(Ge, e.curry(t("../processor/dataFilter"), "pie")) }), e("echarts/echarts", [We, "./model/Global", "./ExtensionAPI", "./CoordinateSystem", "./model/OptionManager", "./model/Component", "./model/Series", "./view/Component", "./view/Chart", "./util/graphic", "zrender", He, "zrender/tool/color", "zrender/core/env", "zrender/mixin/Eventful", "./loading/default", "./visual/seriesColor", "./preprocessor/backwardCompat", "./util/number", "./util/format", "zrender/core/matrix", Fe], function(t) {
        function e(t) {
            return function(e, i, n) { e = e && e[Ve](), A[Ee][t].call(this, e, i, n) } }

        function i() { A.call(this) }

        function n(t, e, n) { n = n || {}, typeof e === Be && (e = G[e]), e && k(N, function(t) { t(e) }), this.id, this.group, this._dom = t, this._zr = M.init(t, { renderer: n.renderer || "canvas", devicePixelRatio: n.devicePixelRatio }), this._theme = S.clone(e), this._chartsViews = [], this._chartsMap = {}, this._componentsViews = [], this._componentsMap = {}, this._api = new m(this), this._coordSysMgr = new v, A.call(this), this._messageCenter = new i, this._initEvents(), this[Re] = S.bind(this[Re], this) }

        function r(t, e) {
            var i = this._model;
            i && i[ze]({ mainType: "series", query: e }, function(n) {
                var r = this._chartsMap[n.__viewId];
                r && r.__alive && r[t](n, i, this._api, e) }, this) }

        function a(t, e, i) {
            var n = this._api;
            k(this._componentsViews, function(r) {
                var a = r.__model;
                r[t](a, e, n, i), d(a, r) }, this), e[ve](function(r) {
                var a = this._chartsMap[r.__viewId];
                a[t](r, e, n, i), d(r, a) }, this) }

        function o(t, e) {
            for (var i = "component" === t, n = i ? this._componentsViews : this._chartsViews, r = i ? this._componentsMap : this._chartsMap, a = this._zr, o = 0; o < n[ye]; o++) n[o].__alive = !1;
            e[i ? ze : ve](function(t, o) {
                if (i) {
                    if (t === me) return } else o = t;
                var s = o.id + "_" + o.type,
                    l = r[s];
                if (!l) {
                    var c = y.parseClassType(o.type),
                        u = i ? _.getClass(c.main, c.sub) : b.getClass(c.sub);
                    if (!u) return;
                    l = new u, l.init(e, this._api), r[s] = l, n.push(l), a.add(l.group) }
                o.__viewId = s, l.__alive = !0, l.__id = s, l.__model = o }, this);
            for (var o = 0; o < n[ye];) {
                var s = n[o];
                s.__alive ? o++ : (a[we](s.group), s.dispose(e, this._api), n[pe](o, 1), delete r[s.__id]) } }

        function s(t, e) { k(z, function(i) { k(V[i] || [], function(i) { i(t, e) }) }) }

        function l(t) {
            var e = {};
            t[ve](function(t) {
                var i = t.get("stack"),
                    n = t[Ze]();
                if (i && "list" === n.type) {
                    var r = e[i];
                    r && (n.stackedOn = r), e[i] = n } }) }

        function c(t, e) {
            var i = this._api;
            k(E, function(n) { n(t, i, e) }) }

        function u(t, e) { k(L, function(i) { k(F[i] || [], function(i) { i(t, e) }) }) }

        function h(t, e) {
            var i = this._api;
            k(this._componentsViews, function(n) {
                var r = n.__model;
                n.render(r, t, i, e), d(r, n) }, this), k(this._chartsViews, function(t) { t.__alive = !1 }, this), t[ve](function(n) {
                var r = this._chartsMap[n.__viewId];
                r.__alive = !0, r.render(n, t, i, e), r.group.silent = !!n.get("silent"), d(n, r) }, this), k(this._chartsViews, function(e) { e.__alive || e[we](t, i) }, this) }

        function d(t, e) {
            var i = t.get("z"),
                n = t.get(se);
            e.group[oe](function(t) { null != i && (t.z = i), null != n && (t[se] = n) }) }

        function f(t) {
            function e(t, e) {
                for (var i = 0; i < t[ye]; i++) {
                    var n = t[i];
                    n[a] = e } }
            var i = 0,
                n = 1,
                r = 2,
                a = "__connectUpdateStatus";
            S.each(B, function(o, s) { t._messageCenter.on(s, function(o) {
                    if (H[t.group] && t[a] !== i) {
                        var s = t.makeActionFromEvent(o),
                            l = [];
                        for (var c in Z) {
                            var u = Z[c];
                            u !== t && u.group === t.group && l.push(u) }
                        e(l, i), k(l, function(t) { t[a] !== n && t[_e](s) }), e(l, r) } }) }) }
        var p = t("./model/Global"),
            m = t("./ExtensionAPI"),
            v = t("./CoordinateSystem"),
            g = t("./model/OptionManager"),
            y = t("./model/Component"),
            x = t("./model/Series"),
            _ = t("./view/Component"),
            b = t("./view/Chart"),
            w = t("./util/graphic"),
            M = t("zrender"),
            S = t(He),
            T = t("zrender/tool/color"),
            C = t("zrender/core/env"),
            A = t("zrender/mixin/Eventful"),
            k = S.each,
            L = ["echarts", "chart", "component"],
            z = [Ne, Ge, "statistic"];
        i[Ee].on = e("on"), i[Ee].off = e("off"), i[Ee].one = e("one"), S.mixin(i, A);
        var P = n[Ee];
        P.getDom = function() {
            return this._dom }, P.getZr = function() {
            return this._zr }, P.setOption = function(t, e, i) {
            (!this._model || e) && (this._model = new p(null, null, this._theme, new g(this._api))), this._model.setOption(t, N), D.prepareAndUpdate.call(this), !i && this._zr.refreshImmediately() }, P.setTheme = function() { console.log("ECharts#setTheme() is DEPRECATED in ECharts 3.0") }, P[Oe] = function() {
            return this._model }, P.getOption = function() {
            return this._model.getOption() }, P[Ie] = function() {
            return this._zr[Ie]() }, P[De] = function() {
            return this._zr[De]() }, P.getRenderedCanvas = function(t) {
            if (C[Pe]) { t = t || {}, t.pixelRatio = t.pixelRatio || 1, t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor");
                var e = this._zr,
                    i = e.storage.getDisplayList();
                return S.each(i, function(t) { t.stopAnimation(!0) }), e.painter.getRenderedCanvas(t) } }, P.getDataURL = function(t) { t = t || {};
            var e = t.excludeComponents,
                i = this._model,
                n = [],
                r = this;
            k(e, function(t) { i[ze]({ mainType: t }, function(t) {
                    var e = r._componentsMap[t.__viewId];
                    e.group[Le] || (n.push(e), e.group[Le] = !0) }) });
            var a = this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
            return k(n, function(t) { t.group[Le] = !1 }), a }, P.getConnectedDataURL = function(t) {
            if (C[Pe]) {
                var e = this.group,
                    i = Math.min,
                    n = Math.max,
                    r = 1 / 0;
                if (H[e]) {
                    var a = r,
                        o = r,
                        s = -r,
                        l = -r,
                        c = [],
                        u = t && t.pixelRatio || 1;
                    for (var h in Z) {
                        var d = Z[h];
                        if (d.group === e) {
                            var f = d.getRenderedCanvas(S.clone(t)),
                                p = d.getDom().getBoundingClientRect();
                            a = i(p.left, a), o = i(p.top, o), s = n(p.right, s), l = n(p[ke], l), c.push({ dom: f, left: p.left, top: p.top }) } }
                    a *= u, o *= u, s *= u, l *= u;
                    var m = s - a,
                        v = l - o,
                        g = S.createCanvas();
                    g.width = m, g[Ae] = v;
                    var y = M.init(g);
                    return k(c, function(t) {
                        var e = new w.Image({ style: { x: t.left * u - a, y: t.top * u - o, image: t.dom } });
                        y.add(e) }), y.refreshImmediately(), g.toDataURL("image/" + (t && t.type || "png")) }
                return this.getDataURL(t) } };
        var D = { update: function(t) {
                var e = this._model,
                    i = this._api,
                    n = this._coordSysMgr;
                if (e) { e.restoreData(), n[Ce](this._model, this._api), s.call(this, e, i), l.call(this, e), n[Te](e, i), c.call(this, e, t), u.call(this, e, t), h.call(this, e, t);
                    var r = e.get("backgroundColor") || "transparent",
                        a = this._zr.painter;
                    if (a.isSingleCanvas && a.isSingleCanvas()) this._zr.configLayer(0, { clearColor: r });
                    else {
                        if (!C[Pe]) {
                            var o = T.parse(r);
                            r = T.stringify(o, "rgb"), 0 === o[3] && (r = "transparent") }
                        r = r, this._dom.style.backgroundColor = r } } }, updateView: function(t) {
                var e = this._model;
                e && (c.call(this, e, t), u.call(this, e, t), a.call(this, "updateView", e, t)) }, updateVisual: function(t) {
                var e = this._model;
                e && (u.call(this, e, t), a.call(this, "updateVisual", e, t)) }, updateLayout: function(t) {
                var e = this._model;
                e && (c.call(this, e, t), a.call(this, Se, e, t)) }, highlight: function(t) { r.call(this, "highlight", t) }, downplay: function(t) { r.call(this, "downplay", t) }, prepareAndUpdate: function(t) {
                var e = this._model;
                o.call(this, "component", e), o.call(this, "chart", e), D[Te].call(this, t) } };
        P[Re] = function() { this._zr[Re]();
            var t = this._model && this._model.resetOption("media");
            D[t ? "prepareAndUpdate" : Te].call(this), this._loadingFX && this._loadingFX[Re]() };
        var I = t("./loading/default");
        P.showLoading = function(t, e) { S[Me](t) && (e = t, t = "default"), this.hideLoading();
            var i = I(this._api, e),
                n = this._zr;
            this._loadingFX = i, n.add(i) }, P.hideLoading = function() { this._loadingFX && this._zr[we](this._loadingFX), this._loadingFX = null }, P.makeActionFromEvent = function(t) {
            var e = S[be]({}, t);
            return e.type = B[t.type], e }, P[_e] = function(t, e) {
            var i = R[t.type];
            if (i) {
                var n = i.actionInfo,
                    r = n[Te] || Te,
                    a = [t],
                    o = !1;
                t.batch && (o = !0, a = S.map(t.batch, function(e) {
                    return e = S[xe](S[be]({}, e), t), e.batch = null, e }));
                for (var s, l = [], c = "highlight" === t.type || "downplay" === t.type, u = 0; u < a[ye]; u++) {
                    var h = a[u];
                    s = i.action(h, this._model), s = s || S[be]({}, h), s.type = n.event || s.type, l.push(s), c && D[r].call(this, h) } "none" !== r && !c && D[r].call(this, t), e || (s = o ? { type: n.event || t.type, batch: l } : l[0], this._messageCenter[ge](s.type, s)) } }, P.on = e("on"), P.off = e("off"), P.one = e("one");
        var O = ["click", "dblclick", fe, de, "mousedown", "mouseup", "globalout"];
        P._initEvents = function() {
            var t = this._zr;
            k(O, function(e) { t.on(e, function(t) {
                    var i = this[Oe](),
                        n = t[he];
                    if (n && null != n[ue]) {
                        var r = n.dataModel || i.getSeriesByIndex(n[ce]),
                            a = r && r[le](n[ue]) || {};
                        a.event = t, a.type = e, this[ge](e, a) } else n && n.eventData && this[ge](e, n.eventData) }, this) }, this), k(B, function(t, e) { this._messageCenter.on(e, function(t) { this[ge](e, t) }, this) }, this) }, P.isDisposed = function() {
            return this._disposed }, P.clear = function() { this.setOption({}, !0) }, P.dispose = function() { this._disposed = !0;
            var t = this._api,
                e = this._model;
            k(this._componentsViews, function(i) { i.dispose(e, t) }), k(this._chartsViews, function(i) { i.dispose(e, t) }), this._zr.dispose(), delete Z[this.id] }, S.mixin(n, A);
        var R = [],
            B = {},
            E = [],
            V = {},
            N = [],
            F = {},
            G = {},
            Z = {},
            H = {},
            W = new Date - 0,
            q = new Date - 0,
            j = "_echarts_instance_",
            U = { version: "3.1.7", dependencies: { zrender: "3.0.8" } };
        return U.init = function(t, e, i) {
            if (M.version[ae](".", "") - 0 < U.dependencies.zrender[ae](".", "") - 0) throw new Error("ZRender " + M.version + " is too old for ECharts " + U.version + ". Current version need ZRender " + U.dependencies.zrender + "+");
            if (!t) throw new Error("Initialize failed: invalid dom.");
            var r = new n(t, e, i);
            return r.id = "ec_" + W++, Z[r.id] = r, t.setAttribute && t.setAttribute(j, r.id), f(r), r }, U.connect = function(t) {
            if (S[re](t)) {
                var e = t;
                t = null, S.each(e, function(e) { null != e.group && (t = e.group) }), t = t || "g_" + q++, S.each(e, function(e) { e.group = t }) }
            return H[t] = !0, t }, U.disConnect = function(t) { H[t] = !1 }, U.dispose = function(t) { S.isDom(t) ? t = U.getInstanceByDom(t) : typeof t === Be && (t = Z[t]), t instanceof n && !t.isDisposed() && t.dispose() }, U.getInstanceByDom = function(t) {
            var e = t.getAttribute(j);
            return Z[e] }, U.getInstanceById = function(t) {
            return Z[t] }, U.registerTheme = function(t, e) { G[t] = e }, U.registerPreprocessor = function(t) { N.push(t) }, U.registerProcessor = function(t, e) {
            if (S[ne](z, t) < 0) throw new Error("stage should be one of " + z);
            var i = V[t] || (V[t] = []);
            i.push(e) }, U.registerAction = function(t, e, i) { typeof e === ie && (i = e, e = "");
            var n = S[Me](t) ? t.type : [t, t = { event: e }][0];
            t.event = (t.event || n)[Ve](), e = t.event, R[n] || (R[n] = { action: i, actionInfo: t }), B[e] = n }, U.registerCoordinateSystem = function(t, e) { v.register(t, e) }, U.registerLayout = function(t) { S[ne](E, t) < 0 && E.push(t) }, U.registerVisualCoding = function(t, e) {
            if (S[ne](L, t) < 0) throw new Error("stage should be one of " + L);
            var i = F[t] || (F[t] = []);
            i.push(e) }, U.extendChartView = function(t) {
            return b[be](t) }, U.extendComponentModel = function(t) {
            return y[be](t) }, U.extendSeriesModel = function(t) {
            return x[be](t) }, U.extendComponentView = function(t) {
            return _[be](t) }, U.setCanvasCreator = function(t) { S.createCanvas = t }, U.registerVisualCoding("echarts", S.curry(t("./visual/seriesColor"), "", "itemStyle")), U.registerPreprocessor(t("./preprocessor/backwardCompat")), U.registerAction({ type: "highlight", event: "highlight", update: "highlight" }, S.noop), U.registerAction({ type: "downplay", event: "downplay", update: "downplay" }, S.noop), U.graphic = t("./util/graphic"), U[ee] = t("./util/number"), U.format = t("./util/format"), U.matrix = t("zrender/core/matrix"), U.vector = t(Fe), U.util = {}, k(["map", "each", Ge, ne, te, "reduce", Ge, "bind", "curry", re, "isString", Me, "isFunction", be], function(t) { U.util[t] = S[t] }), U }), e("echarts/component/grid", [We, "../util/graphic", He, "../coord/cartesian/Grid", "./axis", "../echarts"], function(t) {
        var e = t("../util/graphic"),
            i = t(He);
        t("../coord/cartesian/Grid"), t("./axis"), t("../echarts").extendComponentView({ type: "grid", render: function(t) { this.group[J](), t.get("show") && this.group.add(new e.Rect({ shape: t[K].getRect(), style: i[xe]({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0 })) } }) }), e("echarts/component/title", [We, "../echarts", "../util/graphic", "../util/layout"], function(t) {
        var e = t("../echarts"),
            i = t("../util/graphic"),
            n = t("../util/layout");
        e.extendComponentModel({ type: "title", layoutMode: { type: "box", ignoreSize: !0 }, defaultOption: { zlevel: 0, z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bolder", color: "#333" }, subtextStyle: { color: "#aaa" } } }), e.extendComponentView({ type: "title", render: function(t, e, r) {
                if (this.group[J](), t.get("show")) {
                    var a = this.group,
                        o = t[Oe](Q),
                        s = t[Oe]("subtextStyle"),
                        l = t.get($),
                        c = new i.Text({ style: { text: t.get("text"), textFont: o[Y](), fill: o[X](), textBaseline: "top" }, z2: 10 }),
                        u = c[U](),
                        h = t.get("subtext"),
                        d = new i.Text({ style: { text: h, textFont: s[Y](), fill: s[X](), y: u[Ae] + t.get("itemGap"), textBaseline: "top" }, z2: 10 }),
                        f = t.get("link"),
                        p = t.get("sublink");
                    c.silent = !f, d.silent = !p, f && c.on("click", function() { window.open(f, "_" + t.get(he)) }), p && d.on("click", function() { window.open(p, "_" + t.get("subtarget")) }), a.add(c), h && a.add(d);
                    var m = a[U](),
                        v = t.getBoxLayoutParams();
                    v.width = m.width, v[Ae] = m[Ae];
                    var g = n.getLayoutRect(v, { width: r[Ie](), height: r[De]() }, t.get("padding"));
                    l || (l = t.get("left") || t.get("right"), l === j && (l = q), "right" === l ? g.x += g.width : l === q && (g.x += g.width / 2)), a[W] = [g.x, g.y], c[H]($, l), d[H]($, l), m = a[U]();
                    var y = g.margin,
                        x = t.getItemStyle(["color", Z]);
                    x.fill = t.get("backgroundColor");
                    var _ = new i.Rect({ shape: { x: m.x - y[3], y: m.y - y[0], width: m.width + y[1] + y[3], height: m[Ae] + y[0] + y[2] }, style: x, silent: !0 });
                    i.subPixelOptimizeRect(_), a.add(_) } } }) }), e("echarts/component/legend", [We, "./legend/LegendModel", "./legend/legendAction", "./legend/LegendView", "../echarts", "./legend/legendFilter"], function(t) { t("./legend/LegendModel"), t("./legend/legendAction"), t("./legend/LegendView");
        var e = t("../echarts");
        e.registerProcessor(Ge, t("./legend/legendFilter")) }), e("echarts/component/tooltip", [We, "./tooltip/TooltipModel", "./tooltip/TooltipView", "../echarts"], function(t) { t("./tooltip/TooltipModel"), t("./tooltip/TooltipView"), t("../echarts").registerAction({ type: "showTip", event: "showTip", update: "none" }, function() {}), t("../echarts").registerAction({ type: "hideTip", event: "hideTip", update: "none" }, function() {}) }), e("echarts/component/markLine", [We, "./marker/MarkLineModel", "./marker/MarkLineView", "../echarts"], function(t) { t("./marker/MarkLineModel"), t("./marker/MarkLineView"), t("../echarts").registerPreprocessor(function(t) { t.markLine = t.markLine || {} }) }), e("zrender/vml/vml", [We, "./graphic", "../zrender", "./Painter"], function(t) { t("./graphic"), t("../zrender").registerPainter("vml", t("./Painter")) }), e("echarts/component/toolbox", [We, "./toolbox/ToolboxModel", "./toolbox/ToolboxView", "./toolbox/feature/SaveAsImage", "./toolbox/feature/MagicType", "./toolbox/feature/DataView", "./toolbox/feature/DataZoom", "./toolbox/feature/Restore"], function(t) { t("./toolbox/ToolboxModel"), t("./toolbox/ToolboxView"), t("./toolbox/feature/SaveAsImage"), t("./toolbox/feature/MagicType"), t("./toolbox/feature/DataView"), t("./toolbox/feature/DataZoom"), t("./toolbox/feature/Restore") }), e("echarts/scale/Time", [We, He, "../util/number", "../util/format", "./Interval"], function(t) {
        var e = t(He),
            i = t("../util/number"),
            n = t("../util/format"),
            r = t("./Interval"),
            a = r[Ee],
            o = Math.ceil,
            s = Math.floor,
            l = 864e5,
            c = function(t, e, i, n) {
                for (; n > i;) {
                    var r = i + n >>> 1;
                    t[r][2] < e ? i = r + 1 : n = r }
                return i },
            u = r[be]({ type: "time", getLabel: function(t) {
                    var e = this._stepLvl,
                        i = new Date(t);
                    return n.formatTime(e[0], i) }, niceExtent: function(t, e, n) {
                    var r = this._extent;
                    if (r[0] === r[1] && (r[0] -= l, r[1] += l), r[1] === -1 / 0 && 1 / 0 === r[0]) {
                        var a = new Date;
                        r[1] = new Date(a.getFullYear(), a.getMonth(), a.getDate()), r[0] = r[1] - l }
                    this.niceTicks(t, e, n);
                    var c = this._interval;
                    e || (r[0] = i.round(s(r[0] / c) * c)), n || (r[1] = i.round(o(r[1] / c) * c)) }, niceTicks: function(t) { t = t || 10;
                    var e = this._extent,
                        n = e[1] - e[0],
                        r = n / t,
                        a = h[ye],
                        l = c(h, r, 0, a),
                        u = h[Math.min(l, a - 1)],
                        d = u[2];
                    if ("year" === u[0]) {
                        var f = n / d,
                            p = i.nice(f / t, !0);
                        d *= p }
                    var m = [o(e[0] / d) * d, s(e[1] / d) * d];
                    this._stepLvl = u, this._interval = d, this._niceExtent = m }, parse: function(t) {
                    return +i.parseDate(t) } });
        e.each([G, "normalize"], function(t) { u[Ee][t] = function(e) {
                return a[t].call(this, this.parse(e)) } });
        var h = [
            ["hh:mm:ss", 1, 1e3],
            ["hh:mm:ss", 5, 5e3],
            ["hh:mm:ss", 10, 1e4],
            ["hh:mm:ss", 15, 15e3],
            ["hh:mm:ss", 30, 3e4],
            ["hh:mm\nMM-dd", 1, 6e4],
            ["hh:mm\nMM-dd", 5, 3e5],
            ["hh:mm\nMM-dd", 10, 6e5],
            ["hh:mm\nMM-dd", 15, 9e5],
            ["hh:mm\nMM-dd", 30, 18e5],
            ["hh:mm\nMM-dd", 1, 36e5],
            ["hh:mm\nMM-dd", 2, 72e5],
            ["hh:mm\nMM-dd", 6, 216e5],
            ["hh:mm\nMM-dd", 12, 432e5],
            ["MM-dd\nyyyy", 1, l],
            ["week", 7, 7 * l],
            ["month", 1, 31 * l],
            ["quarter", 3, 380 * l / 4],
            ["half-year", 6, 380 * l / 2],
            ["year", 1, 380 * l]
        ];
        return u[Ce] = function() {
            return new u }, u }), e("echarts/scale/Log", [We, He, "./Scale", "../util/number", "./Interval"], function(t) {
        var e = t(He),
            i = t("./Scale"),
            n = t("../util/number"),
            r = t("./Interval"),
            a = i[Ee],
            o = r[Ee],
            s = Math.floor,
            l = Math.ceil,
            c = Math.pow,
            u = 10,
            h = Math.log,
            d = i[be]({ type: "log", getTicks: function() {
                    return e.map(o.getTicks.call(this), function(t) {
                        return n.round(c(u, t)) }) }, getLabel: o.getLabel, scale: function(t) {
                    return t = a.scale.call(this, t), c(u, t) }, setExtent: function(t, e) { t = h(t) / h(u), e = h(e) / h(u), o.setExtent.call(this, t, e) }, getExtent: function() {
                    var t = a[F].call(this);
                    return t[0] = c(u, t[0]), t[1] = c(u, t[1]), t }, unionExtent: function(t) { t[0] = h(t[0]) / h(u), t[1] = h(t[1]) / h(u), a.unionExtent.call(this, t) }, niceTicks: function(t) { t = t || 10;
                    var e = this._extent,
                        i = e[1] - e[0];
                    if (!(1 / 0 === i || 0 >= i)) {
                        var r = c(10, s(h(i / t) / Math.LN10)),
                            a = t / i * r;
                        .5 >= a && (r *= 10);
                        var o = [n.round(l(e[0] / r) * r), n.round(s(e[1] / r) * r)];
                        this._interval = r, this._niceExtent = o } }, niceExtent: o.niceExtent });
        return e.each([G, "normalize"], function(t) { d[Ee][t] = function(e) {
                return e = h(e) / h(u), a[t].call(this, e) } }), d[Ce] = function() {
            return new d }, d }), e(He, [We, "../graphic/Gradient"], function(t) {
        function e(t) {
            if ("object" == typeof t && null !== t) {
                var i = t;
                if (t instanceof Array) { i = [];
                    for (var n = 0, r = t[ye]; r > n; n++) i[n] = e(t[n]) } else if (!M(t) && !S(t)) { i = {};
                    for (var a in t) t.hasOwnProperty(a) && (i[a] = e(t[a])) }
                return i }
            return t }

        function i(t, n, r) {
            if (!w(n) || !w(t)) return r ? e(n) : t;
            for (var a in n)
                if (n.hasOwnProperty(a)) {
                    var o = t[a],
                        s = n[a];!w(s) || !w(o) || x(s) || x(o) || S(s) || S(o) || M(s) || M(o) ? !r && a in t || (t[a] = e(n[a], !0)) : i(o, s, r) }
            return t }

        function n(t, e) {
            for (var n = t[0], r = 1, a = t[ye]; a > r; r++) n = i(n, t[r], e);
            return n }

        function r(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
            return t }

        function a(t, e, i) {
            for (var n in e) e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
            return t }

        function o() {
            return document[N]("canvas") }

        function s() {
            return k || (k = G.createCanvas()[V]("2d")), k }

        function l(t, e) {
            if (t) {
                if (t[ne]) return t[ne](e);
                for (var i = 0, n = t[ye]; n > i; i++)
                    if (t[i] === e) return i }
            return -1 }

        function c(t, e) {
            function i() {}
            var n = t[Ee];
            i[Ee] = e[Ee], t[Ee] = new i;
            for (var r in n) t[Ee][r] = n[r];
            t[Ee].constructor = t, t.superClass = e }

        function u(t, e, i) { t = Ee in t ? t[Ee] : t, e = Ee in e ? e[Ee] : e, a(t, e, i) }

        function h(t) {
            return t ? typeof t == Be ? !1 : typeof t[ye] == ee : void 0 }

        function d(t, e, i) {
            if (t && e)
                if (t.forEach && t.forEach === I) t.forEach(e, i);
                else if (t[ye] === +t[ye])
                for (var n = 0, r = t[ye]; r > n; n++) e.call(i, t[n], n, t);
            else
                for (var a in t) t.hasOwnProperty(a) && e.call(i, t[a], a, t) }

        function f(t, e, i) {
            if (t && e) {
                if (t.map && t.map === B) return t.map(e, i);
                for (var n = [], r = 0, a = t[ye]; a > r; r++) n.push(e.call(i, t[r], r, t));
                return n } }

        function p(t, e, i, n) {
            if (t && e) {
                if (t.reduce && t.reduce === F) return t.reduce(e, i, n);
                for (var r = 0, a = t[ye]; a > r; r++) i = e.call(n, i, t[r], r, t);
                return i } }

        function m(t, e, i) {
            if (t && e) {
                if (t[Ge] && t[Ge] === O) return t[Ge](e, i);
                for (var n = [], r = 0, a = t[ye]; a > r; r++) e.call(i, t[r], r, t) && n.push(t[r]);
                return n } }

        function v(t, e, i) {
            if (t && e)
                for (var n = 0, r = t[ye]; r > n; n++)
                    if (e.call(i, t[n], n, t)) return t[n] }

        function g(t, e) {
            var i = R.call(arguments, 2);
            return function() {
                return t.apply(e, i[E](R.call(arguments))) } }

        function y(t) {
            var e = R.call(arguments, 1);
            return function() {
                return t.apply(this, e[E](R.call(arguments))) } }

        function x(t) {
            return "[object Array]" === P.call(t) }

        function _(t) {
            return typeof t === ie }

        function b(t) {
            return "[object String]" === P.call(t) }

        function w(t) {
            var e = typeof t;
            return e === ie || !!t && "object" == e }

        function M(t) {
            return !!z[P.call(t)] || t instanceof L }

        function S(t) {
            return t && 1 === t.nodeType && typeof t.nodeName == Be }

        function T() {
            for (var t = 0, e = arguments[ye]; e > t; t++)
                if (null != arguments[t]) return arguments[t] }

        function C() {
            return Function.call.apply(R, arguments) }

        function A(t, e) {
            if (!t) throw new Error(e) }
        var k, L = t("../graphic/Gradient"),
            z = { "[object Function]": 1, "[object RegExp]": 1, "[object Date]": 1, "[object Error]": 1, "[object CanvasGradient]": 1 },
            P = Object[Ee].toString,
            D = Array[Ee],
            I = D.forEach,
            O = D[Ge],
            R = D.slice,
            B = D.map,
            F = D.reduce,
            G = { inherits: c, mixin: u, clone: e, merge: i, mergeAll: n, extend: r, defaults: a, getContext: s, createCanvas: o, indexOf: l, slice: C, find: v, isArrayLike: h, each: d, map: f, reduce: p, filter: m, bind: g, curry: y, isArray: x, isString: b, isObject: w, isFunction: _, isBuildInObject: M, isDom: S, retrieve: T, assert: A, noop: function() {} };
        return G }), e("echarts/chart/line/LineSeries", [We, "../helper/createListFromArray", "../../model/Series"], function(t) {
        var e = t("../helper/createListFromArray"),
            i = t("../../model/Series");
        return i[be]({ type: "series.line", dependencies: ["grid", "polar"], getInitialData: function(t, i) {
                return e(t.data, this, i) }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, hoverAnimation: !0, xAxisIndex: 0, yAxisIndex: 0, polarIndex: 0, clipOverflow: !0, label: { normal: { position: "top" } }, lineStyle: { normal: { width: 2, type: "solid" } }, symbol: "emptyCircle", symbolSize: 4, showSymbol: !0, animationEasing: "linear" } }) }), e("echarts/chart/line/LineView", [We, He, "../helper/SymbolDraw", "../helper/Symbol", "./lineAnimationDiff", B, "./poly", "../../view/Chart"], function(t) {
        function e(t, e) {
            if (t[ye] === e[ye]) {
                for (var i = 0; i < t[ye]; i++) {
                    var n = t[i],
                        r = e[i];
                    if (n[0] !== r[0] || n[1] !== r[1]) return }
                return !0 } }

        function i(t) {
            return typeof t === ee ? t : t ? .3 : 0 }

        function n(t) {
            var e = t.getGlobalExtent();
            if (t.onBand) {
                var i = t.getBandWidth() / 2 - 1,
                    n = e[1] > e[0] ? 1 : -1;
                e[0] += n * i, e[1] -= n * i }
            return e }

        function r(t) {
            return t >= 0 ? 1 : -1 }

        function a(t, e) {
            var i = t[R](),
                n = t.getOtherAxis(i),
                a = i.onZero ? 0 : n.scale[F]()[0],
                o = n.dim,
                s = "x" === o || o === O ? 1 : 0;
            return e.mapArray([o], function(n, l) {
                for (var c, u = e.stackedOn; u && r(u.get(o, l)) === r(n);) { c = u;
                    break }
                var h = [];
                return h[s] = e.get(i.dim, l), h[1 - s] = c ? c.get(o, l, !0) : a, t.dataToPoint(h) }, !0) }

        function o(t, e) {
            return null != e[ue] ? e[ue] : null != e.name ? t.indexOfName(e.name) : void 0 }

        function s(t, e, i) {
            var r = n(t[I]("x")),
                a = n(t[I]("y")),
                o = t[R]().isHorizontal(),
                s = r[0],
                l = a[0],
                c = r[1] - s,
                u = a[1] - l;
            i.get("clipOverflow") || (o ? (l -= u, u *= 3) : (s -= c, c *= 3));
            var h = new p.Rect({ shape: { x: s, y: l, width: c, height: u } });
            return e && (h.shape[o ? "width" : Ae] = 0, p.initProps(h, { shape: { width: c, height: u } }, i)), h }

        function l(t, e, i) {
            var n = t.getAngleAxis(),
                r = t.getRadiusAxis(),
                a = r[F](),
                o = n[F](),
                s = Math.PI / 180,
                l = new p.Sector({ shape: { cx: t.cx, cy: t.cy, r0: a[0], r: a[1], startAngle: -o[0] * s, endAngle: -o[1] * s, clockwise: n.inverse } });
            return e && (l.shape.endAngle = -o[0] * s, p.initProps(l, { shape: { endAngle: -o[1] * s } }, i)), l }

        function c(t, e, i) {
            return "polar" === t.type ? l(t, e, i) : s(t, e, i) }
        var u = t(He),
            h = t("../helper/SymbolDraw"),
            d = t("../helper/Symbol"),
            f = t("./lineAnimationDiff"),
            p = t(B),
            m = t("./poly"),
            v = t("../../view/Chart");
        return v[be]({ type: "line", init: function() {
                var t = new p.Group,
                    e = new h;
                this.group.add(e.group), this._symbolDraw = e, this._lineGroup = t }, render: function(t, n, r) {
                var o = t[K],
                    s = this.group,
                    l = t[Ze](),
                    h = t[Oe]("lineStyle.normal"),
                    d = t[Oe]("areaStyle.normal"),
                    f = l.mapArray(l[D], !0),
                    p = "polar" === o.type,
                    m = this._coordSys,
                    v = this._symbolDraw,
                    g = this._polyline,
                    y = this._polygon,
                    x = this._lineGroup,
                    _ = t.get(P),
                    b = !d.isEmpty(),
                    w = a(o, l),
                    M = t.get("showSymbol"),
                    S = M && !p && !t.get("showAllSymbol") && this._getSymbolIgnoreFunc(l, o),
                    T = this._data;
                T && T[z](function(t, e) { t.__temp && (s[we](t), T.setItemGraphicEl(e, null)) }), M || v[we](), s.add(x), g && m.type === o.type ? (b && !y ? y = this._newPolygon(f, w, o, _) : y && !b && (x[we](y), y = this._polygon = null), x.setClipPath(c(o, !1, t)), M && v[L](l, S), l[z](function(t) { t.stopAnimation(!0) }), e(this._stackedOnPoints, w) && e(this._points, f) || (_ ? this._updateAnimation(l, w, o, r) : (g.setShape({ points: f }), y && y.setShape({ points: f, stackedOnPoints: w })))) : (M && v[L](l, S), g = this._newPolyline(f, o, _), b && (y = this._newPolygon(f, w, o, _)), x.setClipPath(c(o, !0, t))), g[H](u[xe](h.getLineStyle(), { stroke: l.getVisual("color"), lineJoin: "bevel" }));
                var C = t.get("smooth");
                if (C = i(t.get("smooth")), g.setShape({ smooth: C, smoothMonotone: t.get("smoothMonotone") }), y) {
                    var A = l.stackedOn,
                        k = 0;
                    if (y.style[Z] = .7, y[H](u[xe](d.getAreaStyle(), { fill: l.getVisual("color"), lineJoin: "bevel" })), A) {
                        var I = A.hostModel;
                        k = i(I.get("smooth")) }
                    y.setShape({ smooth: C, stackedOnSmooth: k, smoothMonotone: t.get("smoothMonotone") }) }
                this._data = l, this._coordSys = o, this._stackedOnPoints = w, this._points = f }, highlight: function(t, e, i, n) {
                var r = t[Ze](),
                    a = o(r, n);
                if (null != a && a >= 0) {
                    var s = r[k](a);
                    if (!s) {
                        var l = r[D](a);
                        s = new d(r, a, i), s[W] = l, s.setZ(t.get(se), t.get("z")), s[Le] = isNaN(l[0]) || isNaN(l[1]), s.__temp = !0, r.setItemGraphicEl(a, s), s.stopSymbolAnimation(!0), this.group.add(s) }
                    s.highlight() } else v[Ee].highlight.call(this, t, e, i, n) }, downplay: function(t, e, i, n) {
                var r = t[Ze](),
                    a = o(r, n);
                if (null != a && a >= 0) {
                    var s = r[k](a);
                    s && (s.__temp ? (r.setItemGraphicEl(a, null), this.group[we](s)) : s.downplay()) } else v[Ee].downplay.call(this, t, e, i, n) }, _newPolyline: function(t) {
                var e = this._polyline;
                return e && this._lineGroup[we](e), e = new m.Polyline({ shape: { points: t }, silent: !0, z2: 10 }), this._lineGroup.add(e), this._polyline = e, e }, _newPolygon: function(t, e) {
                var i = this._polygon;
                return i && this._lineGroup[we](i), i = new m.Polygon({ shape: { points: t, stackedOnPoints: e }, silent: !0 }), this._lineGroup.add(i), this._polygon = i, i }, _getSymbolIgnoreFunc: function(t, e) {
                var i = e.getAxesByScale(A)[0];
                return i && i.isLabelIgnored ? u.bind(i.isLabelIgnored, i) : void 0 }, _updateAnimation: function(t, e, i) {
                var n = this._polyline,
                    r = this._polygon,
                    a = t.hostModel,
                    o = f(this._data, t, this._stackedOnPoints, e, this._coordSys, i);
                n.shape.points = o.current, p[C](n, { shape: { points: o.next } }, a), r && (r.setShape({ points: o.current, stackedOnPoints: o.stackedOnCurrent }), p[C](r, { shape: { points: o.next, stackedOnPoints: o.stackedOnNext } }, a));
                for (var s = [], l = o.status, c = 0; c < l[ye]; c++) {
                    var u = l[c].cmd;
                    if ("=" === u) {
                        var h = t[k](l[c].idx1);
                        h && s.push({ el: h, ptIdx: c }) } }
                n.animators && n.animators[ye] && n.animators[0].during(function() {
                    for (var t = 0; t < s[ye]; t++) {
                        var e = s[t].el;
                        e.attr(W, n.shape.points[s[t].ptIdx]) } }) }, remove: function() {
                var t = this.group,
                    e = this._data;
                this._lineGroup[J](), this._symbolDraw[we](!0), e && e[z](function(i, n) { i.__temp && (t[we](i), e.setItemGraphicEl(n, null)) }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null } }) }), e("echarts/visual/symbol", [We], function() {
        return function(t, e, i, n) { n.eachRawSeriesByType(t, function(t) {
                var r = t[Ze](),
                    a = t.get("symbol") || e,
                    o = t.get("symbolSize");
                r.setVisual({ legendSymbol: i || a, symbol: a, symbolSize: o }), n.isSeriesFiltered(t) || (typeof o === ie && r.each(function(e) {
                    var i = t.getRawValue(e),
                        n = t[le](e);
                    r.setItemVisual(e, "symbolSize", o(i, n)) }), r.each(function(t) {
                    var e = r[T](t),
                        i = e.get("symbol", !0),
                        n = e.get("symbolSize", !0);
                    null != i && r.setItemVisual(t, "symbol", i), null != n && r.setItemVisual(t, "symbolSize", n) })) }) } }), e("echarts/layout/points", [We], function() {
        return function(t, e) { e.eachSeriesByType(t, function(t) {
                var e = t[Ze](),
                    i = t[K],
                    n = i[S];
                e.each(n, function(t, n, r) {
                    var a;
                    a = isNaN(t) || isNaN(n) ? [0 / 0, 0 / 0] : i.dataToPoint([t, n]), e.setItemLayout(r, a) }, !0) }) } }), e("echarts/processor/dataSample", [], function() {
        var t = { average: function(t) {
                    for (var e = 0, i = 0, n = 0; n < t[ye]; n++) isNaN(t[n]) || (e += t[n], i++);
                    return 0 === i ? 0 / 0 : e / i }, sum: function(t) {
                    for (var e = 0, i = 0; i < t[ye]; i++) e += t[i] || 0;
                    return e }, max: function(t) {
                    for (var e = -1 / 0, i = 0; i < t[ye]; i++) t[i] > e && (e = t[i]);
                    return e }, min: function(t) {
                    for (var e = 1 / 0, i = 0; i < t[ye]; i++) t[i] < e && (e = t[i]);
                    return e }, nearest: function(t) {
                    return t[0] } },
            e = function(t) {
                return Math.round(t[ye] / 2) };
        return function(i, n) { n.eachSeriesByType(i, function(i) {
                var n = i[Ze](),
                    r = i.get("sampling"),
                    a = i[K];
                if ("cartesian2d" === a.type && r) {
                    var o = a[R](),
                        s = a.getOtherAxis(o),
                        l = o[F](),
                        c = l[1] - l[0],
                        u = Math.round(n.count() / c);
                    if (u > 1) {
                        var h;
                        typeof r === Be ? h = t[r] : typeof r === ie && (h = r), h && (n = n.downSample(s.dim, 1 / u, h, e), i.setData(n)) } } }, this) } }), e("echarts/coord/cartesian/Grid", [We, "exports", "../../util/layout", "../../coord/axisHelper", He, "./Cartesian2D", "./Axis2D", "./GridModel", "../../CoordinateSystem"], function(t) {
        function e(t, e, i) {
            return i[M]("grid", t.get("gridIndex")) === e }

        function i(t) {
            var e, i = t.model,
                n = i.getFormattedLabels(),
                r = 1,
                a = n[ye];
            a > 40 && (r = Math.ceil(a / 40));
            for (var o = 0; a > o; o += r)
                if (!t.isLabelIgnored(o)) {
                    var s = i.getTextRect(n[o]);
                    e ? e.union(s) : e = s }
            return e }

        function n(t, e, i) { this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this._initCartesian(t, e, i), this._model = t }

        function r(t, e) {
            var i = t[F](),
                n = i[0] + i[1];
            t.toGlobalCoord = "x" === t.dim ? function(t) {
                return t + e } : function(t) {
                return n - t + e }, t.toLocalCoord = "x" === t.dim ? function(t) {
                return t - e } : function(t) {
                return n - t + e } }
        var a = t("../../util/layout"),
            o = t("../../coord/axisHelper"),
            s = t(He),
            l = t("./Cartesian2D"),
            c = t("./Axis2D"),
            u = s.each,
            h = o.ifAxisCrossZero,
            d = o.niceScaleExtent;
        t("./GridModel");
        var f = n[Ee];
        return f.type = "grid", f.getRect = function() {
            return this._rect }, f[Te] = function(t, e) {
            function i(t) {
                var e = n[t];
                for (var i in e) {
                    var r = e[i];
                    if (r && (r.type === w || !h(r))) return !0 }
                return !1 }
            var n = this._axesMap;
            this._updateScale(t, this._model), u(n.x, function(t) { d(t, t.model) }), u(n.y, function(t) { d(t, t.model) }), u(n.x, function(t) { i("y") && (t.onZero = !1) }), u(n.y, function(t) { i("x") && (t.onZero = !1) }), this[Re](this._model, e) }, f[Re] = function(t, e) {
            function n() { u(s, function(t) {
                    var e = t.isHorizontal(),
                        i = e ? [0, o.width] : [0, o[Ae]],
                        n = t.inverse ? 1 : 0;
                    t.setExtent(i[n], i[1 - n]), r(t, e ? o.x : o.y) }) }
            var o = a.getLayoutRect(t.getBoxLayoutParams(), { width: e[Ie](), height: e[De]() });
            this._rect = o;
            var s = this._axesList;
            n(), t.get("containLabel") && (u(s, function(t) {
                if (!t.model.get("axisLabel.inside")) {
                    var e = i(t);
                    if (e) {
                        var n = t.isHorizontal() ? Ae : "width",
                            r = t.model.get("axisLabel.margin");
                        o[n] -= e[n] + r, "top" === t[W] ? o.y += e[Ae] + r : "left" === t[W] && (o.x += e.width + r) } } }), n()) }, f[I] = function(t, e) {
            var i = this._axesMap[t];
            if (null != i) {
                if (null == e)
                    for (var n in i) return i[n];
                return i[e] } }, f.getCartesian = function(t, e) {
            var i = "x" + t + "y" + e;
            return this._coordsMap[i] }, f._initCartesian = function(t, i) {
            function n(n) {
                return function(l, u) {
                    if (e(l, t, i)) {
                        var h = l.get(W); "x" === n ? ("top" !== h && h !== ke && (h = ke), r[h] && (h = "top" === h ? ke : "top")) : ("left" !== h && "right" !== h && (h = "left"), r[h] && (h = "left" === h ? "right" : "left")), r[h] = !0;
                        var d = new c(n, o.createScaleByModel(l), [0, 0], l.get("type"), h),
                            f = d.type === w;
                        d.onBand = f && l.get("boundaryGap"), d.inverse = l.get("inverse"), d.onZero = l.get("axisLine.onZero"), l.axis = d, d.model = l, d.index = u, this._axesList.push(d), a[n][u] = d, s[n]++ } } }
            var r = { left: !1, right: !1, top: !1, bottom: !1 },
                a = { x: {}, y: {} },
                s = { x: 0, y: 0 };
            return i[ze]("xAxis", n("x"), this), i[ze]("yAxis", n("y"), this), s.x && s.y ? (this._axesMap = a, void u(a.x, function(t, e) { u(a.y, function(i, n) {
                    var r = "x" + e + "y" + n,
                        a = new l(r);
                    a.grid = this, this._coordsMap[r] = a, this._coordsList.push(a), a.addAxis(t), a.addAxis(i) }, this) }, this)) : (this._axesMap = {}, void(this._axesList = [])) }, f._updateScale = function(t, i) {
            function n(t, e, i) { u(i.coordDimToDataDim(e.dim), function(i) { e.scale.unionExtent(t.getDataExtent(i, e.scale.type !== A)) }) }
            s.each(this._axesList, function(t) { t.scale.setExtent(1 / 0, -1 / 0) }), t[ve](function(r) {
                if ("cartesian2d" === r.get(K)) {
                    var a = r.get("xAxisIndex"),
                        o = r.get("yAxisIndex"),
                        s = t[M]("xAxis", a),
                        l = t[M]("yAxis", o);
                    if (!e(s, i, t) || !e(l, i, t)) return;
                    var c = this.getCartesian(a, o),
                        u = r[Ze](),
                        h = c[I]("x"),
                        d = c[I]("y"); "list" === u.type && (n(u, h, r), n(u, d, r)) } }, this) }, n[Ce] = function(t, e) {
            var i = [];
            return t[ze]("grid", function(r, a) {
                var o = new n(r, t, e);
                o.name = "grid_" + a, o[Re](r, e), r[K] = o, i.push(o) }), t[ve](function(e) {
                if ("cartesian2d" === e.get(K)) {
                    var n = e.get("xAxisIndex"),
                        r = t[M]("xAxis", n),
                        a = i[r.get("gridIndex")];
                    e[K] = a.getCartesian(n, e.get("yAxisIndex")) } }), i }, n[S] = l[Ee][S], t("../../CoordinateSystem").register("cartesian2d", n), n
    }), e("echarts/chart/bar/BarSeries", [We, "../../model/Series", "../helper/createListFromArray"], function(t) {
        var e = t("../../model/Series"),
            i = t("../helper/createListFromArray");
        return e[be]({ type: "series.bar", dependencies: ["grid", "polar"], getInitialData: function(t, e) {
                return i(t.data, this, e) }, getMarkerPosition: function(t) {
                var e = this[K];
                if (e) {
                    var i = e.dataToPoint(t),
                        n = this[Ze](),
                        r = n.getLayout("offset"),
                        a = n.getLayout("size"),
                        o = e[R]().isHorizontal() ? 0 : 1;
                    return i[o] += r + a / 2, i }
                return [0 / 0, 0 / 0] }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, xAxisIndex: 0, yAxisIndex: 0, barMinHeight: 0, itemStyle: { normal: { barBorderColor: "#fff", barBorderWidth: 0 }, emphasis: { barBorderColor: "#fff", barBorderWidth: 0 } } } }) }), e("echarts/chart/bar/BarView", [We, He, B, "../../model/Model", "./barItemStyle", b], function(t) {
        function e(t, e) {
            var i = t.width > 0 ? 1 : -1,
                n = t[Ae] > 0 ? 1 : -1;
            e = Math.min(e, Math.abs(t.width), Math.abs(t[Ae])), t.x += i * e / 2, t.y += n * e / 2, t.width -= i * e, t[Ae] -= n * e }
        var i = t(He),
            n = t(B);
        return i[be](t("../../model/Model")[Ee], t("./barItemStyle")), t(b).extendChartView({ type: "bar", render: function(t, e, i) {
                var n = t.get(K);
                return "cartesian2d" === n && this._renderOnCartesian(t, e, i), this.group }, _renderOnCartesian: function(t) {
                function r(r, a) {
                    var s = o[D](r),
                        l = o[T](r).get(d) || 0;
                    e(s, l);
                    var c = new n.Rect({ shape: i[be]({}, s) });
                    if (h) {
                        var f = c.shape,
                            p = u ? Ae : "width",
                            m = {};
                        f[p] = 0, m[p] = s[p], n[a ? C : "initProps"](c, { shape: m }, t) }
                    return c }
                var a = this.group,
                    o = t[Ze](),
                    s = this._data,
                    l = t[K],
                    c = l[R](),
                    u = c.isHorizontal(),
                    h = t.get(P),
                    d = ["itemStyle", _, "barBorderWidth"];
                o.diff(s).add(function(t) {
                    if (o.hasValue(t)) {
                        var e = r(t);
                        o.setItemGraphicEl(t, e), a.add(e) } })[Te](function(i, l) {
                    var c = s[k](l);
                    if (!o.hasValue(i)) return void a[we](c);
                    c || (c = r(i, !0));
                    var u = o[D](i),
                        h = o[T](i).get(d) || 0;
                    e(u, h), n[C](c, { shape: u }, t), o.setItemGraphicEl(i, c), a.add(c) })[we](function(e) {
                    var i = s[k](e);
                    i && (i.style.text = "", n[C](i, { shape: { width: 0 } }, t, function() { a[we](i) })) }).execute(), this._updateStyle(t, o, u), this._data = o }, _updateStyle: function(t, e, r) {
                function a(t, e, i, r, a) { n.setText(t, e, i), t.text = r, "outside" === t.textPosition && (t.textPosition = a) }
                e[z](function(o, s) {
                    var l = e[T](s),
                        c = e[x](s, "color"),
                        u = e[x](s, Z),
                        h = e[D](s),
                        d = l[Oe]("itemStyle.normal"),
                        f = l[Oe]("itemStyle.emphasis").getBarItemStyle();
                    o.setShape("r", d.get("barBorderRadius") || 0), o[H](i[xe]({ fill: c, opacity: u }, d.getBarItemStyle()));
                    var p = r ? h[Ae] > 0 ? ke : "top" : h.width > 0 ? "left" : "right",
                        m = l[Oe]("label.normal"),
                        v = l[Oe]("label.emphasis"),
                        b = o.style;
                    m.get("show") ? a(b, m, c, i.retrieve(t.getFormattedLabel(s, _), t.getRawValue(s)), p) : b.text = "", v.get("show") ? a(f, v, c, i.retrieve(t.getFormattedLabel(s, y), t.getRawValue(s)), p) : f.text = "", n[g](o, f) }) }, remove: function(t) {
                var e = this.group;
                t.get(P) ? this._data && this._data[z](function(i) { i.style.text = "", n[C](i, { shape: { width: 0 } }, t, function() { e[we](i) }) }) : e[J]() } }) }), e("echarts/layout/barGrid", [We, He, "../util/number"], function(t) {
        function e(t) {
            return t.get("stack") || "__ec_stack_" + t[ce] }

        function i(t) {
            var i = {};
            r.each(t, function(t) {
                var n = t[K],
                    r = n[R](),
                    a = i[r.index] || { remainedWidth: r.getBandWidth(), autoWidthCount: 0, categoryGap: "20%", gap: "30%", axis: r, stacks: {} },
                    o = a.stacks;
                i[r.index] = a;
                var s = e(t);
                o[s] || a.autoWidthCount++, o[s] = o[s] || { width: 0, maxWidth: 0 };
                var l = t.get("barWidth"),
                    c = t.get("barMaxWidth"),
                    u = t.get("barGap"),
                    h = t.get("barCategoryGap");
                l && !o[s].width && (l = Math.min(a.remainedWidth, l), o[s].width = l, a.remainedWidth -= l), c && (o[s].maxWidth = c), null != u && (a.gap = u), null != h && (a.categoryGap = h) });
            var n = {};
            return r.each(i, function(t, e) { n[e] = {};
                var i = t.stacks,
                    a = t.axis,
                    s = a.getBandWidth(),
                    l = o(t.categoryGap, s),
                    c = o(t.gap, 1),
                    u = t.remainedWidth,
                    h = t.autoWidthCount,
                    d = (u - l) / (h + (h - 1) * c);
                d = Math.max(d, 0), r.each(i, function(t) {
                    var e = t.maxWidth;!t.width && e && d > e && (e = Math.min(e, u), u -= e, t.width = e, h--) }), d = (u - l) / (h + (h - 1) * c), d = Math.max(d, 0);
                var f, p = 0;
                r.each(i, function(t) { t.width || (t.width = d), f = t, p += t.width * (1 + c) }), f && (p -= f.width * c);
                var m = -p / 2;
                r.each(i, function(t, i) { n[e][i] = n[e][i] || { offset: m, width: t.width }, m += t.width * (1 + c) }) }), n }

        function n(t, n) {
            var a = i(r[Ge](n.getSeriesByType(t), function(t) {
                    return !n.isSeriesFiltered(t) && t[K] && "cartesian2d" === t[K].type })),
                o = {};
            n.eachSeriesByType(t, function(t) {
                var i = t[Ze](),
                    n = t[K],
                    r = n[R](),
                    s = e(t),
                    l = a[r.index][s],
                    c = l.offset,
                    u = l.width,
                    h = n.getOtherAxis(r),
                    d = t.get("barMinHeight") || 0,
                    f = r.onZero ? h.toGlobalCoord(h.dataToCoord(0)) : h.getGlobalExtent()[0],
                    p = n.dataToPoints(i, !0);
                o[s] = o[s] || [], i.setLayout({ offset: c, size: u }), i.each(h.dim, function(t, e) {
                    if (!isNaN(t)) { o[s][e] || (o[s][e] = { p: f, n: f });
                        var n, r, a, l, m = t >= 0 ? "p" : "n",
                            v = p[e],
                            g = o[s][e][m];
                        h.isHorizontal() ? (n = g, r = v[1] + c, a = v[0] - g, l = u, Math.abs(a) < d && (a = (0 > a ? -1 : 1) * d), o[s][e][m] += a) : (n = v[0] + c, r = g, a = u, l = v[1] - g, Math.abs(l) < d && (l = (0 >= l ? -1 : 1) * d), o[s][e][m] += l), i.setItemLayout(e, { x: n, y: r, width: a, height: l }) } }, !0) }, this) }
        var r = t(He),
            a = t("../util/number"),
            o = a[v];
        return n }), e("echarts/chart/pie/PieSeries", [We, "../../data/List", He, "../../util/model", "../../data/helper/completeDimensions", "../helper/dataSelectableMixin", b], function(t) {
        var e = t("../../data/List"),
            i = t(He),
            n = t("../../util/model"),
            r = t("../../data/helper/completeDimensions"),
            a = t("../helper/dataSelectableMixin"),
            o = t(b).extendSeriesModel({ type: "series.pie", init: function(t) { o.superApply(this, "init", arguments), this.legendDataProvider = function() {
                        return this._dataBeforeProcessed }, this.updateSelectedMap(), this._defaultLabelLine(t) }, mergeOption: function(t) { o.superCall(this, "mergeOption", t), this.updateSelectedMap() }, getInitialData: function(t) {
                    var i = r(["value"], t.data),
                        n = new e(i, this);
                    return n.initData(t.data), n }, getDataParams: function(t) {
                    var e = this._data,
                        i = o.superCall(this, le, t),
                        n = e.getSum("value");
                    return i.percent = n ? +(e.get("value", t) / n * 100)[m](2) : 0, i.$vars.push("percent"), i }, _defaultLabelLine: function(t) { n.defaultEmphasis(t.labelLine, ["show"]);
                    var e = t.labelLine[_],
                        i = t.labelLine[y];
                    e.show = e.show && t.label[_].show, i.show = i.show && t.label[y].show }, defaultOption: { zlevel: 0, z: 2, legendHoverLink: !0, hoverAnimation: !0, center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, minAngle: 0, selectedOffset: 10, avoidLabelOverlap: !0, label: { normal: { rotate: !1, show: !0, position: "outer" }, emphasis: {} }, labelLine: { normal: { show: !0, length: 15, length2: 15, smooth: !1, lineStyle: { width: 1, type: "solid" } } }, itemStyle: { normal: { borderColor: "rgba(0,0,0,0)", borderWidth: 1 }, emphasis: { borderColor: "rgba(0,0,0,0)", borderWidth: 1 } }, animationEasing: "cubicOut", data: [] } });
        return i.mixin(o, a), o }), e("echarts/chart/pie/PieView", [We, B, He, "../../view/Chart"], function(t) {
        function e(t, e, n, r) {
            var a = e[Ze](),
                o = this[ue],
                s = a[p](o),
                l = e.get("selectedOffset");
            r[_e]({ type: "pieToggleSelect", from: t, name: s, seriesId: e.id }), a.each(function(t) { i(a[k](t), a[D](t), e.isSelected(a[p](t)), l, n) }) }

        function i(t, e, i, n, r) {
            var a = (e.startAngle + e.endAngle) / 2,
                o = Math.cos(a),
                s = Math.sin(a),
                l = i ? n : 0,
                c = [o * l, s * l];
            r ? t.animate().when(200, { position: c }).start("bounceOut") : t.attr(W, c) }

        function n(t, e) {
            function i() { o[Le] = o.hoverIgnore, s[Le] = s.hoverIgnore }

            function n() { o[Le] = o.normalIgnore, s[Le] = s.normalIgnore }
            a.Group.call(this);
            var r = new a.Sector({ z2: 2 }),
                o = new a.Polyline,
                s = new a.Text;
            this.add(r), this.add(o), this.add(s), this[L](t, e, !0), this.on(y, i).on(_, n).on(fe, i).on(de, n) }

        function r(t, e, i, n, r) {
            var a = n[Oe](Q),
                s = r === f || "inner" === r;
            return { fill: a[X]() || (s ? "#fff" : t[x](e, "color")), textFont: a[Y](), text: o.retrieve(t.hostModel.getFormattedLabel(e, i), t[p](e)) } }
        var a = t(B),
            o = t(He),
            s = n[Ee];
        s[L] = function(t, e, n) {
            function r() { l.stopAnimation(!0), l.animateTo({ shape: { r: h.r + 10 } }, 300, "elasticOut") }

            function s() { l.stopAnimation(!0), l.animateTo({ shape: { r: h.r } }, 300, "elasticOut") }
            var l = this.childAt(0),
                c = t.hostModel,
                u = t[T](e),
                h = t[D](e),
                d = o[be]({}, h);
            d.label = null, n ? (l.setShape(d), l.shape.endAngle = h.startAngle, a[C](l, { shape: { endAngle: h.endAngle } }, c)) : a[C](l, { shape: d }, c);
            var f = u[Oe]("itemStyle"),
                p = t[x](e, "color");
            l[H](o[xe]({ fill: p }, f[Oe](_).getItemStyle())), l.hoverStyle = f[Oe](y).getItemStyle(), i(this, t[D](e), u.get("selected"), c.get("selectedOffset"), c.get(P)), l.off(fe).off(de).off(y).off(_), u.get("hoverAnimation") && l.on(fe, r).on(de, s).on(y, r).on(_, s), this._updateLabel(t, e), a[g](this) }, s._updateLabel = function(t, e) {
            var i = this.childAt(1),
                n = this.childAt(2),
                o = t.hostModel,
                s = t[T](e),
                l = t[D](e),
                c = l.label,
                u = t[x](e, "color");
            a[C](i, { shape: { points: c.linePoints || [
                        [c.x, c.y],
                        [c.x, c.y],
                        [c.x, c.y]
                    ] } }, o), a[C](n, { style: { x: c.x, y: c.y } }, o), n.attr({ style: { textVerticalAlign: c.verticalAlign, textAlign: c[$], textFont: c.font }, rotation: c[d], origin: [c.x, c.y], z2: 10 });
            var h = s[Oe]("label.normal"),
                f = s[Oe]("label.emphasis"),
                p = s[Oe]("labelLine.normal"),
                m = s[Oe]("labelLine.emphasis"),
                v = h.get(W) || f.get(W);
            n[H](r(t, e, _, h, v)), n[Le] = n.normalIgnore = !h.get("show"), n.hoverIgnore = !f.get("show"), i[Le] = i.normalIgnore = !p.get("show"), i.hoverIgnore = !m.get("show"), i[H]({ stroke: u }), i[H](p[Oe]("lineStyle").getLineStyle()), n.hoverStyle = r(t, e, y, f, v), i.hoverStyle = m[Oe]("lineStyle").getLineStyle();
            var g = p.get("smooth");
            g && g === !0 && (g = .4), i.setShape({ smooth: g }) }, o[te](n, a.Group);
        var l = t("../../view/Chart")[be]({ type: "pie", init: function() {
                var t = new a.Group;
                this._sectorGroup = t }, render: function(t, i, r, a) {
                if (!a || a.from !== this.uid) {
                    var s = t[Ze](),
                        l = this._data,
                        c = this.group,
                        u = i.get(P),
                        h = !l,
                        d = o.curry(e, this.uid, t, u, r),
                        f = t.get("selectedMode");
                    if (s.diff(l).add(function(t) {
                            var e = new n(s, t);
                            h && e.eachChild(function(t) { t.stopAnimation(!0) }), f && e.on("click", d), s.setItemGraphicEl(t, e), c.add(e) })[Te](function(t, e) {
                            var i = l[k](e);
                            i[L](s, t), i.off("click"), f && i.on("click", d), c.add(i), s.setItemGraphicEl(t, i) })[we](function(t) {
                            var e = l[k](t);
                            c[we](e) }).execute(), u && h && s.count() > 0) {
                        var p = s[D](0),
                            m = Math.max(r[Ie](), r[De]()) / 2,
                            v = o.bind(c.removeClipPath, c);
                        c.setClipPath(this._createClipPath(p.cx, p.cy, m, p.startAngle, p.clockwise, v, t)) }
                    this._data = s } }, _createClipPath: function(t, e, i, n, r, o, s) {
                var l = new a.Sector({ shape: { cx: t, cy: e, r0: 0, r: i, startAngle: n, endAngle: n, clockwise: r } });
                return a.initProps(l, { shape: { endAngle: n + (r ? 1 : -1) * Math.PI * 2 } }, s, o), l } });
        return l }), e("echarts/action/createDataSelectAction", [We, "../echarts", He], function(t) {
        var e = t("../echarts"),
            i = t(He);
        return function(t, n) { i.each(n, function(i) { i[Te] = "updateView", e.registerAction(i, function(e, n) {
                    var r = {};
                    return n[ze]({ mainType: "series", subType: t, query: e }, function(t) { t[i.method] && t[i.method](e.name);
                        var n = t[Ze]();
                        n.each(function(e) {
                            var i = n[p](e);
                            r[i] = t.isSelected(i) || !1 }) }), { name: e.name, selected: r } }) }) } }), e("echarts/visual/dataColor", [We], function() {
        return function(t, e) {
            var i = e.get("color"),
                n = 0;
            e.eachRawSeriesByType(t, function(t) {
                var r = t.get("color", !0),
                    a = t.getRawData();
                if (!e.isSeriesFiltered(t)) {
                    var o = t[Ze]();
                    o.each(function(t) {
                        var e = o[T](t),
                            s = o.getRawIndex(t),
                            l = o[x](t, "color", !0);
                        if (l) a.setItemVisual(s, "color", l);
                        else {
                            var c = r ? r[s % r[ye]] : i[(s + n) % i[ye]],
                                u = e.get("itemStyle.normal.color") || c;
                            a.setItemVisual(s, "color", u), o.setItemVisual(t, "color", u) } }) }
                n += a.count() }) } }), e("echarts/chart/pie/pieLayout", [We, h, "./labelLayout", He], function(t) {
        var e = t(h),
            i = e[v],
            n = t("./labelLayout"),
            r = t(He),
            a = 2 * Math.PI,
            o = Math.PI / 180;
        return function(t, s, l) { s.eachSeriesByType(t, function(t) {
                var s = t.get(q),
                    c = t.get(O);
                r[re](c) || (c = [0, c]), r[re](s) || (s = [s, s]);
                var u = l[Ie](),
                    h = l[De](),
                    d = Math.min(u, h),
                    f = i(s[0], u),
                    p = i(s[1], h),
                    m = i(c[0], d / 2),
                    v = i(c[1], d / 2),
                    g = t[Ze](),
                    y = -t.get("startAngle") * o,
                    x = t.get("minAngle") * o,
                    _ = g.getSum("value"),
                    b = Math.PI / (_ || g.count()) * 2,
                    w = t.get("clockwise"),
                    M = t.get("roseType"),
                    S = g.getDataExtent("value");
                S[0] = 0;
                var T = a,
                    C = 0,
                    A = y,
                    k = w ? 1 : -1;
                if (g.each("value", function(t, i) {
                        var n;
                        n = "area" !== M ? 0 === _ ? b : t * b : a / (g.count() || 1), x > n ? (n = x, T -= x) : C += t;
                        var r = A + k * n;
                        g.setItemLayout(i, { angle: n, startAngle: A, endAngle: r, clockwise: w, cx: f, cy: p, r0: m, r: M ? e.linearMap(t, S, [m, v]) : v }), A = r }, !0), a > T)
                    if (.001 >= T) {
                        var L = a / g.count();
                        g.each(function(t) {
                            var e = g[D](t);
                            e.startAngle = y + k * t * L, e.endAngle = y + k * (t + 1) * L }) } else b = T / C, A = y, g.each("value", function(t, e) {
                        var i = g[D](e),
                            n = i.angle === x ? x : t * b;
                        i.startAngle = A, i.endAngle = A + k * n, A += n });
                n(t, v, u, h) }) } }), e("echarts/processor/dataFilter", [], function() {
        return function(t, e) {
            var i = e.findComponents({ mainType: "legend" });
            i && i[ye] && e.eachSeriesByType(t, function(t) {
                var e = t[Ze]();
                e.filterSelf(function(t) {
                    for (var n = e[p](t), r = 0; r < i[ye]; r++)
                        if (!i[r].isSelected(n)) return !1;
                    return !0 }, this) }, this) } }), e("echarts/model/Global", [We, He, "../util/model", "./Model", "./Component", "./globalDefault"], function(t) {
        function e(t, e) {
            for (var i in e) x.hasClass(i) || ("object" == typeof e[i] ? t[i] = t[i] ? c.merge(t[i], e[i], !1) : c.clone(e[i]) : null == t[i] && (t[i] = e[i])) }

        function i(t) { t = t, this[u] = {}, this[u][b] = 1, this._componentsMap = {}, this._seriesIndices = null, e(t, this._theme[u]), c.merge(t, _, !1), this.mergeOption(t) }

        function n(t, e) { c[re](e) || (e = e ? [e] : []);
            var i = {};
            return f(e, function(e) { i[e] = (t[e] || []).slice() }), i }

        function r(t, e) {
            var i = {};
            f(e, function(t) {
                var e = t.exist;
                e && (i[e.id] = t) }), f(e, function(e) {
                var n = e[u];
                if (c.assert(!n || null == n.id || !i[n.id] || i[n.id] === e, "id duplicates: " + (n && n.id)), n && null != n.id && (i[n.id] = e), y(n)) {
                    var r = a(t, n, e.exist);
                    e.keyInfo = { mainType: t, subType: r } } }), f(e, function(t) {
                var e = t.exist,
                    n = t[u],
                    r = t.keyInfo;
                if (y(n)) {
                    if (r.name = null != n.name ? n.name + "" : e ? e.name : "\x00-", e) r.id = e.id;
                    else if (null != n.id) r.id = n.id + "";
                    else {
                        var a = 0;
                        do r.id = "\x00" + r.name + "\x00" + a++; while (i[r.id]) }
                    i[r.id] = t } }) }

        function a(t, e, i) {
            var n = e.type ? e.type : i ? i.subType : x.determineSubType(t, e);
            return n }

        function o(t) {
            return m(t, function(t) {
                return t.componentIndex }) || [] }

        function s(t, e) {
            return e.hasOwnProperty("subType") ? p(t, function(t) {
                return t.subType === e.subType }) : t }

        function l(t) {
            if (!t._seriesIndices) throw new Error("Series has not been initialized yet.") }
        var c = t(He),
            h = t("../util/model"),
            d = t("./Model"),
            f = c.each,
            p = c[Ge],
            m = c.map,
            v = c[re],
            g = c[ne],
            y = c[Me],
            x = t("./Component"),
            _ = t("./globalDefault"),
            b = "\x00_ec_inner",
            w = d[be]({ constructor: w, init: function(t, e, i, n) { i = i || {}, this[u] = null, this._theme = new d(i), this._optionManager = n }, setOption: function(t, e) { c.assert(!(b in t), "please use chart.getOption()"), this._optionManager.setOption(t, e), this.resetOption() }, resetOption: function(t) {
                    var e = !1,
                        n = this._optionManager;
                    if (!t || "recreate" === t) {
                        var r = n.mountOption("recreate" === t);
                        this[u] && "recreate" !== t ? (this.restoreData(), this.mergeOption(r)) : i.call(this, r), e = !0 }
                    if (("timeline" === t || "media" === t) && this.restoreData(), !t || "recreate" === t || "timeline" === t) {
                        var a = n.getTimelineOption(this);
                        a && (this.mergeOption(a), e = !0) }
                    if (!t || "recreate" === t || "media" === t) {
                        var o = n.getMediaOption(this, this._api);
                        o[ye] && f(o, function(t) { this.mergeOption(t, e = !0) }, this) }
                    return e }, mergeOption: function(t) {
                    function e(e, s) {
                        var l = h.normalizeToArray(t[e]),
                            d = h.mappingToExists(a[e], l);
                        r(e, d);
                        var p = n(a, s);
                        i[e] = [], a[e] = [], f(d, function(t, n) {
                            var r = t.exist,
                                o = t[u];
                            if (c.assert(y(o) || r, "Empty component definition"), o) {
                                var s = x.getClass(e, t.keyInfo.subType, !0);
                                r && r instanceof s ? (r.mergeOption(o, this), r.optionUpdated(this)) : (r = new s(o, this, this, c[be]({ dependentModels: p, componentIndex: n }, t.keyInfo)), r.optionUpdated(this)) } else r.mergeOption({}, this), r.optionUpdated(this);
                            a[e][n] = r, i[e][n] = r[u] }, this), e === me && (this._seriesIndices = o(a[me])) }
                    var i = this[u],
                        a = this._componentsMap,
                        s = [];
                    f(t, function(t, e) { null != t && (x.hasClass(e) ? s.push(e) : i[e] = null == i[e] ? c.clone(t) : c.merge(i[e], t, !0)) }), x.topologicalTravel(s, x.getAllClassMainTypes(), e, this) }, getOption: function() {
                    var t = c.clone(this[u]);
                    return f(t, function(e, i) {
                        if (x.hasClass(i)) {
                            for (var e = h.normalizeToArray(e), n = e[ye] - 1; n >= 0; n--) h.isIdInner(e[n]) && e[pe](n, 1);
                            t[i] = e } }), delete t[b], t }, getTheme: function() {
                    return this._theme }, getComponent: function(t, e) {
                    var i = this._componentsMap[t];
                    return i ? i[e || 0] : void 0 }, queryComponents: function(t) {
                    var e = t.mainType;
                    if (!e) return [];
                    var i = t.index,
                        n = t.id,
                        r = t.name,
                        a = this._componentsMap[e];
                    if (!a || !a[ye]) return [];
                    var o;
                    if (null != i) v(i) || (i = [i]), o = p(m(i, function(t) {
                        return a[t] }), function(t) {
                        return !!t });
                    else if (null != n) {
                        var l = v(n);
                        o = p(a, function(t) {
                            return l && g(n, t.id) >= 0 || !l && t.id === n }) } else if (null != r) {
                        var c = v(r);
                        o = p(a, function(t) {
                            return c && g(r, t.name) >= 0 || !c && t.name === r }) }
                    return s(o, t) }, findComponents: function(t) {
                    function e(t) {
                        var e = r + "Index",
                            i = r + "Id",
                            n = r + "Name";
                        return t && (t.hasOwnProperty(e) || t.hasOwnProperty(i) || t.hasOwnProperty(n)) ? { mainType: r, index: t[e], id: t[i], name: t[n] } : null }

                    function i(e) {
                        return t[Ge] ? p(e, t[Ge]) : e }
                    var n = t.query,
                        r = t.mainType,
                        a = e(n),
                        o = a ? this.queryComponents(a) : this._componentsMap[r];
                    return i(s(o, t)) }, eachComponent: function(t, e, i) {
                    var n = this._componentsMap;
                    if (typeof t === ie) i = e, e = t, f(n, function(t, n) { f(t, function(t, r) { e.call(i, n, t, r) }) });
                    else if (c.isString(t)) f(n[t], e, i);
                    else if (y(t)) {
                        var r = this.findComponents(t);
                        f(r, e, i) } }, getSeriesByName: function(t) {
                    var e = this._componentsMap[me];
                    return p(e, function(e) {
                        return e.name === t }) }, getSeriesByIndex: function(t) {
                    return this._componentsMap[me][t] }, getSeriesByType: function(t) {
                    var e = this._componentsMap[me];
                    return p(e, function(e) {
                        return e.subType === t }) }, getSeries: function() {
                    return this._componentsMap[me].slice() }, eachSeries: function(t, e) { l(this), f(this._seriesIndices, function(i) {
                        var n = this._componentsMap[me][i];
                        t.call(e, n, i) }, this) }, eachRawSeries: function(t, e) { f(this._componentsMap[me], t, e) }, eachSeriesByType: function(t, e, i) { l(this), f(this._seriesIndices, function(n) {
                        var r = this._componentsMap[me][n];
                        r.subType === t && e.call(i, r, n) }, this) }, eachRawSeriesByType: function(t, e, i) {
                    return f(this.getSeriesByType(t), e, i) }, isSeriesFiltered: function(t) {
                    return l(this), c[ne](this._seriesIndices, t.componentIndex) < 0 }, filterSeries: function(t, e) { l(this);
                    var i = p(this._componentsMap[me], t, e);
                    this._seriesIndices = o(i) }, restoreData: function() {
                    var t = this._componentsMap;
                    this._seriesIndices = o(t[me]);
                    var e = [];
                    f(t, function(t, i) { e.push(i) }), x.topologicalTravel(e, x.getAllClassMainTypes(), function(e) { f(t[e], function(t) { t.restoreData() }) }) } });
        return w }), e("echarts/CoordinateSystem", [We], function() {
        function t() { this._coordinateSystems = [] }
        var e = {};
        return t[Ee] = { constructor: t, create: function(t, i) {
                var n = [];
                for (var r in e) {
                    var a = e[r][Ce](t, i);
                    a && (n = n[E](a)) }
                this._coordinateSystems = n }, update: function(t, e) {
                for (var i = this._coordinateSystems, n = 0; n < i[ye]; n++) i[n][Te] && i[n][Te](t, e) } }, t.register = function(t, i) { e[t] = i }, t.get = function(t) {
            return e[t] }, t }), e("echarts/ExtensionAPI", [We, He], function(t) {
        function e(t) { i.each(n, function(e) { this[e] = i.bind(t[e], t) }, this) }
        var i = t(He),
            n = ["getDom", "getZr", Ie, De, _e, "on", "off", "getDataURL", "getConnectedDataURL", Oe, "getOption"];
        return e }), e("echarts/model/OptionManager", [We, He, "../util/model", "./Component"], function(t) {
        function e(t) { this._api = t, this._timelineOptions = [], this._mediaList = [], this._mediaDefault, this._currentMediaIndices = [], this._optionBackup, this._newOptionBackup }

        function i(t, e) {
            var i, n, r = [],
                a = [],
                o = t.timeline;
            if (t.baseOption && (n = t.baseOption), (o || t.options) && (n = n || {}, r = (t.options || []).slice()), t.media) { n = n || {};
                var l = t.media;
                h(l, function(t) { t && t[u] && (t.query ? a.push(t) : i || (i = t)) }) }
            return n || (n = t), n.timeline || (n.timeline = o), h([n][E](r)[E](s.map(a, function(t) {
                return t[u] })), function(t) { h(e, function(e) { e(t) }) }), { baseOption: n, timelineOptions: r, mediaDefault: i, mediaList: a } }

        function n(t, e, i) {
            var n = { width: e, height: i, aspectratio: e / i },
                a = !0;
            return s.each(t, function(t, e) {
                var i = e.match(m);
                if (i && i[1] && i[2]) {
                    var o = i[1],
                        s = i[2][Ve]();
                    r(n[s], t, o) || (a = !1) } }), a }

        function r(t, e, i) {
            return "min" === i ? t >= e : "max" === i ? e >= t : t === e }

        function a(t, e) {
            return t.join(",") === e.join(",") }

        function o(t, e) { e = e || {}, h(e, function(e, i) {
                if (null != e) {
                    var n = t[i];
                    if (c.hasClass(i)) { e = l.normalizeToArray(e), n = l.normalizeToArray(n);
                        var r = l.mappingToExists(n, e);
                        t[i] = f(r, function(t) {
                            return t[u] && t.exist ? p(t.exist, t[u], !0) : t.exist || t[u] }) } else t[i] = p(n, e, !0) } }) }
        var s = t(He),
            l = t("../util/model"),
            c = t("./Component"),
            h = s.each,
            d = s.clone,
            f = s.map,
            p = s.merge,
            m = /^(min|max)?(.+)$/;
        return e[Ee] = { constructor: e, setOption: function(t, e) { t = d(t, !0);
                var n = this._optionBackup,
                    r = this._newOptionBackup = i.call(this, t, e);
                n ? (o(n.baseOption, r.baseOption), r.timelineOptions[ye] && (n.timelineOptions = r.timelineOptions), r.mediaList[ye] && (n.mediaList = r.mediaList), r.mediaDefault && (n.mediaDefault = r.mediaDefault)) : this._optionBackup = r }, mountOption: function(t) {
                var e = t ? this._optionBackup : this._newOptionBackup;
                return this._timelineOptions = f(e.timelineOptions, d), this._mediaList = f(e.mediaList, d), this._mediaDefault = d(e.mediaDefault), this._currentMediaIndices = [], d(e.baseOption) }, getTimelineOption: function(t) {
                var e, i = this._timelineOptions;
                if (i[ye]) {
                    var n = t[M]("timeline");
                    n && (e = d(i[n.getCurrentIndex()], !0)) }
                return e }, getMediaOption: function() {
                var t = this._api[Ie](),
                    e = this._api[De](),
                    i = this._mediaList,
                    r = this._mediaDefault,
                    o = [],
                    s = [];
                if (!i[ye] && !r) return s;
                for (var l = 0, c = i[ye]; c > l; l++) n(i[l].query, t, e) && o.push(l);
                return !o[ye] && r && (o = [-1]), o[ye] && !a(o, this._currentMediaIndices) && (s = f(o, function(t) {
                    return d(-1 === t ? r[u] : i[t][u]) })), this._currentMediaIndices = o, s } }, e }), e("echarts/model/Component", [We, "./Model", He, "../util/component", "../util/clazz", "../util/layout", "./mixin/boxLayout"], function(t) {
        function e(t) {
            var e = [];
            return n.each(l.getClassesByMainType(t), function(t) { r.apply(e, t[Ee].dependencies || []) }), n.map(e, function(t) {
                return o.parseClassType(t).main }) }
        var i = t("./Model"),
            n = t(He),
            r = Array[Ee].push,
            a = t("../util/component"),
            o = t("../util/clazz"),
            s = t("../util/layout"),
            l = i[be]({ type: "component", id: "", name: "", mainType: "", subType: "", componentIndex: 0, defaultOption: null, ecModel: null, dependentModels: [], uid: null, layoutMode: null, init: function() { this.mergeDefaultAndTheme(this[u], this[c]) }, mergeDefaultAndTheme: function(t, e) {
                    var i = this.layoutMode,
                        r = i ? s.getLayoutParams(t) : {},
                        a = e.getTheme();
                    n.merge(t, a.get(this.mainType)), n.merge(t, this.getDefaultOption()), i && s.mergeLayoutParam(t, r, i) }, mergeOption: function(t) { n.merge(this[u], t, !0);
                    var e = this.layoutMode;
                    e && s.mergeLayoutParam(this[u], t, e) }, optionUpdated: function() {}, getDefaultOption: function() {
                    if (!this.hasOwnProperty("__defaultOption")) {
                        for (var t = [], e = this.constructor; e;) {
                            var i = e[Ee].defaultOption;
                            i && t.push(i), e = e.superClass }
                        for (var r = {}, a = t[ye] - 1; a >= 0; a--) r = n.merge(r, t[a], !0);
                        this.__defaultOption = r }
                    return this.__defaultOption } });
        return o.enableClassExtend(l, function(t, e, i, r) { n[be](this, r), this.uid = a.getUID("componentModel") }), o.enableClassManagement(l, { registerWhenExtend: !0 }), a.enableSubTypeDefaulter(l), a.enableTopologicalTravel(l, e), n.mixin(l, t("./mixin/boxLayout")), l }), e("echarts/model/Series", [We, He, "../util/format", "../util/model", "./Component"], function(t) {
        var e = t(He),
            i = t("../util/format"),
            n = t("../util/model"),
            r = t("./Component"),
            a = i.encodeHTML,
            o = i.addCommas,
            s = r[be]({ type: "series.__base__", seriesIndex: 0, coordinateSystem: null, defaultOption: null, legendDataProvider: null, init: function(t, e, i) { this[ce] = this.componentIndex, this.mergeDefaultAndTheme(t, i), this._dataBeforeProcessed = this.getInitialData(t, i), this._data = this._dataBeforeProcessed.cloneShallow() }, mergeDefaultAndTheme: function(t, i) { e.merge(t, i.getTheme().get(this.subType)), e.merge(t, this.getDefaultOption()), n.defaultEmphasis(t.label, [W, "show", Q, "distance", "formatter"]);
                    for (var r = t.data || [], a = 0; a < r[ye]; a++) r[a] && r[a].label && n.defaultEmphasis(r[a].label, [W, "show", Q, "distance", "formatter"]) }, mergeOption: function(t, i) { t = e.merge(this[u], t, !0);
                    var n = this.getInitialData(t, i);
                    n && (this._data = n, this._dataBeforeProcessed = n.cloneShallow()) }, getInitialData: function() {}, getData: function() {
                    return this._data }, setData: function(t) { this._data = t }, getRawData: function() {
                    return this._dataBeforeProcessed }, getRawDataArray: function() {
                    return this[u].data }, coordDimToDataDim: function(t) {
                    return [t] }, dataDimToCoordDim: function(t) {
                    return t }, getBaseAxis: function() {
                    var t = this[K];
                    return t && t[R] && t[R]() }, formatTooltip: function(t, i) {
                    var n = this._data,
                        r = this.getRawValue(t),
                        s = e[re](r) ? e.map(r, o).join(", ") : o(r),
                        l = n[p](t),
                        c = n[x](t, "color"),
                        u = '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + c + '"></span>';
                    return i ? u + a(this.name) + " : " + s : a(this.name) + "<br />" + u + (l ? a(l) + " : " + s : s) }, restoreData: function() { this._data = this._dataBeforeProcessed.cloneShallow() } });
        return e.mixin(s, n.dataFormatMixin), s }), e("echarts/view/Component", [We, "zrender/container/Group", "../util/component", "../util/clazz"], function(t) {
        var e = t("zrender/container/Group"),
            i = t("../util/component"),
            n = t("../util/clazz"),
            r = function() { this.group = new e, this.uid = i.getUID("viewComponent") };
        r[Ee] = { constructor: r, init: function() {}, render: function() {}, dispose: function() {} };
        var a = r[Ee];
        return a.updateView = a[Se] = a.updateVisual = function() {}, n.enableClassExtend(r), n.enableClassManagement(r, { registerWhenExtend: !0 }), r }), e("echarts/util/graphic", [We, He, "zrender/tool/path", "zrender/graphic/Path", "zrender/tool/color", "zrender/core/matrix", Fe, "zrender/graphic/Gradient", "zrender/container/Group", "zrender/graphic/Image", "zrender/graphic/Text", "zrender/graphic/shape/Circle", "zrender/graphic/shape/Sector", "zrender/graphic/shape/Ring", "zrender/graphic/shape/Polygon", "zrender/graphic/shape/Polyline", "zrender/graphic/shape/Rect", "zrender/graphic/shape/Line", "zrender/graphic/shape/BezierCurve", "zrender/graphic/shape/Arc", "zrender/graphic/LinearGradient", "zrender/graphic/RadialGradient", "zrender/core/BoundingRect"], function(t) {
        function e(t) {
            if (!t.__isHover) {
                if (t.__hoverStlDirty) {
                    var e = t.style[o],
                        i = t.style.fill,
                        n = t.__hoverStl,
                        r = M.lift;
                    n.fill = n.fill || i && (i instanceof A ? i : r(i, -.1)), n[o] = n[o] || e && (e instanceof A ? e : r(e, -.1));
                    var a = {};
                    for (var s in n) n.hasOwnProperty(s) && (a[s] = t.style[s]);
                    t.__normalStl = a, t.__hoverStlDirty = !1 }
                t[H](t.__hoverStl), t.z2 += 1, t.__isHover = !0 } }

        function i(t) {
            if (t.__isHover) {
                var e = t.__normalStl;
                e && t[H](e), t.z2 -= 1, t.__isHover = !1 } }

        function n(t) { "group" === t.type ? t[oe](function(t) { "group" !== t.type && e(t) }) : e(t) }

        function r(t) { "group" === t.type ? t[oe](function(t) { "group" !== t.type && i(t) }) : i(t) }

        function c(t, e) { t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0 }

        function u() {!this.__isEmphasis && n(this) }

        function h() {!this.__isEmphasis && r(this) }

        function d() { this.__isEmphasis = !0, n(this) }

        function p() { this.__isEmphasis = !1, r(this) }

        function m(t, e, i, n, r) {
            var a = t ? "Update" : "",
                o = n && n.getShallow("animationDuration" + a),
                s = n && n.getShallow("animationEasing" + a);
            n && n.getShallow(P) ? e.animateTo(i, o, s, r) : (e.attr(i), r && r()) }
        var v = t(He),
            x = t("zrender/tool/path"),
            b = Math.round,
            w = t("zrender/graphic/Path"),
            M = t("zrender/tool/color"),
            S = t("zrender/core/matrix"),
            T = t(Fe),
            A = t("zrender/graphic/Gradient"),
            k = {};
        return k.Group = t("zrender/container/Group"), k.Image = t("zrender/graphic/Image"), k.Text = t("zrender/graphic/Text"), k.Circle = t("zrender/graphic/shape/Circle"), k.Sector = t("zrender/graphic/shape/Sector"), k.Ring = t("zrender/graphic/shape/Ring"), k.Polygon = t("zrender/graphic/shape/Polygon"), k.Polyline = t("zrender/graphic/shape/Polyline"), k.Rect = t("zrender/graphic/shape/Rect"), k.Line = t("zrender/graphic/shape/Line"), k.BezierCurve = t("zrender/graphic/shape/BezierCurve"), k.Arc = t("zrender/graphic/shape/Arc"), k.LinearGradient = t("zrender/graphic/LinearGradient"), k.RadialGradient = t("zrender/graphic/RadialGradient"), k.BoundingRect = t("zrender/core/BoundingRect"), k.extendShape = function(t) {
            return w[be](t) }, k.extendPath = function(t, e) {
            return x.extendFromString(t, e) }, k.makePath = function(t, e, i, n) {
            var r = x.createFromString(t, e),
                a = r[U]();
            if (i) {
                var o = a.width / a[Ae];
                if (n === q) {
                    var s, l = i[Ae] * o;
                    l <= i.width ? s = i[Ae] : (l = i.width, s = l / o);
                    var c = i.x + i.width / 2,
                        u = i.y + i[Ae] / 2;
                    i.x = c - l / 2, i.y = u - s / 2, i.width = l, i[Ae] = s }
                this.resizePath(r, i) }
            return r }, k.mergePath = x.mergePath, k.resizePath = function(t, e) {
            if (t[l]) {
                var i = t[U](),
                    n = i.calculateTransform(e);
                t[l](n) } }, k.subPixelOptimizeLine = function(t) {
            var e = k.subPixelOptimize,
                i = t.shape,
                n = t.style[s];
            return b(2 * i.x1) === b(2 * i.x2) && (i.x1 = i.x2 = e(i.x1, n, !0)), b(2 * i.y1) === b(2 * i.y2) && (i.y1 = i.y2 = e(i.y1, n, !0)), t }, k.subPixelOptimizeRect = function(t) {
            var e = k.subPixelOptimize,
                i = t.shape,
                n = t.style[s],
                r = i.x,
                a = i.y,
                o = i.width,
                l = i[Ae];
            return i.x = e(i.x, n, !0), i.y = e(i.y, n, !0), i.width = Math.max(e(r + o, n, !1) - i.x, 0 === o ? 0 : 1), i[Ae] = Math.max(e(a + l, n, !1) - i.y, 0 === l ? 0 : 1), t }, k.subPixelOptimize = function(t, e, i) {
            var n = b(2 * t);
            return (n + b(e)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2 }, k[g] = function(t, e) { "group" === t.type ? t[oe](function(t) { "group" !== t.type && c(t, e) }) : c(t, e), t.on(fe, u).on(de, h), t.on(y, d).on(_, p) }, k.setText = function(t, e, i) {
            var n = e.getShallow(W) || f,
                r = n[ne](f) >= 0 ? "white" : i,
                a = e[Oe](Q);
            v[be](t, { textDistance: e.getShallow("distance") || 5, textFont: a[Y](), textPosition: n, textFill: a[X]() || r }) }, k[C] = v.curry(m, !0), k.initProps = v.curry(m, !1), k.getTransform = function(t, e) {
            for (var i = S.identity([]); t && t !== e;) S.mul(i, t.getLocalTransform(), i), t = t[a];
            return i }, k[l] = function(t, e, i) {
            return i && (e = S.invert([], e)), T[l]([], t, e) }, k.transformDirection = function(t, e, i) {
            var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0]),
                r = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2]),
                a = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -r : t === ke ? r : 0];
            return a = k[l](a, e, i), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? ke : "top" }, k }), e("echarts/view/Chart", [We, "zrender/container/Group", "../util/component", "../util/clazz"], function(t) {
        function e() { this.group = new r, this.uid = a.getUID("viewChart") }

        function i(t, e) {
            if (t && (t[ge](e), "group" === t.type))
                for (var n = 0; n < t.childCount(); n++) i(t.childAt(n), e) }

        function n(t, e, n) {
            if (null != e[ue]) {
                var r = t[k](e[ue]);
                i(r, n) } else if (e.name) {
                var a = t.indexOfName(e.name),
                    r = t[k](a);
                i(r, n) } else t[z](function(t) { i(t, n) }) }
        var r = t("zrender/container/Group"),
            a = t("../util/component"),
            o = t("../util/clazz");
        e[Ee] = { type: "chart", init: function() {}, render: function() {}, highlight: function(t, e, i, r) { n(t[Ze](), r, y) }, downplay: function(t, e, i, r) { n(t[Ze](), r, _) }, remove: function() { this.group[J]() }, dispose: function() {} };
        var s = e[Ee];
        return s.updateView = s[Se] = s.updateVisual = function(t, e, i, n) { this.render(t, e, i, n) }, o.enableClassExtend(e), o.enableClassManagement(e, { registerWhenExtend: !0 }), e }), e("zrender/zrender", [We, "./core/guid", "./core/env", "./Handler", "./Storage", "./animation/Animation", "./Painter"], function(t) {
        function e(t) {
            delete c[t]
        }
        var i = t("./core/guid"),
            n = t("./core/env"),
            r = t("./Handler"),
            a = t("./Storage"),
            o = t("./animation/Animation"),
            s = !n[Pe],
            l = { canvas: t("./Painter") },
            c = {},
            u = {};
        u.version = "3.0.8", u.init = function(t, e) {
            var n = new h(i(), t, e);
            return c[n.id] = n, n }, u.dispose = function(t) {
            if (t) t.dispose();
            else {
                for (var e in c) c[e].dispose();
                c = {} }
            return u }, u.getInstance = function(t) {
            return c[t] }, u.registerPainter = function(t, e) { l[t] = e };
        var h = function(t, e, i) { i = i || {}, this.dom = e, this.id = t;
            var c = this,
                u = new a,
                h = i.renderer;
            if (s) {
                if (!l.vml) throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                h = "vml" } else h && l[h] || (h = "canvas");
            var d = new l[h](e, u, i);
            this.storage = u, this.painter = d, n.node || (this.handler = new r(d.getViewportRoot(), u, d)), this[P] = new o({ stage: { update: function() { c._needsRefresh && c.refreshImmediately() } } }), this[P].start(), this._needsRefresh;
            var f = u.delFromMap,
                p = u.addToMap;
            u.delFromMap = function(t) {
                var e = u.get(t);
                f.call(u, t), e && e.removeSelfFromZr(c) }, u.addToMap = function(t) { p.call(u, t), t.addSelfToZr(c) } };
        return h[Ee] = { constructor: h, getId: function() {
                return this.id }, add: function(t) { this.storage.addRoot(t), this._needsRefresh = !0 }, remove: function(t) { this.storage.delRoot(t), this._needsRefresh = !0 }, configLayer: function(t, e) { this.painter.configLayer(t, e), this._needsRefresh = !0 }, refreshImmediately: function() { this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1 }, refresh: function() { this._needsRefresh = !0 }, resize: function() { this.painter[Re](), this.handler && this.handler[Re]() }, clearAnimation: function() { this[P].clear() }, getWidth: function() {
                return this.painter[Ie]() }, getHeight: function() {
                return this.painter[De]() }, toDataURL: function(t, e, i) {
                return this.painter.toDataURL(t, e, i) }, pathToImage: function(t, e, n) {
                var r = i();
                return this.painter.pathToImage(r, t, e, n) }, setDefaultCursorStyle: function(t) { this.handler.setDefaultCursorStyle(t) }, on: function(t, e, i) { this.handler && this.handler.on(t, e, i) }, off: function(t, e) { this.handler && this.handler.off(t, e) }, trigger: function(t, e) { this.handler && this.handler[ge](t, e) }, clear: function() { this.storage.delRoot(), this.painter.clear() }, dispose: function() { this[P].stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler && this.handler.dispose(), this[P] = this.storage = this.painter = this.handler = null, e(this.id) } }, u
    }), e("zrender/tool/color", [We], function() {
        function t(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 255 ? 255 : t }

        function e(t) {
            return t = Math.round(t), 0 > t ? 0 : t > 360 ? 360 : t }

        function i(t) {
            return 0 > t ? 0 : t > 1 ? 1 : t }

        function n(e) {
            return t(e[ye] && "%" === e.charAt(e[ye] - 1) ? parseFloat(e) / 100 * 255 : parseInt(e, 10)) }

        function r(t) {
            return i(t[ye] && "%" === t.charAt(t[ye] - 1) ? parseFloat(t) / 100 : parseFloat(t)) }

        function a(t, e, i) {
            return 0 > i ? i += 1 : i > 1 && (i -= 1), 1 > 6 * i ? t + (e - t) * i * 6 : 1 > 2 * i ? e : 2 > 3 * i ? t + (e - t) * (2 / 3 - i) * 6 : t }

        function o(t, e, i) {
            return t + (e - t) * i }

        function s(t) {
            if (t) { t += "";
                var e = t[ae](/ /g, "")[Ve]();
                if (e in y) return y[e].slice();
                if ("#" !== e.charAt(0)) {
                    var i = e[ne]("("),
                        a = e[ne](")");
                    if (-1 !== i && a + 1 === e[ye]) {
                        var o = e.substr(0, i),
                            s = e.substr(i + 1, a - (i + 1)).split(","),
                            c = 1;
                        switch (o) {
                            case "rgba":
                                if (4 !== s[ye]) return;
                                c = r(s.pop());
                            case "rgb":
                                if (3 !== s[ye]) return;
                                return [n(s[0]), n(s[1]), n(s[2]), c];
                            case "hsla":
                                if (4 !== s[ye]) return;
                                return s[3] = r(s[3]), l(s);
                            case "hsl":
                                if (3 !== s[ye]) return;
                                return l(s);
                            default:
                                return } } } else {
                    if (4 === e[ye]) {
                        var u = parseInt(e.substr(1), 16);
                        if (!(u >= 0 && 4095 >= u)) return;
                        return [(3840 & u) >> 4 | (3840 & u) >> 8, 240 & u | (240 & u) >> 4, 15 & u | (15 & u) << 4, 1] }
                    if (7 === e[ye]) {
                        var u = parseInt(e.substr(1), 16);
                        if (!(u >= 0 && 16777215 >= u)) return;
                        return [(16711680 & u) >> 16, (65280 & u) >> 8, 255 & u, 1] } } } }

        function l(e) {
            var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360,
                n = r(e[1]),
                o = r(e[2]),
                s = .5 >= o ? o * (n + 1) : o + n - o * n,
                l = 2 * o - s,
                c = [t(255 * a(l, s, i + 1 / 3)), t(255 * a(l, s, i)), t(255 * a(l, s, i - 1 / 3))];
            return 4 === e[ye] && (c[3] = e[3]), c }

        function c(t) {
            if (t) {
                var e, i, n = t[0] / 255,
                    r = t[1] / 255,
                    a = t[2] / 255,
                    o = Math.min(n, r, a),
                    s = Math.max(n, r, a),
                    l = s - o,
                    c = (s + o) / 2;
                if (0 === l) e = 0, i = 0;
                else { i = .5 > c ? l / (s + o) : l / (2 - s - o);
                    var u = ((s - n) / 6 + l / 2) / l,
                        h = ((s - r) / 6 + l / 2) / l,
                        d = ((s - a) / 6 + l / 2) / l;
                    n === s ? e = d - h : r === s ? e = 1 / 3 + u - d : a === s && (e = 2 / 3 + h - u), 0 > e && (e += 1), e > 1 && (e -= 1) }
                var f = [360 * e, i, c];
                return null != t[3] && f.push(t[3]), f } }

        function u(t, e) {
            var i = s(t);
            if (i) {
                for (var n = 0; 3 > n; n++) i[n] = 0 > e ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0;
                return g(i, 4 === i[ye] ? "rgba" : "rgb") } }

        function h(t) {
            var e = s(t);
            return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0 }

        function d(e, i, n) {
            if (i && i[ye] && e >= 0 && 1 >= e) { n = n || [0, 0, 0, 0];
                var r = e * (i[ye] - 1),
                    a = Math.floor(r),
                    s = Math.ceil(r),
                    l = i[a],
                    c = i[s],
                    u = r - a;
                return n[0] = t(o(l[0], c[0], u)), n[1] = t(o(l[1], c[1], u)), n[2] = t(o(l[2], c[2], u)), n[3] = t(o(l[3], c[3], u)), n } }

        function f(e, n, r) {
            if (n && n[ye] && e >= 0 && 1 >= e) {
                var a = e * (n[ye] - 1),
                    l = Math.floor(a),
                    c = Math.ceil(a),
                    u = s(n[l]),
                    h = s(n[c]),
                    d = a - l,
                    f = g([t(o(u[0], h[0], d)), t(o(u[1], h[1], d)), t(o(u[2], h[2], d)), i(o(u[3], h[3], d))], "rgba");
                return r ? { color: f, leftIndex: l, rightIndex: c, value: a } : f } }

        function p(t, e) {
            if (!(2 !== t[ye] || t[1] < t[0])) {
                for (var i = f(t[0], e, !0), n = f(t[1], e, !0), r = [{ color: i.color, offset: 0 }], a = n.value - i.value, o = Math.max(i.value, i.rightIndex), s = Math.min(n.value, n.leftIndex), l = o; a > 0 && s >= l; l++) r.push({ color: e[l], offset: (l - i.value) / a });
                return r.push({ color: n.color, offset: 1 }), r } }

        function m(t, i, n, a) {
            return t = s(t), t ? (t = c(t), null != i && (t[0] = e(i)), null != n && (t[1] = r(n)), null != a && (t[2] = r(a)), g(l(t), "rgba")) : void 0 }

        function v(t, e) {
            return t = s(t), t && null != e ? (t[3] = i(e), g(t, "rgba")) : void 0 }

        function g(t, e) {
            return ("rgb" === e || "hsv" === e || "hsl" === e) && (t = t.slice(0, 3)), e + "(" + t.join(",") + ")" }
        var y = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        return { parse: s, lift: u, toHex: h, fastMapToColor: d, mapToColor: f, mapIntervalToColor: p, modifyHSL: m, modifyAlpha: v, stringify: g } }), e("zrender/core/env", [], function() {
        function t(t) {
            var e = {},
                i = {},
                n = t.match(/Web[kK]it[\/]{0,1}([\d.]+)/),
                r = t.match(/(Android);?[\s\/]+([\d.]+)?/),
                a = t.match(/(iPad).*OS\s([\d_]+)/),
                o = t.match(/(iPod)(.*OS\s([\d_]+))?/),
                s = !a && t.match(/(iPhone\sOS)\s([\d_]+)/),
                l = t.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
                c = l && t.match(/TouchPad/),
                u = t.match(/Kindle\/([\d.]+)/),
                h = t.match(/Silk\/([\d._]+)/),
                d = t.match(/(BlackBerry).*Version\/([\d.]+)/),
                f = t.match(/(BB10).*Version\/([\d.]+)/),
                p = t.match(/(RIM\sTablet\sOS)\s([\d.]+)/),
                m = t.match(/PlayBook/),
                v = t.match(/Chrome\/([\d.]+)/) || t.match(/CriOS\/([\d.]+)/),
                g = t.match(/Firefox\/([\d.]+)/),
                y = n && t.match(/Mobile\//) && !v,
                x = t.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !v,
                _ = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/),
                b = t.match(/Edge\/([\d.]+)/);
            return (i.webkit = !!n) && (i.version = n[1]), r && (e.android = !0, e.version = r[2]), s && !o && (e.ios = e.iphone = !0, e.version = s[2][ae](/_/g, ".")), a && (e.ios = e.ipad = !0, e.version = a[2][ae](/_/g, ".")), o && (e.ios = e.ipod = !0, e.version = o[3] ? o[3][ae](/_/g, ".") : null), l && (e.webos = !0, e.version = l[2]), c && (e.touchpad = !0), d && (e.blackberry = !0, e.version = d[2]), f && (e.bb10 = !0, e.version = f[2]), p && (e.rimtabletos = !0, e.version = p[2]), m && (i.playbook = !0), u && (e.kindle = !0, e.version = u[1]), h && (i.silk = !0, i.version = h[1]), !h && e.android && t.match(/Kindle Fire/) && (i.silk = !0), v && (i.chrome = !0, i.version = v[1]), g && (i.firefox = !0, i.version = g[1]), _ && (i.ie = !0, i.version = _[1]), y && (t.match(/Safari/) || e.ios) && (i.safari = !0), x && (i.webview = !0), _ && (i.ie = !0, i.version = _[1]), b && (i.edge = !0, i.version = b[1]), e.tablet = !!(a || m || r && !t.match(/Mobile/) || g && t.match(/Tablet/) || _ && !t.match(/Phone/) && t.match(/Touch/)), e.phone = !(e.tablet || e.ipod || !(r || s || l || d || f || v && t.match(/Android/) || v && t.match(/CriOS\/([\d.]+)/) || g && t.match(/Mobile/) || _ && t.match(/Touch/))), { browser: i, os: e, node: !1, canvasSupported: document[N]("canvas")[V] ? !0 : !1, touchEventsSupported: "ontouchstart" in window && !i.ie && !i.edge, pointerEventsSupported: "onpointerdown" in window && (i.edge || i.ie && i.version >= 10) } }
        var e = {};
        return e = typeof navigator === r ? { browser: {}, os: {}, node: !0, canvasSupported: !0 } : t(navigator.userAgent) }), e("zrender/mixin/Eventful", [We, n], function(t) {
        var e = Array[Ee].slice,
            i = t(n),
            r = i[ne],
            a = function() { this._$handlers = {} };
        return a[Ee] = { constructor: a, one: function(t, e, i) {
                var n = this._$handlers;
                return e && t ? (n[t] || (n[t] = []), r(n[t], t) >= 0 ? this : (n[t].push({ h: e, one: !0, ctx: i || this }), this)) : this }, on: function(t, e, i) {
                var n = this._$handlers;
                return e && t ? (n[t] || (n[t] = []), n[t].push({ h: e, one: !1, ctx: i || this }), this) : this }, isSilent: function(t) {
                var e = this._$handlers;
                return e[t] && e[t][ye] }, off: function(t, e) {
                var i = this._$handlers;
                if (!t) return this._$handlers = {}, this;
                if (e) {
                    if (i[t]) {
                        for (var n = [], r = 0, a = i[t][ye]; a > r; r++) i[t][r].h != e && n.push(i[t][r]);
                        i[t] = n }
                    i[t] && 0 === i[t][ye] && delete i[t] } else delete i[t];
                return this }, trigger: function(t) {
                if (this._$handlers[t]) {
                    var i = arguments,
                        n = i[ye];
                    n > 3 && (i = e.call(i, 1));
                    for (var r = this._$handlers[t], a = r[ye], o = 0; a > o;) {
                        switch (n) {
                            case 1:
                                r[o].h.call(r[o].ctx);
                                break;
                            case 2:
                                r[o].h.call(r[o].ctx, i[1]);
                                break;
                            case 3:
                                r[o].h.call(r[o].ctx, i[1], i[2]);
                                break;
                            default:
                                r[o].h.apply(r[o].ctx, i) }
                        r[o].one ? (r[pe](o, 1), a--) : o++ } }
                return this }, triggerWithContext: function(t) {
                if (this._$handlers[t]) {
                    var i = arguments,
                        n = i[ye];
                    n > 4 && (i = e.call(i, 1, i[ye] - 1));
                    for (var r = i[i[ye] - 1], a = this._$handlers[t], o = a[ye], s = 0; o > s;) {
                        switch (n) {
                            case 1:
                                a[s].h.call(r);
                                break;
                            case 2:
                                a[s].h.call(r, i[1]);
                                break;
                            case 3:
                                a[s].h.call(r, i[1], i[2]);
                                break;
                            default:
                                a[s].h.apply(r, i) }
                        a[s].one ? (a[pe](s, 1), o--) : s++ } }
                return this } }, a }), e("echarts/loading/default", [We, "../util/graphic", He], function(t) {
        var e = t("../util/graphic"),
            i = t(He),
            n = Math.PI;
        return function(t, r) { r = r || {}, i[xe](r, { text: "loading", color: "#c23531", textColor: "#000", maskColor: "rgba(255, 255, 255, 0.8)", zlevel: 0 });
            var a = new e.Rect({ style: { fill: r.maskColor }, zlevel: r[se], z: 1e4 }),
                o = new e.Arc({ shape: { startAngle: -n / 2, endAngle: -n / 2 + .1, r: 10 }, style: { stroke: r.color, lineCap: "round", lineWidth: 5 }, zlevel: r[se], z: 10001 }),
                s = new e.Rect({ style: { fill: "none", text: r.text, textPosition: "right", textDistance: 10, textFill: r.textColor }, zlevel: r[se], z: 10001 });
            o.animateShape(!0).when(1e3, { endAngle: 3 * n / 2 }).start("circularInOut"), o.animateShape(!0).when(1e3, { startAngle: 3 * n / 2 }).delay(300).start("circularInOut");
            var l = new e.Group;
            return l.add(o), l.add(s), l.add(a), l[Re] = function() {
                var e = t[Ie]() / 2,
                    i = t[De]() / 2;
                o.setShape({ cx: e, cy: i });
                var n = o.shape.r;
                s.setShape({ x: e - n, y: i - n, width: 2 * n, height: 2 * n }), a.setShape({ x: 0, y: 0, width: t[Ie](), height: t[De]() }) }, l[Re](), l } }), e("echarts/visual/seriesColor", [We, "zrender/graphic/Gradient"], function(t) {
        var e = t("zrender/graphic/Gradient");
        return function(t, i, n) {
            function r(t) {
                var r = [i, _, "color"],
                    a = n.get("color"),
                    o = t[Ze](),
                    s = t.get(r) || a[t[ce] % a[ye]];
                o.setVisual("color", s), n.isSeriesFiltered(t) || (typeof s !== ie || s instanceof e || o.each(function(e) { o.setItemVisual(e, "color", s(t[le](e))) }), o.each(function(t) {
                    var e = o[T](t),
                        i = e.get(r, !0);
                    null != i && o.setItemVisual(t, "color", i) })) }
            t ? n.eachSeriesByType(t, r) : n[ve](r) } }), e("echarts/preprocessor/backwardCompat", [We, He, "./helper/compatStyle"], function(t) {
        function e(t, e) { e = e.split(",");
            for (var i = t, n = 0; n < e[ye] && (i = i && i[e[n]], null != i); n++);
            return i }

        function i(t, e, i, n) { e = e.split(",");
            for (var r, a = t, o = 0; o < e[ye] - 1; o++) r = e[o], null == a[r] && (a[r] = {}), a = a[r];
            (n || null == a[e[o]]) && (a[e[o]] = i) }

        function n(t) { c(o, function(e) { e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]) }) }
        var r = t(He),
            a = t("./helper/compatStyle"),
            o = [
                ["x", "left"],
                ["y", "top"],
                ["x2", "right"],
                ["y2", ke]
            ],
            s = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"],
            l = ["bar", "boxplot", "candlestick", "chord", "effectScatter", "funnel", "gauge", "lines", "graph", "heatmap", "line", "map", "parallel", "pie", "radar", "sankey", "scatter", "treemap"],
            c = r.each;
        return function(t) { c(t[me], function(t) {
                if (r[Me](t)) {
                    var o = t.type;
                    if (a(t), ("pie" === o || "gauge" === o) && null != t.clockWise && (t.clockwise = t.clockWise), "gauge" === o) {
                        var s = e(t, "pointer.color");
                        null != s && i(t, "itemStyle.normal.color", s) }
                    for (var c = 0; c < l[ye]; c++)
                        if (l[c] === t.type) { n(t);
                            break } } }), t.dataRange && (t.visualMap = t.dataRange), c(s, function(e) {
                var i = t[e];
                i && (r[re](i) || (i = [i]), c(i, function(t) { n(t) })) }) } }), e("echarts/util/number", [We], function() {
        function t(t) {
            return t[ae](/^\s+/, "")[ae](/\s+$/, "") }
        var e = {},
            i = 1e-4;
        return e.linearMap = function(t, e, i, n) {
            var r = e[1] - e[0];
            if (0 === r) return (i[0] + i[1]) / 2;
            var a = (t - e[0]) / r;
            return n && (a = Math.min(Math.max(a, 0), 1)), a * (i[1] - i[0]) + i[0] }, e[v] = function(e, i) {
            switch (e) {
                case q:
                case j:
                    e = "50%";
                    break;
                case "left":
                case "top":
                    e = "0%";
                    break;
                case "right":
                case ke:
                    e = "100%" }
            return typeof e === Be ? t(e).match(/%$/) ? parseFloat(e) / 100 * i : parseFloat(e) : null == e ? 0 / 0 : +e }, e.round = function(t) {
            return +(+t)[m](10) }, e.asc = function(t) {
            return t.sort(function(t, e) {
                return t - e }), t }, e.getPrecision = function(t) {
            if (isNaN(t)) return 0;
            for (var e = 1, i = 0; Math.round(t * e) / e !== t;) e *= 10, i++;
            return i }, e.getPixelPrecision = function(t, e) {
            var i = Math.log,
                n = Math.LN10,
                r = Math.floor(i(t[1] - t[0]) / n),
                a = Math.round(i(Math.abs(e[1] - e[0])) / n);
            return Math.max(-r + a, 0) }, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = function(t) {
            var e = 2 * Math.PI;
            return (t % e + e) % e }, e.isRadianAroundZero = function(t) {
            return t > -i && i > t }, e.parseDate = function(t) {
            return t instanceof Date ? t : new Date(typeof t === Be ? t[ae](/-/g, "/") : Math.round(t)) }, e.nice = function(t, e) {
            var i, n = Math.floor(Math.log(t) / Math.LN10),
                r = Math.pow(10, n),
                a = t / r;
            return i = e ? 1.5 > a ? 1 : 2.5 > a ? 2 : 4 > a ? 3 : 7 > a ? 5 : 10 : 1 > a ? 1 : 2 > a ? 2 : 3 > a ? 3 : 5 > a ? 5 : 10, i * r }, e }), e("zrender/core/matrix", [], function() {
        var t = typeof Float32Array === r ? Array : Float32Array,
            e = { create: function() {
                    var i = new t(6);
                    return e.identity(i), i }, identity: function(t) {
                    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t }, copy: function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t }, mul: function(t, e, i) {
                    var n = e[0] * i[0] + e[2] * i[1],
                        r = e[1] * i[0] + e[3] * i[1],
                        a = e[0] * i[2] + e[2] * i[3],
                        o = e[1] * i[2] + e[3] * i[3],
                        s = e[0] * i[4] + e[2] * i[5] + e[4],
                        l = e[1] * i[4] + e[3] * i[5] + e[5];
                    return t[0] = n, t[1] = r, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t }, translate: function(t, e, i) {
                    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + i[0], t[5] = e[5] + i[1], t }, rotate: function(t, e, i) {
                    var n = e[0],
                        r = e[2],
                        a = e[4],
                        o = e[1],
                        s = e[3],
                        l = e[5],
                        c = Math.sin(i),
                        u = Math.cos(i);
                    return t[0] = n * u + o * c, t[1] = -n * c + o * u, t[2] = r * u + s * c, t[3] = -r * c + u * s, t[4] = u * a + c * l, t[5] = u * l - c * a, t }, scale: function(t, e, i) {
                    var n = i[0],
                        r = i[1];
                    return t[0] = e[0] * n, t[1] = e[1] * r, t[2] = e[2] * n, t[3] = e[3] * r, t[4] = e[4] * n, t[5] = e[5] * r, t }, invert: function(t, e) {
                    var i = e[0],
                        n = e[2],
                        r = e[4],
                        a = e[1],
                        o = e[3],
                        s = e[5],
                        l = i * o - a * n;
                    return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = i * l, t[4] = (n * s - o * r) * l, t[5] = (a * r - i * s) * l, t) : null } };
        return e }), e("echarts/util/format", [We, He, "./number"], function(t) {
        function e(t) {
            return isNaN(t) ? "-" : (t = (t + "").split("."), t[0][ae](/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t[ye] > 1 ? "." + t[1] : "")) }

        function i(t) {
            return t[Ve]()[ae](/-(.)/g, function(t, e) {
                return e.toUpperCase() }) }

        function n(t) {
            var e = t[ye];
            return typeof t === ee ? [t, t, t, t] : 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t }

        function r(t) {
            return String(t)[ae](/&/g, "&amp;")[ae](/</g, "&lt;")[ae](/>/g, "&gt;")[ae](/"/g, "&quot;")[ae](/'/g, "&#39;") }

        function a(t, e) {
            return "{" + t + (null == e ? "" : e) + "}" }

        function o(t, e) { c[re](e) || (e = [e]);
            var i = e[ye];
            if (!i) return "";
            for (var n = e[0].$vars, r = 0; r < n[ye]; r++) {
                var o = h[r];
                t = t[ae](a(o), a(o, 0)) }
            for (var s = 0; i > s; s++)
                for (var l = 0; l < n[ye]; l++) t = t[ae](a(h[l], s), e[s][n[l]]);
            return t }

        function s(t, e) {
            ("week" === t || "month" === t || "quarter" === t || "half-year" === t || "year" === t) && (t = "MM-dd\nyyyy");
            var i = u.parseDate(e),
                n = i.getFullYear(),
                r = i.getMonth() + 1,
                a = i.getDate(),
                o = i.getHours(),
                s = i.getMinutes(),
                c = i.getSeconds();
            return t = t[ae]("MM", l(r))[Ve]()[ae]("yyyy", n)[ae]("yy", n % 100)[ae]("dd", l(a))[ae]("d", a)[ae]("hh", l(o))[ae]("h", o)[ae]("mm", l(s))[ae]("m", s)[ae]("ss", l(c))[ae]("s", c) }

        function l(t) {
            return 10 > t ? "0" + t : t }
        var c = t(He),
            u = t("./number"),
            h = ["a", "b", "c", "d", "e", "f", "g"];
        return { normalizeCssArray: n, addCommas: e, toCamelCase: i, encodeHTML: r, formatTpl: o, formatTime: s } }), e(Fe, [], function() {
        var t = typeof Float32Array === r ? Array : Float32Array,
            e = { create: function(e, i) {
                    var n = new t(2);
                    return n[0] = e || 0, n[1] = i || 0, n }, copy: function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t }, clone: function(e) {
                    var i = new t(2);
                    return i[0] = e[0], i[1] = e[1], i }, set: function(t, e, i) {
                    return t[0] = e, t[1] = i, t }, add: function(t, e, i) {
                    return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t }, scaleAndAdd: function(t, e, i, n) {
                    return t[0] = e[0] + i[0] * n, t[1] = e[1] + i[1] * n, t }, sub: function(t, e, i) {
                    return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t }, len: function(t) {
                    return Math.sqrt(this.lenSquare(t)) }, lenSquare: function(t) {
                    return t[0] * t[0] + t[1] * t[1] }, mul: function(t, e, i) {
                    return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t }, div: function(t, e, i) {
                    return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t }, dot: function(t, e) {
                    return t[0] * e[0] + t[1] * e[1] }, scale: function(t, e, i) {
                    return t[0] = e[0] * i, t[1] = e[1] * i, t }, normalize: function(t, i) {
                    var n = e.len(i);
                    return 0 === n ? (t[0] = 0, t[1] = 0) : (t[0] = i[0] / n, t[1] = i[1] / n), t }, distance: function(t, e) {
                    return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) }, distanceSquare: function(t, e) {
                    return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) }, negate: function(t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t }, lerp: function(t, e, i, n) {
                    return t[0] = e[0] + n * (i[0] - e[0]), t[1] = e[1] + n * (i[1] - e[1]), t }, applyTransform: function(t, e, i) {
                    var n = e[0],
                        r = e[1];
                    return t[0] = i[0] * n + i[2] * r + i[4], t[1] = i[1] * n + i[3] * r + i[5], t }, min: function(t, e, i) {
                    return t[0] = Math.min(e[0], i[0]), t[1] = Math.min(e[1], i[1]), t }, max: function(t, e, i) {
                    return t[0] = Math.max(e[0], i[0]), t[1] = Math.max(e[1], i[1]), t } };
        return e[ye] = e.len, e.lengthSquare = e.lenSquare, e.dist = e.distance, e.distSquare = e.distanceSquare, e }), e("echarts/component/axis", [We, "../coord/cartesian/AxisModel", "./axis/AxisView"], function(t) { t("../coord/cartesian/AxisModel"), t("./axis/AxisView") }), e("echarts/util/layout", [We, He, "zrender/core/BoundingRect", "./number", "./format"], function(t) {
        function e(t, e, i, n, r) {
            var a = 0,
                o = 0;
            null == n && (n = 1 / 0), null == r && (r = 1 / 0);
            var s = 0;
            e.eachChild(function(l, c) {
                var u, h, d = l[W],
                    f = l[U](),
                    p = e.childAt(c + 1),
                    m = p && p[U]();
                if ("horizontal" === t) {
                    var v = f.width + (m ? -m.x + f.x : 0);
                    u = a + v, u > n || l.newline ? (a = 0, u = v, o += s + i, s = f[Ae]) : s = Math.max(s, f[Ae]) } else {
                    var g = f[Ae] + (m ? -m.y + f.y : 0);
                    h = o + g, h > r || l.newline ? (a += s + i, o = 0, h = g, s = f.width) : s = Math.max(s, f.width) }
                l.newline || (d[0] = a, d[1] = o, "horizontal" === t ? a = u + i : o = h + i) }) }
        var i = t(He),
            n = t("zrender/core/BoundingRect"),
            r = t("./number"),
            a = t("./format"),
            o = r[v],
            s = i.each,
            l = {},
            c = ["left", "right", "top", ke, "width", Ae];
        return l.box = e, l.vbox = i.curry(e, "vertical"), l.hbox = i.curry(e, "horizontal"), l.getAvailableSize = function(t, e, i) {
            var n = e.width,
                r = e[Ae],
                s = o(t.x, n),
                l = o(t.y, r),
                c = o(t.x2, n),
                u = o(t.y2, r);
            return (isNaN(s) || isNaN(parseFloat(t.x))) && (s = 0), (isNaN(c) || isNaN(parseFloat(t.x2))) && (c = n), (isNaN(l) || isNaN(parseFloat(t.y))) && (l = 0), (isNaN(u) || isNaN(parseFloat(t.y2))) && (u = r), i = a.normalizeCssArray(i || 0), { width: Math.max(c - s - i[1] - i[3], 0), height: Math.max(u - l - i[0] - i[2], 0) } }, l.getLayoutRect = function(t, e, i) { i = a.normalizeCssArray(i || 0);
            var r = e.width,
                s = e[Ae],
                l = o(t.left, r),
                c = o(t.top, s),
                u = o(t.right, r),
                h = o(t[ke], s),
                d = o(t.width, r),
                f = o(t[Ae], s),
                p = i[2] + i[0],
                m = i[1] + i[3],
                v = t.aspect;
            switch (isNaN(d) && (d = r - u - m - l), isNaN(f) && (f = s - h - p - c), isNaN(d) && isNaN(f) && (v > r / s ? d = .8 * r : f = .8 * s), null != v && (isNaN(d) && (d = v * f), isNaN(f) && (f = d / v)), isNaN(l) && (l = r - u - d - m), isNaN(c) && (c = s - h - f - p), t.left || t.right) {
                case q:
                    l = r / 2 - d / 2 - i[3];
                    break;
                case "right":
                    l = r - d - m }
            switch (t.top || t[ke]) {
                case j:
                case q:
                    c = s / 2 - f / 2 - i[0];
                    break;
                case ke:
                    c = s - f - p }
            l = l || 0, c = c || 0, isNaN(d) && (d = r - l - (u || 0)), isNaN(f) && (f = s - c - (h || 0));
            var g = new n(l + i[3], c + i[0], d, f);
            return g.margin = i, g }, l.positionGroup = function(t, e, n, r) {
            var a = t[U]();
            e = i[be](i.clone(e), { width: a.width, height: a[Ae] }), e = l.getLayoutRect(e, n, r), t[W] = [e.x - a.x, e.y - a.y] }, l.mergeLayoutParam = function(t, e, n) {
            function r(i) {
                var r = {},
                    l = 0,
                    c = {},
                    u = 0,
                    h = n.ignoreSize ? 1 : 2;
                if (s(i, function(e) { c[e] = t[e] }), s(i, function(t) { a(e, t) && (r[t] = c[t] = e[t]), o(r, t) && l++, o(c, t) && u++ }), u !== h && l) {
                    if (l >= h) return r;
                    for (var d = 0; d < i[ye]; d++) {
                        var f = i[d];
                        if (!a(r, f) && a(t, f)) { r[f] = t[f];
                            break } }
                    return r }
                return c }

            function a(t, e) {
                return t.hasOwnProperty(e) }

            function o(t, e) {
                return null != t[e] && "auto" !== t[e] }

            function l(t, e, i) { s(t, function(t) { e[t] = i[t] }) }!i[Me](n) && (n = {});
            var c = ["width", "left", "right"],
                u = [Ae, "top", ke],
                h = r(c),
                d = r(u);
            l(c, t, h), l(u, t, d) }, l.getLayoutParams = function(t) {
            return l.copyLayoutParams({}, t) }, l.copyLayoutParams = function(t, e) {
            return e && t && s(c, function(i) { e.hasOwnProperty(i) && (t[i] = e[i]) }), t }, l }), e("echarts/component/legend/LegendModel", [We, He, "../../model/Model", b], function(t) {
        var e = t(He),
            i = t("../../model/Model"),
            n = t(b).extendComponentModel({ type: "legend", dependencies: [me], layoutMode: { type: "box", ignoreSize: !0 }, init: function(t, e, i) { this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateData(i);
                    var n = this._data,
                        r = this[u].selected;
                    if (n[0] && "single" === this.get("selectedMode")) {
                        var a = !1;
                        for (var o in r) r[o] && (this.select(o), a = !0);!a && this.select(n[0].get("name")) } }, mergeOption: function(t) { n.superCall(this, "mergeOption", t), this._updateData(this[c]) }, _updateData: function(t) {
                    var n = e.map(this.get("data") || [], function(t) {
                        return typeof t === Be && (t = { name: t }), new i(t, this, this[c]) }, this);
                    this._data = n;
                    var r = e.map(t.getSeries(), function(t) {
                        return t.name });
                    t[ve](function(t) {
                        if (t.legendDataProvider) {
                            var e = t.legendDataProvider();
                            r = r[E](e.mapArray(e[p])) } }), this._availableNames = r }, getData: function() {
                    return this._data }, select: function(t) {
                    var i = this[u].selected,
                        n = this.get("selectedMode");
                    if ("single" === n) {
                        var r = this._data;
                        e.each(r, function(t) { i[t.get("name")] = !1 }) }
                    i[t] = !0 }, unSelect: function(t) { "single" !== this.get("selectedMode") && (this[u].selected[t] = !1) }, toggleSelected: function(t) {
                    var e = this[u].selected;
                    t in e || (e[t] = !0), this[e[t] ? "unSelect" : "select"](t) }, isSelected: function(t) {
                    var i = this[u].selected;
                    return !(t in i && !i[t]) && e[ne](this._availableNames, t) >= 0 }, defaultOption: { zlevel: 0, z: 4, show: !0, orient: "horizontal", left: "center", top: "top", align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, textStyle: { color: "#333" }, selectedMode: !0 } });
        return n }), e("echarts/component/legend/LegendView", [We, He, "../../util/symbol", B, "../helper/listComponent", b], function(t) {
        function e(t, e) { e[_e]({ type: "legendToggleSelect", name: t }) }

        function i(t, e, i) { t.get("legendHoverLink") && i[_e]({ type: "highlight", seriesName: t.name, name: e }) }

        function n(t, e, i) { t.get("legendHoverLink") && i[_e]({ type: "downplay", seriesName: t.name, name: e }) }
        var r = t(He),
            a = t("../../util/symbol"),
            o = t(B),
            s = t("../helper/listComponent"),
            l = r.curry,
            c = "#ccc";
        return t(b).extendComponentView({ type: "legend", init: function() { this._symbolTypeStore = {} }, render: function(t, a, c) {
                var u = this.group;
                if (u[J](), t.get("show")) {
                    var h = t.get("selectedMode"),
                        d = t.get("align"); "auto" === d && (d = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left");
                    var f = {};
                    r.each(t[Ze](), function(r) {
                        var s = r.get("name");
                        if ("" === s || "\n" === s) return void u.add(new o.Group({ newline: !0 }));
                        var p = a.getSeriesByName(s)[0];
                        if (!f[s])
                            if (p) {
                                var m = p[Ze](),
                                    v = m.getVisual("color");
                                typeof v === ie && (v = v(p[le](0)));
                                var g = m.getVisual("legendSymbol") || "roundRect",
                                    y = m.getVisual("symbol"),
                                    _ = this._createItem(s, r, t, g, y, d, v, h);
                                _.on("click", l(e, s, c)).on(fe, l(i, p, "", c)).on(de, l(n, p, "", c)), f[s] = !0 } else a.eachRawSeries(function(a) {
                                if (!f[s] && a.legendDataProvider) {
                                    var o = a.legendDataProvider(),
                                        u = o.indexOfName(s),
                                        p = o[x](u, "color"),
                                        m = "roundRect",
                                        v = this._createItem(s, r, t, m, null, d, p, h);
                                    v.on("click", l(e, s, c)).on(fe, l(i, a, s, c)).on(de, l(n, a, s, c)), f[s] = !0 } }, this) }, this), s.layout(u, t, c), s.addBackground(u, t) } }, _createItem: function(t, e, i, n, r, s, l, u) {
                var h = i.get("itemWidth"),
                    d = i.get("itemHeight"),
                    f = i.isSelected(t),
                    p = new o.Group,
                    m = e[Oe](Q),
                    v = e.get("icon");
                if (n = v || n, p.add(a.createSymbol(n, 0, 0, h, d, f ? l : c)), !v && r && (r !== n || "none" == r)) {
                    var y = .8 * d; "none" === r && (r = "circle"), p.add(a.createSymbol(r, (h - y) / 2, (d - y) / 2, y, y, f ? l : c)) }
                var x = "left" === s ? h + 5 : -5,
                    _ = s,
                    b = i.get("formatter");
                typeof b === Be && b ? t = b[ae]("{name}", t) : typeof b === ie && (t = b(t));
                var w = new o.Text({ style: { text: t, x: x, y: d / 2, fill: f ? m[X]() : c, textFont: m[Y](), textAlign: _, textVerticalAlign: "middle" } });
                return p.add(w), p.add(new o.Rect({ shape: p[U](), invisible: !0 })), p.eachChild(function(t) { t.silent = !u }), this.group.add(p), o[g](p), p } }) }), e("echarts/component/legend/legendAction", [We, b, He], function(t) {
        function e(t, e, i) {
            var r, a = {},
                o = "toggleSelected" === t;
            return i[ze]("legend", function(i) { o && null != r ? i[r ? "select" : "unSelect"](e.name) : (i[t](e.name), r = i.isSelected(e.name));
                var s = i[Ze]();
                n.each(s, function(t) {
                    var e = t.get("name");
                    if ("\n" !== e && "" !== e) {
                        var n = i.isSelected(e);
                        a[e] = e in a ? a[e] && n : n } }) }), { name: e.name, selected: a } }
        var i = t(b),
            n = t(He);
        i.registerAction("legendToggleSelect", "legendselectchanged", n.curry(e, "toggleSelected")), i.registerAction("legendSelect", "legendselected", n.curry(e, "select")), i.registerAction("legendUnSelect", "legendunselected", n.curry(e, "unSelect")) }), e("echarts/component/tooltip/TooltipModel", [We, b], function(t) { t(b).extendComponentModel({ type: "tooltip", defaultOption: { zlevel: 0, z: 8, show: !0, showContent: !0, trigger: "item", triggerOn: "mousemove", alwaysShowContent: !1, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: "rgba(50,50,50,0.7)", borderColor: "#333", borderRadius: 4, borderWidth: 0, padding: 5, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: !0, animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", lineStyle: { color: "#555", width: 1, type: "solid" }, crossStyle: { color: "#555", width: 1, type: "dashed", textStyle: {} }, shadowStyle: { color: "rgba(150,150,150,0.3)" } }, textStyle: { color: "#fff", fontSize: 14 } } }) }), e("echarts/component/legend/legendFilter", [], function() {
        return function(t) {
            var e = t.findComponents({ mainType: "legend" });
            e && e[ye] && t.filterSeries(function(t) {
                for (var i = 0; i < e[ye]; i++)
                    if (!e[i].isSelected(t.name)) return !1;
                return !0 }) } }), e("echarts/component/marker/MarkLineModel", [We, "../../util/model", b], function(t) {
        var e = t("../../util/model"),
            i = t(b).extendComponentModel({ type: "markLine", dependencies: [me, "grid", "polar"], init: function(t, e, i, n) { this.mergeDefaultAndTheme(t, i), this.mergeOption(t, i, n.createdBySelf, !0) }, mergeOption: function(t, n, r, a) { r || n[ve](function(t) {
                        var r = t.get("markLine"),
                            o = t.markLineModel;
                        if (!r || !r.data) return void(t.markLineModel = null);
                        if (o) o.mergeOption(r, n, !0);
                        else { a && e.defaultEmphasis(r.label, [W, "show", Q, "distance", "formatter"]);
                            var s = { seriesIndex: t[ce], name: t.name, createdBySelf: !0 };
                            o = new i(r, this, n, s) }
                        t.markLineModel = o }, this) }, defaultOption: { zlevel: 0, z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], precision: 2, tooltip: { trigger: "item" }, label: { normal: { show: !0, position: "end" }, emphasis: { show: !0 } }, lineStyle: { normal: { type: "dashed" }, emphasis: { width: 3 } }, animationEasing: "linear" } });
        return i }), e("echarts/component/tooltip/TooltipView", [We, "./TooltipContent", B, He, "../../util/format", h, "zrender/core/env", b], function(t) {
        function e(t, e) {
            if (!t || !e) return !1;
            var i = _.round;
            return i(t[0]) === i(e[0]) && i(t[1]) === i(e[1]) }

        function i(t, e, i, n) {
            return { x1: t, y1: e, x2: i, y2: n } }

        function n(t, e, i, n) {
            return { x: t, y: e, width: i, height: n } }

        function r(t, e, i, n, r, a) {
            return { cx: t, cy: e, r0: i, r: n, startAngle: r, endAngle: a, clockwise: !0 } }

        function a(t, e, i, n, r) {
            var a = i.clientWidth,
                o = i.clientHeight,
                s = 20;
            return t + a + s > n ? t -= a + s : t += s, e + o + s > r ? e -= o + s : e += s, [t, e] }

        function s(t, e, i) {
            var n = i.clientWidth,
                r = i.clientHeight,
                a = 5,
                o = 0,
                s = 0,
                l = e.width,
                c = e[Ae];
            switch (t) {
                case f:
                    o = e.x + l / 2 - n / 2, s = e.y + c / 2 - r / 2;
                    break;
                case "top":
                    o = e.x + l / 2 - n / 2, s = e.y - r - a;
                    break;
                case ke:
                    o = e.x + l / 2 - n / 2, s = e.y + c + a;
                    break;
                case "left":
                    o = e.x - n - a, s = e.y + c / 2 - r / 2;
                    break;
                case "right":
                    o = e.x + l + a, s = e.y + c / 2 - r / 2 }
            return [o, s] }

        function c(t, e, i, n, r, o, c) {
            var u = c[Ie](),
                h = c[De](),
                d = o && o[U]().clone();
            if (o && d[l](o[Ne]), typeof t === ie && (t = t([e, i], r, d)), y[re](t)) e = M(t[0], u), i = M(t[1], h);
            else if (typeof t === Be && o) {
                var f = s(t, d, n.el);
                e = f[0], i = f[1] } else {
                var f = a(e, i, n.el, u, h);
                e = f[0], i = f[1] }
            n.moveTo(e, i) }

        function u(t) {
            var e = t[K],
                i = t.get("tooltip.trigger", !0);
            return !(!e || "cartesian2d" !== e.type && "polar" !== e.type && "single" !== e.type || "item" === i) }
        var d = t("./TooltipContent"),
            g = t(B),
            y = t(He),
            x = t("../../util/format"),
            _ = t(h),
            M = _[v],
            A = t("zrender/core/env");
        t(b).extendComponentView({
            type: "tooltip",
            _axisPointers: {},
            init: function(t, e) {
                if (!A.node) {
                    var i = new d(e.getDom(), e);
                    this._tooltipContent = i, e.on("showTip", this._manuallyShowTip, this), e.on("hideTip", this._manuallyHideTip, this) } },
            render: function(t, e, i) {
                if (!A.node) { this.group[J](), this._axisPointers = {}, this._tooltipModel = t, this._ecModel = e, this._api = i, this._lastHover = {};
                    var n = this._tooltipContent;
                    n[Te](), n.enterable = t.get("enterable"), this._alwaysShowContent = t.get("alwaysShowContent"), this._seriesGroupByAxis = this._prepareAxisTriggerData(t, e);
                    var r = this._crossText;
                    if (r && this.group.add(r), null != this._lastX && null != this._lastY) {
                        var a = this;
                        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() { a._manuallyShowTip({ x: a._lastX, y: a._lastY }) }) }
                    var o = this._api.getZr();
                    o.off("click", this._tryShow), o.off("mousemove", this._mousemove), o.off(de, this._hide), o.off("globalout", this._hide), "click" === t.get("triggerOn") ? o.on("click", this._tryShow, this) : (o.on("mousemove", this._mousemove, this), o.on(de, this._hide, this), o.on("globalout", this._hide, this)) } },
            _mousemove: function(t) {
                var e = this._tooltipModel.get("showDelay"),
                    i = this;
                clearTimeout(this._showTimeout), e > 0 ? this._showTimeout = setTimeout(function() {
                    i._tryShow(t)
                }, e) : this._tryShow(t)
            },
            _manuallyShowTip: function(t) {
                if (t.from !== this.uid) {
                    var e = this._ecModel,
                        i = t[ce],
                        n = t[ue],
                        r = e.getSeriesByIndex(i),
                        a = this._api;
                    if (null == t.x || null == t.y) {
                        if (r || e[ve](function(t) { u(t) && !r && (r = t) }), r) {
                            var o = r[Ze]();
                            null == n && (n = o.indexOfName(t.name));
                            var s, c, h = o[k](n),
                                d = r[K];
                            if (d && d.dataToPoint) {
                                var f = d.dataToPoint(o.getValues(y.map(d[S], function(t) {
                                    return r.coordDimToDataDim(t)[0] }), n, !0));
                                s = f && f[0], c = f && f[1] } else if (h) {
                                var p = h[U]().clone();
                                p[l](h[Ne]), s = p.x + p.width / 2, c = p.y + p[Ae] / 2 }
                            null != s && null != c && this._tryShow({ offsetX: s, offsetY: c, target: h, event: {} }) } } else {
                        var h = a.getZr().handler.findHover(t.x, t.y);
                        this._tryShow({ offsetX: t.x, offsetY: t.y, target: h, event: {} }) } } },
            _manuallyHideTip: function(t) { t.from !== this.uid && this._hide() },
            _prepareAxisTriggerData: function(t, e) {
                var i = {};
                return e[ve](function(t) {
                    if (u(t)) {
                        var e, n, r = t[K]; "cartesian2d" === r.type ? (e = r[R](), n = e.dim + e.index) : "single" === r.type ? (e = r[I](), n = e.dim + e.type) : (e = r[R](), n = e.dim + r.name), i[n] = i[n] || { coordSys: [], series: [] }, i[n].coordSys.push(r), i[n][me].push(t) } }, this), i },
            _tryShow: function(t) {
                var e = t[he],
                    i = this._tooltipModel,
                    n = i.get(ge),
                    r = this._ecModel,
                    a = this._api;
                if (i)
                    if (this._lastX = t.offsetX, this._lastY = t.offsetY, e && null != e[ue]) {
                        var o = e.dataModel || r.getSeriesByIndex(e[ce]),
                            s = e[ue],
                            l = o[Ze]()[T](s); "axis" === (l.get("tooltip.trigger") || n) ? this._showAxisTooltip(i, r, t): (this._ticket = "", this._hideAxisPointer(), this._resetLastHover(), this._showItemTooltipContent(o, s, t)), a[_e]({ type: "showTip", from: this.uid, dataIndex: e[ue], seriesIndex: e[ce] }) } else "item" === n ? this._hide() : this._showAxisTooltip(i, r, t), "cross" === i.get("axisPointer.type") && a[_e]({ type: "showTip", from: this.uid, x: t.offsetX, y: t.offsetY }) },
            _showAxisTooltip: function(t, i, n) {
                var r = t[Oe]("axisPointer"),
                    a = r.get("type");
                if ("cross" === a) {
                    var o = n[he];
                    if (o && null != o[ue]) {
                        var s = i.getSeriesByIndex(o[ce]),
                            l = o[ue];
                        this._showItemTooltipContent(s, l, n) } }
                this._showAxisPointer();
                var c = !0;
                y.each(this._seriesGroupByAxis, function(t) {
                    var i = t.coordSys,
                        o = i[0],
                        s = [n.offsetX, n.offsetY];
                    if (!o.containPoint(s)) return void this._hideAxisPointer(o.name);
                    c = !1;
                    var l = o[S],
                        u = o.pointToData(s, !0);
                    s = o.dataToPoint(u);
                    var h = o[R](),
                        d = r.get("axis"); "auto" === d && (d = h.dim);
                    var f = !1,
                        p = this._lastHover;
                    if ("cross" === a) e(p.data, u) && (f = !0), p.data = u;
                    else {
                        var m = y[ne](l, d);
                        p.data === u[m] && (f = !0), p.data = u[m] } "cartesian2d" !== o.type || f ? "polar" !== o.type || f ? "single" !== o.type || f || this._showSinglePointer(r, o, d, s) : this._showPolarPointer(r, o, d, s) : this._showCartesianPointer(r, o, d, s), "cross" !== a && this._dispatchAndShowSeriesTooltipContent(o, t[me], s, u, f) }, this), c && this._hide() },
            _showCartesianPointer: function(t, e, r, a) {
                function o(n, r, a) {
                    var o = "x" === n ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]),
                        s = l._getPointerElement(e, t, n, o);
                    u ? g[C](s, { shape: o }, t) : s.attr({ shape: o }) }

                function s(i, r, a) {
                    var o = e[I](i),
                        s = o.getBandWidth(),
                        c = a[1] - a[0],
                        h = "x" === i ? n(r[0] - s / 2, a[0], s, c) : n(a[0], r[1] - s / 2, c, s),
                        d = l._getPointerElement(e, t, i, h);
                    u ? g[C](d, { shape: h }, t) : d.attr({ shape: h }) }
                var l = this,
                    c = t.get("type"),
                    u = "cross" !== c;
                if ("cross" === c) o("x", a, e[I]("y").getGlobalExtent()), o("y", a, e[I]("x").getGlobalExtent()), this._updateCrossText(e, a, t);
                else {
                    var h = e[I]("x" === r ? "y" : "x"),
                        d = h.getGlobalExtent(); "cartesian2d" === e.type && ("line" === c ? o : s)(r, a, d) } },
            _showSinglePointer: function(t, e, n, r) {
                function a(n, r, a) {
                    var s = e[I](),
                        c = s.orient,
                        u = "horizontal" === c ? i(r[0], a[0], r[0], a[1]) : i(a[0], r[1], a[1], r[1]),
                        h = o._getPointerElement(e, t, n, u);
                    l ? g[C](h, { shape: u }, t) : h.attr({ shape: u }) }
                var o = this,
                    s = t.get("type"),
                    l = "cross" !== s,
                    c = e.getRect(),
                    u = [c.y, c.y + c[Ae]];
                a(n, r, u) },
            _showPolarPointer: function(t, e, n, a) {
                function o(n, r, a) {
                    var o, s = e.pointToCoord(r);
                    if ("angle" === n) {
                        var c = e.coordToPoint([a[0], s[1]]),
                            u = e.coordToPoint([a[1], s[1]]);
                        o = i(c[0], c[1], u[0], u[1]) } else o = { cx: e.cx, cy: e.cy, r: s[0] };
                    var h = l._getPointerElement(e, t, n, o);
                    d ? g[C](h, { shape: o }, t) : h.attr({ shape: o }) }

                function s(i, n, a) {
                    var o, s = e[I](i),
                        c = s.getBandWidth(),
                        u = e.pointToCoord(n),
                        h = Math.PI / 180;
                    o = "angle" === i ? r(e.cx, e.cy, a[0], a[1], (-u[1] - c / 2) * h, (-u[1] + c / 2) * h) : r(e.cx, e.cy, u[0] - c / 2, u[0] + c / 2, 0, 2 * Math.PI);
                    var f = l._getPointerElement(e, t, i, o);
                    d ? g[C](f, { shape: o }, t) : f.attr({ shape: o }) }
                var l = this,
                    c = t.get("type"),
                    u = e.getAngleAxis(),
                    h = e.getRadiusAxis(),
                    d = "cross" !== c;
                if ("cross" === c) o("angle", a, h[F]()), o(O, a, u[F]()), this._updateCrossText(e, a, t);
                else {
                    var f = e[I](n === O ? "angle" : O),
                        p = f[F]();
                    ("line" === c ? o : s)(n, a, p) } },
            _updateCrossText: function(t, e, i) {
                var n = i[Oe]("crossStyle"),
                    r = n[Oe](Q),
                    a = this._tooltipModel,
                    o = this._crossText;
                o || (o = this._crossText = new g.Text({ style: { textAlign: "left", textVerticalAlign: "bottom" } }), this.group.add(o));
                var s = t.pointToData(e),
                    l = t[S];
                s = y.map(s, function(e, i) {
                    var n = t[I](l[i]);
                    return e = n.type === w || "time" === n.type ? n.scale.getLabel(e) : x.addCommas(e[m](n.getPixelPrecision())) }), o[H]({ fill: r[X]() || n.get("color"), textFont: r[Y](), text: s.join(", "), x: e[0] + 5, y: e[1] - 5 }), o.z = a.get("z"), o[se] = a.get(se) },
            _getPointerElement: function(t, e, i, n) {
                var r = this._tooltipModel,
                    a = r.get("z"),
                    s = r.get(se),
                    l = this._axisPointers,
                    c = t.name;
                if (l[c] = l[c] || {}, l[c][i]) return l[c][i];
                var u = e.get("type"),
                    h = e[Oe](u + "Style"),
                    d = "shadow" === u,
                    f = h[d ? "getAreaStyle" : "getLineStyle"](),
                    p = "polar" === t.type ? d ? "Sector" : i === O ? "Circle" : "Line" : d ? "Rect" : "Line";
                d ? f[o] = null : f.fill = null;
                var m = l[c][i] = new g[p]({ style: f, z: a, zlevel: s, silent: !0, shape: n });
                return this.group.add(m), m },
            _dispatchAndShowSeriesTooltipContent: function(t, e, i, n, r) {
                var a = this._tooltipModel,
                    o = this._tooltipContent,
                    s = t[R](),
                    l = y.map(e, function(t) {
                        return { seriesIndex: t[ce], dataIndex: t.getAxisTooltipDataIndex ? t.getAxisTooltipDataIndex(t.coordDimToDataDim(s.dim), n, s) : t[Ze]().indexOfNearest(t.coordDimToDataDim(s.dim)[0], n["x" === s.dim || s.dim === O ? 0 : 1]) } }),
                    u = this._lastHover,
                    h = this._api;
                if (u.payloadBatch && !r && h[_e]({ type: "downplay", batch: u.payloadBatch }), r || (h[_e]({ type: "highlight", batch: l }), u.payloadBatch = l), h[_e]({ type: "showTip", dataIndex: l[0][ue], seriesIndex: l[0][ce], from: this.uid }), s && a.get("showContent")) {
                    var d, f = a.get("formatter"),
                        m = a.get(W),
                        v = y.map(e, function(t, e) {
                            return t[le](l[e][ue]) });
                    o.show(a);
                    var g = l[0][ue];
                    if (!r) {
                        if (this._ticket = "", f) {
                            if (typeof f === Be) d = x.formatTpl(f, v);
                            else if (typeof f === ie) {
                                var _ = this,
                                    b = "axis_" + t.name + "_" + g,
                                    w = function(t, e) { t === _._ticket && (o.setContent(e), c(m, i[0], i[1], o, v, null, h)) };
                                _._ticket = b, d = f(v, b, w) } } else {
                            var M = e[0][Ze]()[p](g);
                            d = (M ? M + "<br />" : "") + y.map(e, function(t, e) {
                                return t.formatTooltip(l[e][ue], !0) }).join("<br />") }
                        o.setContent(d) }
                    c(m, i[0], i[1], o, v, null, h) } },
            _showItemTooltipContent: function(t, e, i) {
                var n = this._api,
                    r = t[Ze](),
                    a = r[T](e),
                    o = this._tooltipModel,
                    s = this._tooltipContent,
                    l = a[Oe]("tooltip");
                if (l.parentModel ? l.parentModel.parentModel = o : l.parentModel = this._tooltipModel, l.get("showContent")) {
                    var u, h = l.get("formatter"),
                        d = l.get(W),
                        f = t[le](e);
                    if (h) {
                        if (typeof h === Be) u = x.formatTpl(h, f);
                        else if (typeof h === ie) {
                            var p = this,
                                m = "item_" + t.name + "_" + e,
                                v = function(t, e) { t === p._ticket && (s.setContent(e), c(d, i.offsetX, i.offsetY, s, f, i[he], n)) };
                            p._ticket = m, u = h(f, m, v) } } else u = t.formatTooltip(e);
                    s.show(l), s.setContent(u), c(d, i.offsetX, i.offsetY, s, f, i[he], n) } },
            _showAxisPointer: function(t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && y.each(e, function(t) { t.show() }) } else this.group.eachChild(function(t) { t.show() }), this.group.show() },
            _resetLastHover: function() {
                var t = this._lastHover;
                t.payloadBatch && this._api[_e]({ type: "downplay", batch: t.payloadBatch }), this._lastHover = {} },
            _hideAxisPointer: function(t) {
                if (t) {
                    var e = this._axisPointers[t];
                    e && y.each(e, function(t) { t.hide() }) } else this.group.hide() },
            _hide: function() { clearTimeout(this._showTimeout), this._hideAxisPointer(), this._resetLastHover(), this._alwaysShowContent || this._tooltipContent.hideLater(this._tooltipModel.get("hideDelay")), this._api[_e]({ type: "hideTip", from: this.uid }), this._lastX = this._lastY = null },
            dispose: function(t, e) {
                if (!A.node) {
                    var i = e.getZr();
                    this._tooltipContent.hide(), i.off("click", this._tryShow), i.off("mousemove", this._mousemove), i.off(de, this._hide), i.off("globalout", this._hide), e.off("showTip", this._manuallyShowTip), e.off("hideTip", this._manuallyHideTip) } }
        })
    }), e("echarts/component/marker/MarkLineView", [We, He, "../../data/List", "../../util/format", "../../util/model", h, "./markerHelper", "../../chart/helper/LineDraw", b], function(t) {
        function e(t, e) {
            return f.dataFilter(t, e[0]) && f.dataFilter(t, e[1]) }

        function i(t, e, i, n, r, a, o) {
            var s, c = a[K],
                u = t[T](e),
                h = u.get("x"),
                d = u.get("y");
            if (null != h && null != d) s = [l[v](h, o[Ie]()), l[v](d, o[De]())];
            else {
                if (a.getMarkerPosition) s = a.getMarkerPosition(t.getValues(t[S], e));
                else {
                    var f = c[S],
                        p = t.get(f[0], e),
                        m = t.get(f[1], e);
                    s = c.dataToPoint([p, m]) }
                if (n && "cartesian2d" === c.type) {
                    var g = null != r ? c[I](1 === r ? "x" : "y") : c.getAxesByScale(A)[0];
                    g && g.onBand && (s["x" === g.dim ? 0 : 1] = g.toGlobalCoord(g[F]()[i ? 0 : 1])) } }
            t.setItemLayout(e, s) }

        function n(t, i, n) {
            var o;
            o = t ? r.map(t && t[S], function(t) {
                var e = i[Ze]().getDimensionInfo(i.coordDimToDataDim(t)[0]) || {};
                return e.name = t, e }) : [{ name: "value", type: "float" }];
            var s = new a(o, n),
                l = new a(o, n),
                c = new a([], n),
                u = r.map(n.get("data"), r.curry(y, i, t, n));
            t && (u = r[Ge](u, r.curry(e, t)));
            var h = t ? f.dimValueGetter : function(t) {
                return t.value };
            return s.initData(r.map(u, function(t) {
                return t[0] }), null, h), l.initData(r.map(u, function(t) {
                return t[1] }), null, h), c.initData(r.map(u, function(t) {
                return t[2] })), { from: s, to: l, line: c } }
        var r = t(He),
            a = t("../../data/List"),
            o = t("../../util/format"),
            s = t("../../util/model"),
            l = t(h),
            c = o.addCommas,
            d = o.encodeHTML,
            f = t("./markerHelper"),
            g = t("../../chart/helper/LineDraw"),
            y = function(t, e, i, n) {
                var a = t[Ze](),
                    o = n.type;
                if (!r[re](n) && ("min" === o || "max" === o || "average" === o)) {
                    var s = f.getAxisInfo(n, a, e, t),
                        l = s.baseAxis.dim + "Axis",
                        c = s.valueAxis.dim + "Axis",
                        u = s.baseAxis.scale[F](),
                        h = r.clone(n),
                        d = {};
                    h.type = null, h[l] = u[0], d[l] = u[1];
                    var p = f.numCalculate(a, s.valueDataDim, o);
                    p = s.valueAxis.coordToData(s.valueAxis.dataToCoord(p));
                    var v = i.get("precision");
                    v >= 0 && (p = +p[m](v)), h[c] = d[c] = p, n = [h, d, { type: o, valueIndex: n.valueIndex, value: p }] }
                return n = [f.dataTransform(t, n[0]), f.dataTransform(t, n[1]), r[be]({}, n[2])], n[2].type = n[2].type || "", r.merge(n[2], n[0]), r.merge(n[2], n[1]), n },
            _ = { formatTooltip: function(t) {
                    var e = this._data,
                        i = this.getRawValue(t),
                        n = r[re](i) ? r.map(i, c).join(", ") : c(i),
                        a = e[p](t);
                    return this.name + "<br />" + ((a ? d(a) + " : " : "") + n) }, getRawDataArray: function() {
                    return this[u].data }, getData: function() {
                    return this._data }, setData: function(t) { this._data = t } };
        r[xe](_, s.dataFormatMixin), t(b).extendComponentView({ type: "markLine", init: function() { this._markLineMap = {} }, render: function(t, e, i) {
                var n = this._markLineMap;
                for (var r in n) n[r].__keep = !1;
                e[ve](function(t) {
                    var n = t.markLineModel;
                    n && this._renderSeriesML(t, n, e, i) }, this);
                for (var r in n) n[r].__keep || this.group[we](n[r].group) }, updateLayout: function(t, e, n) { e[ve](function(t) {
                    var e = t.markLineModel;
                    if (e) {
                        var r = e[Ze](),
                            a = e.__from,
                            o = e.__to;
                        a.each(function(e) {
                            var s = r[T](e),
                                l = s.get("type"),
                                c = s.get("valueIndex");
                            i(a, e, !0, l, c, t, n), i(o, e, !1, l, c, t, n) }), r.each(function(t) { r.setItemLayout(t, [a[D](t), o[D](t)]) }), this._markLineMap[t.name][Se]() } }, this) }, _renderSeriesML: function(t, e, a, o) {
                function s(e, n, r, a, s) {
                    var l = e[T](n);
                    i(e, n, r, a, s, t, o), e.setItemVisual(n, { symbolSize: l.get("symbolSize") || b[r ? 0 : 1], symbol: l.get("symbol", !0) || y[r ? 0 : 1], color: l.get("itemStyle.normal.color") || u.getVisual("color") }) }
                var l = t[K],
                    c = t.name,
                    u = t[Ze](),
                    h = this._markLineMap,
                    d = h[c];
                d || (d = h[c] = new g), this.group.add(d.group);
                var f = n(l, t, e),
                    p = f.from,
                    m = f.to,
                    v = f.line;
                e.__from = p, e.__to = m, r[be](e, _), e.setData(v);
                var y = e.get("symbol"),
                    b = e.get("symbolSize");
                r[re](y) || (y = [y, y]), typeof b === ee && (b = [b, b]), f.from.each(function(t) {
                    var e = v[T](t),
                        i = e.get("type"),
                        n = e.get("valueIndex");
                    s(p, t, !0, i, n), s(m, t, !1, i, n) }), v.each(function(t) {
                    var e = v[T](t).get("lineStyle.normal.color");
                    v.setItemVisual(t, { color: e || p[x](t, "color") }), v.setItemLayout(t, [p[D](t), m[D](t)]) }), d[L](v, p, m), f.line[z](function(t) { t[oe](function(t) { t.dataModel = e }) }), d.__keep = !0 } }) }), e("zrender/vml/graphic", [We, "../core/env", "../core/vector", "../core/BoundingRect", "../core/PathProxy", "../tool/color", "../contain/text", "../graphic/mixin/RectText", "../graphic/Displayable", "../graphic/Image", "../graphic/Text", "../graphic/Path", "../graphic/Gradient", "./core"], function(t) {
        if (!t("../core/env")[Pe]) {
            var e = t("../core/vector"),
                n = t("../core/BoundingRect"),
                r = t("../core/PathProxy").CMD,
                a = t("../tool/color"),
                c = t("../contain/text"),
                u = t("../graphic/mixin/RectText"),
                h = t("../graphic/Displayable"),
                d = t("../graphic/Image"),
                f = t("../graphic/Text"),
                p = t("../graphic/Path"),
                v = t("../graphic/Gradient"),
                g = t("./core"),
                y = Math.round,
                x = Math.sqrt,
                b = Math.abs,
                w = Math.cos,
                M = Math.sin,
                S = Math.max,
                T = e[l],
                C = ",",
                A = "progid:DXImageTransform.Microsoft",
                k = 21600,
                L = k / 2,
                z = 1e5,
                P = 1e3,
                D = function(t) { t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;", t.coordsize = k + "," + k, t.coordorigin = "0,0" },
                I = function(t) {
                    return String(t)[ae](/&/g, "&amp;")[ae](/"/g, "&quot;") },
                O = function(t, e, i) {
                    return "rgb(" + [t, e, i].join(",") + ")" },
                R = function(t, e) { e && t && e.parentNode !== t && t.appendChild(e) },
                B = function(t, e) { e && t && e.parentNode === t && t.removeChild(e) },
                E = function(t, e, i) {
                    return (parseFloat(t) || 0) * z + (parseFloat(e) || 0) * P + i },
                V = function(t, e) {
                    return typeof t === Be ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t },
                F = function(t, e, i) {
                    var n = a.parse(e);
                    i = +i, isNaN(i) && (i = 1), n && (t.color = O(n[0], n[1], n[2]), t[Z] = i * n[3]) },
                G = function(t) {
                    var e = a.parse(t);
                    return [O(e[0], e[1], e[2]), e[3]] },
                H = function(t, e, i) {
                    var n = e.fill;
                    if (null != n)
                        if (n instanceof v) {
                            var r, a = 0,
                                o = [0, 0],
                                s = 0,
                                l = 1,
                                c = i[U](),
                                u = c.width,
                                h = c[Ae];
                            if ("linear" === n.type) { r = "gradient";
                                var d = i[Ne],
                                    f = [n.x * u, n.y * h],
                                    p = [n.x2 * u, n.y2 * h];
                                d && (T(f, f, d), T(p, p, d));
                                var m = p[0] - f[0],
                                    g = p[1] - f[1];
                                a = 180 * Math.atan2(m, g) / Math.PI, 0 > a && (a += 360), 1e-6 > a && (a = 0) } else { r = "gradientradial";
                                var f = [n.x * u, n.y * h],
                                    d = i[Ne],
                                    y = i.scale,
                                    x = u,
                                    _ = h;
                                o = [(f[0] - c.x) / x, (f[1] - c.y) / _], d && T(f, f, d), x /= y[0] * k, _ /= y[1] * k;
                                var b = S(x, _);
                                s = 0 / b, l = 2 * n.r / b - s }
                            var w = n.colorStops.slice();
                            w.sort(function(t, e) {
                                return t.offset - e.offset });
                            for (var M = w[ye], C = [], A = [], L = 0; M > L; L++) {
                                var z = w[L],
                                    P = G(z.color);
                                A.push(z.offset * l + s + " " + P[0]), (0 === L || L === M - 1) && C.push(P) }
                            if (M >= 2) {
                                var D = C[0][0],
                                    I = C[1][0],
                                    O = C[0][1] * e[Z],
                                    R = C[1][1] * e[Z];
                                t.type = r, t.method = "none", t.focus = "100%", t.angle = a, t.color = D, t.color2 = I, t.colors = A.join(","), t[Z] = R, t.opacity2 = O } "radial" === r && (t.focusposition = o.join(",")) } else F(t, n, e[Z]) },
                W = function(t, e) { null != e.lineJoin && (t.joinstyle = e.lineJoin), null != e.miterLimit && (t.miterlimit = e.miterLimit * k), null != e.lineCap && (t.endcap = e.lineCap), null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")), null == e[o] || e[o] instanceof v || F(t, e[o], e[Z]) },
                X = function(t, e, i, n) {
                    var r = "fill" == e,
                        a = t.getElementsByTagName(e)[0];
                    null != i[e] && "none" !== i[e] && (r || !r && i[s]) ? (t[r ? "filled" : "stroked"] = "true", i[e] instanceof v && B(t, a), a || (a = g.createNode(e)), r ? H(a, i, n) : W(a, i), R(t, a)) : (t[r ? "filled" : "stroked"] = "false", B(t, a)) },
                Y = [
                    [],
                    [],
                    []
                ],
                Q = function(t, e) {
                    var i, n, a, o, s, l, c = r.M,
                        u = r.C,
                        h = r.L,
                        d = r.A,
                        f = r.Q,
                        p = [];
                    for (o = 0; o < t[ye];) {
                        switch (a = t[o++], n = "", i = 0, a) {
                            case c:
                                n = " m ", i = 1, s = t[o++], l = t[o++], Y[0][0] = s, Y[0][1] = l;
                                break;
                            case h:
                                n = " l ", i = 1, s = t[o++], l = t[o++], Y[0][0] = s, Y[0][1] = l;
                                break;
                            case f:
                            case u:
                                n = " c ", i = 3;
                                var m, v, g = t[o++],
                                    _ = t[o++],
                                    b = t[o++],
                                    S = t[o++];
                                a === f ? (m = b, v = S, b = (b + 2 * g) / 3, S = (S + 2 * _) / 3, g = (s + 2 * g) / 3, _ = (l + 2 * _) / 3) : (m = t[o++], v = t[o++]), Y[0][0] = g, Y[0][1] = _, Y[1][0] = b, Y[1][1] = S, Y[2][0] = m, Y[2][1] = v, s = m, l = v;
                                break;
                            case d:
                                var A = 0,
                                    z = 0,
                                    P = 1,
                                    D = 1,
                                    I = 0;
                                e && (A = e[4], z = e[5], P = x(e[0] * e[0] + e[1] * e[1]), D = x(e[2] * e[2] + e[3] * e[3]), I = Math.atan2(-e[1] / D, e[0] / P));
                                var O = t[o++],
                                    R = t[o++],
                                    B = t[o++],
                                    E = t[o++],
                                    V = t[o++] + I,
                                    N = t[o++] + V + I;
                                o++;
                                var F = t[o++],
                                    G = O + w(V) * B,
                                    Z = R + M(V) * E,
                                    g = O + w(N) * B,
                                    _ = R + M(N) * E,
                                    H = F ? " wa " : " at ";
                                Math.abs(G - g) < 1e-10 && F && (G += 270 / k), p.push(H, y(((O - B) * P + A) * k - L), C, y(((R - E) * D + z) * k - L), C, y(((O + B) * P + A) * k - L), C, y(((R + E) * D + z) * k - L), C, y((G * P + A) * k - L), C, y((Z * D + z) * k - L), C, y((g * P + A) * k - L), C, y((_ * D + z) * k - L)), s = g, l = _;
                                break;
                            case r.R:
                                var W = Y[0],
                                    q = Y[1];
                                W[0] = t[o++], W[1] = t[o++], q[0] = W[0] + t[o++], q[1] = W[1] + t[o++], e && (T(W, W, e), T(q, q, e)), W[0] = y(W[0] * k - L), q[0] = y(q[0] * k - L), W[1] = y(W[1] * k - L), q[1] = y(q[1] * k - L), p.push(" m ", W[0], C, W[1], " l ", q[0], C, W[1], " l ", q[0], C, q[1], " l ", W[0], C, q[1]);
                                break;
                            case r.Z:
                                p.push(" x ") }
                        if (i > 0) { p.push(n);
                            for (var j = 0; i > j; j++) {
                                var U = Y[j];
                                e && T(U, U, e), p.push(y(U[0] * k - L), C, y(U[1] * k - L), i - 1 > j ? C : "") } } }
                    return p.join("") };
            p[Ee].brushVML = function(t) {
                var e = this.style,
                    n = this._vmlEl;
                n || (n = g.createNode("shape"), D(n), this._vmlEl = n), X(n, "fill", e, this), X(n, o, e, this);
                var r = this[Ne],
                    a = null != r,
                    l = n.getElementsByTagName(o)[0];
                if (l) {
                    var c = e[s];
                    if (a && !e.strokeNoScale) {
                        var u = r[0] * r[3] - r[1] * r[2];
                        c *= x(b(u)) }
                    l.weight = c + "px" }
                var h = this.path;
                this.__dirtyPath && (h.beginPath(), this[i](h, this.shape), h.toStatic(), this.__dirtyPath = !1), n.path = Q(h.data, this[Ne]), n.style.zIndex = E(this[se], this.z, this.z2), R(t, n), e.text && this.drawRectText(t, this[U]()) }, p[Ee].onRemove = function(t) { B(t, this._vmlEl), this.removeRectText(t) }, p[Ee].onAdd = function(t) { R(t, this._vmlEl), this.appendRectText(t) };
            var K = function(t) {
                return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase() };
            d[Ee].brushVML = function(t) {
                var e, i, n = this.style,
                    r = n.image;
                if (K(r)) {
                    var a = r.src;
                    if (a === this._imageSrc) e = this._imageWidth, i = this._imageHeight;
                    else {
                        var o = r.runtimeStyle,
                            s = o.width,
                            l = o[Ae];
                        o.width = "auto", o[Ae] = "auto", e = r.width, i = r[Ae], o.width = s, o[Ae] = l, this._imageSrc = a, this._imageWidth = e, this._imageHeight = i }
                    r = a } else r === this._imageSrc && (e = this._imageWidth, i = this._imageHeight);
                if (r) {
                    var c = n.x || 0,
                        u = n.y || 0,
                        h = n.width,
                        d = n[Ae],
                        f = n.sWidth,
                        p = n.sHeight,
                        m = n.sx || 0,
                        v = n.sy || 0,
                        _ = f && p,
                        b = this._vmlEl;
                    b || (b = g.doc[N]("div"), D(b), this._vmlEl = b);
                    var w, M = b.style,
                        k = !1,
                        L = 1,
                        z = 1;
                    if (this[Ne] && (w = this[Ne], L = x(w[0] * w[0] + w[1] * w[1]), z = x(w[2] * w[2] + w[3] * w[3]), k = w[1] || w[2]), k) {
                        var P = [c, u],
                            I = [c + h, u],
                            O = [c, u + d],
                            B = [c + h, u + d];
                        T(P, P, w), T(I, I, w), T(O, O, w), T(B, B, w);
                        var V = S(P[0], I[0], O[0], B[0]),
                            F = S(P[1], I[1], O[1], B[1]),
                            G = [];
                        G.push("M11=", w[0] / L, C, "M12=", w[2] / z, C, "M21=", w[1] / L, C, "M22=", w[3] / z, C, "Dx=", y(c * L + w[4]), C, "Dy=", y(u * z + w[5])), M.padding = "0 " + y(V) + "px " + y(F) + "px 0", M[Ge] = A + ".Matrix(" + G.join("") + ", SizingMethod=clip)" } else w && (c = c * L + w[4], u = u * z + w[5]), M[Ge] = "", M.left = y(c) + "px", M.top = y(u) + "px";
                    var H = this._imageEl,
                        W = this._cropEl;
                    H || (H = g.doc[N]("div"), this._imageEl = H);
                    var q = H.style;
                    if (_) {
                        if (e && i) q.width = y(L * e * h / f) + "px", q[Ae] = y(z * i * d / p) + "px";
                        else {
                            var j = new Image,
                                X = this;
                            j.onload = function() { j.onload = null, e = j.width, i = j[Ae], q.width = y(L * e * h / f) + "px", q[Ae] = y(z * i * d / p) + "px", X._imageWidth = e, X._imageHeight = i, X._imageSrc = r }, j.src = r }
                        W || (W = g.doc[N]("div"), W.style.overflow = "hidden", this._cropEl = W);
                        var Y = W.style;
                        Y.width = y((h + m * h / f) * L), Y[Ae] = y((d + v * d / p) * z), Y[Ge] = A + ".Matrix(Dx=" + -m * h / f * L + ",Dy=" + -v * d / p * z + ")", W.parentNode || b.appendChild(W), H.parentNode != W && W.appendChild(H) } else q.width = y(L * h) + "px", q[Ae] = y(z * d) + "px", b.appendChild(H), W && W.parentNode && (b.removeChild(W), this._cropEl = null);
                    var $ = "",
                        Q = n[Z];
                    1 > Q && ($ += ".Alpha(opacity=" + y(100 * Q) + ") "), $ += A + ".AlphaImageLoader(src=" + r + ", SizingMethod=scale)", q[Ge] = $, b.style.zIndex = E(this[se], this.z, this.z2), R(t, b), n.text && this.drawRectText(t, this[U]()) } }, d[Ee].onRemove = function(t) { B(t, this._vmlEl), this._vmlEl = null, this._cropEl = null, this._imageEl = null, this.removeRectText(t) }, d[Ee].onAdd = function(t) { R(t, this._vmlEl), this.appendRectText(t) };
            var J, te = _,
                ee = {},
                ie = 0,
                ne = 100,
                re = document[N]("div"),
                oe = function(t) {
                    var e = ee[t];
                    if (!e) { ie > ne && (ie = 0, ee = {});
                        var i, n = re.style;
                        try { n.font = t, i = n.fontFamily.split(",")[0] } catch (r) {}
                        e = { style: n.fontStyle || te, variant: n.fontVariant || te, weight: n.fontWeight || te, size: 0 | parseFloat(n.fontSize || 12), family: i || "Microsoft YaHei" }, ee[t] = e, ie++ }
                    return e };
            c.measureText = function(t, e) {
                var i = g.doc;
                J || (J = i[N]("div"), J.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;", g.doc.body.appendChild(J));
                try { J.style.font = e } catch (n) {}
                return J.innerHTML = "", J.appendChild(i.createTextNode(t)), { width: J.offsetWidth } };
            for (var le = new n, ce = function(t, e, i, n) {
                    var r = this.style,
                        a = r.text;
                    if (a) {
                        var s, u, h = r[$],
                            d = oe(r.textFont),
                            f = d.style + " " + d.variant + " " + d.weight + " " + d.size + 'px "' + d.family + '"',
                            p = r.textBaseline,
                            v = r.textVerticalAlign;
                        i = i || c[U](a, f, h, p);
                        var x = this[Ne];
                        if (x && !n && (le.copy(e), le[l](x), e = le), n) s = e.x, u = e.y;
                        else {
                            var _ = r.textPosition,
                                b = r.textDistance;
                            if (_ instanceof Array) s = e.x + V(_[0], e.width), u = e.y + V(_[1], e[Ae]), h = h || "left", p = p || "top";
                            else {
                                var w = c.adjustTextPositionOnRect(_, e, i, b);
                                s = w.x, u = w.y, h = h || w[$], p = p || w.textBaseline } }
                        if (v) {
                            switch (v) {
                                case j:
                                    u -= i[Ae] / 2;
                                    break;
                                case ke:
                                    u -= i[Ae] }
                            p = "top" }
                        var M = d.size;
                        switch (p) {
                            case "hanging":
                            case "top":
                                u += M / 1.75;
                                break;
                            case j:
                                break;
                            default:
                                u -= M / 2.25 }
                        switch (h) {
                            case "left":
                                break;
                            case q:
                                s -= i.width / 2;
                                break;
                            case "right":
                                s -= i.width }
                        var S, A, k, L = g.createNode,
                            z = this._textVmlEl;
                        z ? (k = z.firstChild, S = k.nextSibling, A = S.nextSibling) : (z = L("line"), S = L("path"), A = L("textpath"), k = L("skew"), A.style["v-text-align"] = "left", D(z), S.textpathok = !0, A.on = !0, z.from = "0 0", z.to = "1000 0.05", R(z, k), R(z, S), R(z, A), this._textVmlEl = z);
                        var P = [s, u],
                            O = z.style;
                        x && n ? (T(P, P, x), k.on = !0, k.matrix = x[0][m](3) + C + x[2][m](3) + C + x[1][m](3) + C + x[3][m](3) + ",0,0", k.offset = (y(P[0]) || 0) + "," + (y(P[1]) || 0), k.origin = "0 0", O.left = "0px", O.top = "0px") : (k.on = !1, O.left = y(s) + "px", O.top = y(u) + "px"), A[Be] = I(a);
                        try { A.style.font = f } catch (B) {}
                        X(z, "fill", { fill: n ? r.fill : r.textFill, opacity: r[Z] }, this), X(z, o, { stroke: n ? r[o] : r.textStroke, opacity: r[Z], lineDash: r.lineDash }, this), z.style.zIndex = E(this[se], this.z, this.z2), R(t, z) } }, ue = function(t) { B(t, this._textVmlEl), this._textVmlEl = null }, he = function(t) { R(t, this._textVmlEl) }, de = [u, h, d, p, f], fe = 0; fe < de[ye]; fe++) {
                var pe = de[fe][Ee];
                pe.drawRectText = ce, pe.removeRectText = ue, pe.appendRectText = he }
            f[Ee].brushVML = function(t) {
                var e = this.style;
                e.text && this.drawRectText(t, { x: e.x || 0, y: e.y || 0, width: 0, height: 0 }, this[U](), !0) }, f[Ee].onRemove = function(t) { this.removeRectText(t) }, f[Ee].onAdd = function(t) { this.appendRectText(t) } } }), e("zrender/vml/Painter", [We, "../core/log", "./core"], function(t) {
        function e(t) {
            return parseInt(t, 10) }

        function i(t, e) { a.initVML(), this.root = t, this.storage = e;
            var i = document[N]("div"),
                n = document[N]("div");
            i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;", n.style.cssText = "position:absolute;left:0;top:0;", t.appendChild(i), this._vmlRoot = n, this._vmlViewport = i, this[Re]();
            var r = e.delFromMap,
                o = e.addToMap;
            e.delFromMap = function(t) {
                var i = e.get(t);
                r.call(e, t), i && i.onRemove && i.onRemove(n) }, e.addToMap = function(t) { t.onAdd && t.onAdd(n), o.call(e, t) }, this._firstPaint = !0 }

        function n(t) {
            return function() { r('In IE8.0 VML mode painter not support method "' + t + '"') } }
        var r = t("../core/log"),
            a = t("./core");
        i[Ee] = { constructor: i, getViewportRoot: function() {
                return this._vmlViewport }, refresh: function() {
                var t = this.storage.getDisplayList(!0, !0);
                this._paintList(t) }, _paintList: function(t) {
                for (var e = this._vmlRoot, i = 0; i < t[ye]; i++) {
                    var n = t[i];
                    n.invisible || n[Le] ? (n.__alreadyNotVisible || n.onRemove(e), n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e), n.__alreadyNotVisible = !1, n.__dirty && (n.beforeBrush && n.beforeBrush(), (n.brushVML || n.brush).call(n, e), n.afterBrush && n.afterBrush())), n.__dirty = !1 }
                this._firstPaint && (this._vmlViewport.appendChild(e), this._firstPaint = !1) }, resize: function() {
                var t = this._getWidth(),
                    e = this._getHeight();
                if (this._width != t && this._height != e) { this._width = t, this._height = e;
                    var i = this._vmlViewport.style;
                    i.width = t + "px", i[Ae] = e + "px" } }, dispose: function() { this.root.innerHTML = "", this._vmlRoot = this._vmlViewport = this.storage = null }, getWidth: function() {
                return this._width }, getHeight: function() {
                return this._height }, _getWidth: function() {
                var t = this.root,
                    i = t.currentStyle;
                return (t.clientWidth || e(i.width)) - e(i.paddingLeft) - e(i.paddingRight) | 0 }, _getHeight: function() {
                var t = this.root,
                    i = t.currentStyle;
                return (t.clientHeight || e(i[Ae])) - e(i.paddingTop) - e(i.paddingBottom) | 0 } };
        for (var o = ["getLayer", "insertLayer", "eachLayer", "eachBuildinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], s = 0; s < o[ye]; s++) {
            var l = o[s];
            i[Ee][l] = n(l) }
        return i }), e("echarts/component/toolbox/ToolboxModel", [We, "./featureManager", He, b], function(t) {
        var e = t("./featureManager"),
            i = t(He),
            n = t(b).extendComponentModel({ type: "toolbox", layoutMode: { type: "box", ignoreSize: !0 }, mergeDefaultAndTheme: function() { n.superApply(this, "mergeDefaultAndTheme", arguments), i.each(this[u].feature, function(t, n) {
                        var r = e.get(n);
                        r && i.merge(t, r.defaultOption) }) }, defaultOption: { show: !0, z: 6, zlevel: 0, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { normal: { borderColor: "#666", color: "none" }, emphasis: { borderColor: "#3E98C5" } } } });
        return n }), e("echarts/component/toolbox/ToolboxView", [We, "./featureManager", He, B, "../../model/Model", "../../data/DataDiffer", "../helper/listComponent", "zrender/contain/text", b], function(t) {
        function e(t) {
            return 0 === t[ne]("my") }
        var i = t("./featureManager"),
            n = t(He),
            r = t(B),
            a = t("../../model/Model"),
            s = t("../../data/DataDiffer"),
            l = t("../helper/listComponent"),
            h = t("zrender/contain/text");
        return t(b).extendComponentView({ type: "toolbox", render: function(t, d, f) {
                function p(n, r) {
                    var o, s = M[n],
                        l = M[r],
                        h = b[s],
                        p = new a(h, t, t[c]);
                    if (s && !l) {
                        if (e(s)) o = { model: p, onclick: p[u].onclick, featureName: s };
                        else {
                            var v = i.get(s);
                            if (!v) return;
                            o = new v(p) }
                        w[s] = o } else {
                        if (o = w[l], !o) return;
                        o.model = p }
                    return !s && l ? void(o.dispose && o.dispose(d, f)) : !p.get("show") || o.unusable ? void(o[we] && o[we](d, f)) : (m(p, o, s), p.setIconStatus = function(t, e) {
                        var i = this[u],
                            n = this.iconPaths;
                        i.iconStatus = i.iconStatus || {}, i.iconStatus[t] = e, n[t] && n[t][ge](e) }, void(o.render && o.render(p, d, f))) }

                function m(e, i, a) {
                    var s = e[Oe]("iconStyle"),
                        l = i.getIcons ? i.getIcons() : e.get("icon"),
                        c = e.get("title") || {};
                    if (typeof l === Be) {
                        var u = l,
                            h = c;
                        l = {}, c = {}, l[a] = u, c[a] = h }
                    var p = e.iconPaths = {};
                    n.each(l, function(a, l) {
                        var u = s[Oe](_).getItemStyle(),
                            h = s[Oe](y).getItemStyle(),
                            m = { x: -x / 2, y: -x / 2, width: x, height: x },
                            b = 0 === a[ne]("image://") ? (m.image = a.slice(8), new r.Image({ style: m })) : r.makePath(a[ae]("path://", ""), { style: u, hoverStyle: h, rectHover: !0 }, m, q);
                        r[g](b), t.get("showTitle") && (b.__title = c[l], b.on(fe, function() { b[H]({ text: c[l], textPosition: h.textPosition || ke, textFill: h.fill || h[o] || "#000", textAlign: h[$] || q }) }).on(de, function() { b[H]({ textFill: null }) })), b[ge](e.get("iconStatus." + l) || _), v.add(b), b.on("click", n.bind(i.onclick, i, d, f, l)), p[l] = b }) }
                var v = this.group;
                if (v[J](), t.get("show")) {
                    var x = +t.get("itemSize"),
                        b = t.get("feature") || {},
                        w = this._features || (this._features = {}),
                        M = [];
                    n.each(b, function(t, e) { M.push(e) }), new s(this._featureNames || [], M).add(p)[Te](p)[we](n.curry(p, null)).execute(), this._featureNames = M, l.layout(v, t, f), l.addBackground(v, t), v.eachChild(function(t) {
                        var e = t.__title,
                            i = t.hoverStyle;
                        if (i && e) {
                            var n = h[U](e, i.font),
                                r = t[W][0] + v[W][0],
                                a = t[W][1] + v[W][1] + x,
                                o = !1;
                            a + n[Ae] > f[De]() && (i.textPosition = "top", o = !0);
                            var s = o ? -5 - n[Ae] : x + 8;
                            r + n.width / 2 > f[Ie]() ? (i.textPosition = ["100%", s], i[$] = "right") : r - n.width / 2 < 0 && (i.textPosition = [0, s], i[$] = "left") } }) } }, remove: function(t, e) { n.each(this._features, function(i) { i[we] && i[we](t, e) }), this.group[J]() }, dispose: function(t, e) { n.each(this._features, function(i) { i.dispose && i.dispose(t, e) }) } }) }), e("echarts/component/toolbox/feature/SaveAsImage", [We, "zrender/core/env", "../featureManager"], function(t) {
        function e(t) { this.model = t }
        var i = t("zrender/core/env");
        e.defaultOption = { show: !0, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: "保存为图片", type: "png", name: "", excludeComponents: ["toolbox"], pixelRatio: 1, lang: ["右键另存为图片"] }, e[Ee].unusable = !i[Pe];
        var n = e[Ee];
        return n.onclick = function(t, e) {
            var i = this.model,
                n = i.get("name") || t.get("title.0.text") || "echarts",
                r = document[N]("a"),
                a = i.get("type", !0) || "png";
            r.download = n + "." + a, r[he] = "_blank";
            var o = e.getConnectedDataURL({ type: a, backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff", excludeComponents: i.get("excludeComponents"), pixelRatio: i.get("pixelRatio") });
            if (r.href = o, typeof MouseEvent === ie) {
                var s = new MouseEvent("click", { view: window, bubbles: !0, cancelable: !1 });
                r.dispatchEvent(s) } else {
                var l = i.get("lang"),
                    c = '<body style="margin:0;"><img src="' + o + '" style="max-width:100%;" title="' + (l && l[0] || "") + '" /></body>',
                    u = window.open();
                u.document.write(c) } }, t("../featureManager").register("saveAsImage", e), e }), e("echarts/component/toolbox/feature/MagicType", [We, He, "../../../echarts", "../featureManager"], function(t) {
        function e(t) { this.model = t }
        var i = t(He);
        e.defaultOption = { show: !0, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z", tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z" }, title: { line: "切换为折线图", bar: "切换为柱状图", stack: "切换为堆叠", tiled: "切换为平铺" }, option: {}, seriesIndex: {} };
        var n = e[Ee];
        n.getIcons = function() {
            var t = this.model,
                e = t.get("icon"),
                n = {};
            return i.each(t.get("type"), function(t) { e[t] && (n[t] = e[t]) }), n };
        var r = { line: function(t, e, n, r) {
                    return "bar" === t ? i.merge({ id: e, type: "line", data: n.get("data"), stack: n.get("stack"), markPoint: n.get("markPoint"), markLine: n.get("markLine") }, r.get("option.line") || {}, !0) : void 0 }, bar: function(t, e, n, r) {
                    return "line" === t ? i.merge({ id: e, type: "bar", data: n.get("data"), stack: n.get("stack"), markPoint: n.get("markPoint"), markLine: n.get("markLine") }, r.get("option.bar") || {}, !0) : void 0 }, stack: function(t, e, n, r) {
                    return "line" === t || "bar" === t ? i.merge({ id: e, stack: "__ec_magicType_stack__" }, r.get("option.stack") || {}, !0) : void 0 }, tiled: function(t, e, n, r) {
                    return "line" === t || "bar" === t ? i.merge({ id: e, stack: "" }, r.get("option.tiled") || {}, !0) : void 0 } },
            a = [
                ["line", "bar"],
                ["stack", "tiled"]
            ];
        n.onclick = function(t, e, n) {
            var o = this.model,
                s = o.get("seriesIndex." + n);
            if (r[n]) {
                var l = { series: [] },
                    c = function(t) {
                        var e = t.subType,
                            a = t.id,
                            s = r[n](e, a, t, o);
                        s && (i[xe](s, t[u]), l[me].push(s));
                        var c = t[K];
                        if (c && "cartesian2d" === c.type && ("line" === n || "bar" === n)) {
                            var h = c.getAxesByScale(A)[0];
                            if (h) {
                                var d = h.dim,
                                    f = t.get(d + "AxisIndex"),
                                    p = d + "Axis";
                                l[p] = l[p] || [];
                                for (var m = 0; f >= m; m++) l[p][f] = l[p][f] || {};
                                l[p][f].boundaryGap = "bar" === n ? !0 : !1 } } };
                i.each(a, function(t) { i[ne](t, n) >= 0 && i.each(t, function(t) { o.setIconStatus(t, _) }) }), o.setIconStatus(n, y), t[ze]({ mainType: "series", query: null == s ? null : { seriesIndex: s } }, c), e[_e]({ type: "changeMagicType", currentType: n, newOption: l }) } };
        var o = t("../../../echarts");
        return o.registerAction({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function(t, e) { e.mergeOption(t.newOption) }), t("../featureManager").register("magicType", e), e }), e("echarts/component/toolbox/feature/DataView", [We, He, "zrender/core/event", "../featureManager", "../../../echarts"], function(t) {
        function e(t) {
            var e = {},
                i = [],
                n = [];
            return t.eachRawSeries(function(t) {
                var r = t[K];
                if (!r || "cartesian2d" !== r.type && "polar" !== r.type) i.push(t);
                else {
                    var a = r[R]();
                    if (a.type === w) {
                        var o = a.dim + "_" + a.index;
                        e[o] || (e[o] = { categoryAxis: a, valueAxis: r.getOtherAxis(a), series: [] }, n.push({ axisDim: a.dim, axisIndex: a.index })), e[o][me].push(t) } else i.push(t) } }), { seriesGroupByCategoryAxis: e, other: i, meta: n } }

        function i(t) {
            var e = [];
            return d.each(t, function(t) {
                var i = t.categoryAxis,
                    n = t.valueAxis,
                    r = n.dim,
                    a = [" "][E](d.map(t[me], function(t) {
                        return t.name })),
                    o = [i.model.getCategories()];
                d.each(t[me], function(t) { o.push(t.getRawData().mapArray(r, function(t) {
                        return t })) });
                for (var s = [a.join(v)], l = 0; l < o[0][ye]; l++) {
                    for (var c = [], u = 0; u < o[ye]; u++) c.push(o[u][l]);
                    s.push(c.join(v)) }
                e.push(s.join("\n")) }), e.join("\n\n" + m + "\n\n") }

        function n(t) {
            return d.map(t, function(t) {
                var e = t.getRawData(),
                    i = [t.name],
                    n = [];
                return e.each(e[S], function() {
                    for (var t = arguments[ye], r = arguments[t - 1], a = e[p](r), o = 0; t - 1 > o; o++) n[o] = arguments[o];
                    i.push((a ? a + v : "") + n.join(v)) }), i.join("\n") }).join("\n\n" + m + "\n\n") }

        function r(t) {
            var r = e(t);
            return { value: d[Ge]([i(r.seriesGroupByCategoryAxis), n(r.other)], function(t) {
                    return t[ae](/[\n\t\s]/g, "") }).join("\n\n" + m + "\n\n"), meta: r.meta } }

        function a(t) {
            return t[ae](/^\s\s*/, "")[ae](/\s\s*$/, "") }

        function o(t) {
            var e = t.slice(0, t[ne]("\n"));
            return e[ne](v) >= 0 ? !0 : void 0 }

        function s(t) {
            for (var e = t.split(/\n+/g), i = a(e.shift()).split(g), n = [], r = d.map(i, function(t) {
                    return { name: t, data: [] } }), o = 0; o < e[ye]; o++) {
                var s = a(e[o]).split(g);
                n.push(s.shift());
                for (var l = 0; l < s[ye]; l++) r[l] && (r[l].data[o] = s[l]) }
            return { series: r, categories: n } }

        function l(t) {
            for (var e = t.split(/\n+/g), i = a(e.shift()), n = [], r = 0; r < e[ye]; r++) {
                var o, s = a(e[r]).split(g),
                    l = "",
                    c = !1;
                isNaN(s[0]) ? (c = !0, l = s[0], s = s.slice(1), n[r] = { name: l, value: [] }, o = n[r].value) : o = n[r] = [];
                for (var u = 0; u < s[ye]; u++) o.push(+s[u]);
                1 === o[ye] && (c ? n[r].value = o[0] : n[r] = o[0])
            }
            return { name: i, data: n }
        }

        function c(t, e) {
            var i = t.split(new RegExp("\n*" + m + "\n*", "g")),
                n = { series: [] };
            return d.each(i, function(t, i) {
                if (o(t)) {
                    var r = s(t),
                        a = e[i],
                        c = a.axisDim + "Axis";
                    a && (n[c] = n[c] || [], n[c][a.axisIndex] = { data: r.categories }, n[me] = n[me][E](r[me])) } else {
                    var r = l(t);
                    n[me].push(r) } }), n }

        function u(t) { this._dom = null, this.model = t }

        function h(t, e) {
            return d.map(t, function(t, i) {
                var n = e && e[i];
                return d[Me](n) && !d[re](n) ? (d[Me](t) && !d[re](t) && (t = t.value), d[xe]({ value: t }, n)) : t }) }
        var d = t(He),
            f = t("zrender/core/event"),
            m = new Array(60).join("-"),
            v = "   ",
            g = new RegExp("[" + v + "]+", "g");
        return u.defaultOption = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: "数据视图", lang: ["数据视图", "关闭", "刷新"], backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" }, u[Ee].onclick = function(t, e) {
            function i() { n.removeChild(o), S._dom = null }
            var n = e.getDom(),
                a = this.model;
            this._dom && n.removeChild(this._dom);
            var o = document[N]("div");
            o.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
            var s = document[N]("h4"),
                l = a.get("lang") || [];
            s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin: 10px 20px;", s.style.color = a.get("textColor");
            var u = document[N]("div"),
                h = document[N]("textarea");
            u.style.cssText = "display:block;width:100%;overflow:hidden;";
            var p = a.get("optionToContent"),
                m = a.get("contentToOption"),
                g = r(t);
            if (typeof p === ie) {
                var y = p(e.getOption());
                typeof y === Be ? u.innerHTML = y : d.isDom(y) && u.appendChild(y) } else u.appendChild(h), h.readOnly = a.get("readOnly"), h.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;", h.style.color = a.get("textColor"), h.style.borderColor = a.get("textareaBorderColor"), h.style.backgroundColor = a.get("textareaColor"), h.value = g.value;
            var x = g.meta,
                _ = document[N]("div");
            _.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
            var b = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px",
                w = document[N]("div"),
                M = document[N]("div");
            b += ";background-color:" + a.get("buttonColor"), b += ";color:" + a.get("buttonTextColor");
            var S = this;
            f.addEventListener(w, "click", i), f.addEventListener(M, "click", function() {
                var t;
                try { t = typeof m === ie ? m(u, e.getOption()) : c(h.value, x) } catch (n) {
                    throw i(), new Error("Data view format error " + n) }
                t && e[_e]({ type: "changeDataView", newOption: t }), i() }), w.innerHTML = l[1], M.innerHTML = l[2], M.style.cssText = b, w.style.cssText = b, !a.get("readOnly") && _.appendChild(M), _.appendChild(w), f.addEventListener(h, "keydown", function(t) {
                if (9 === (t.keyCode || t.which)) {
                    var e = this.value,
                        i = this.selectionStart,
                        n = this.selectionEnd;
                    this.value = e.substring(0, i) + v + e.substring(n), this.selectionStart = this.selectionEnd = i + 1, f.stop(t) } }), o.appendChild(s), o.appendChild(u), o.appendChild(_), u.style[Ae] = n.clientHeight - 80 + "px", n.appendChild(o), this._dom = o }, u[Ee][we] = function(t, e) { this._dom && e.getDom().removeChild(this._dom) }, u[Ee].dispose = function(t, e) { this[we](t, e) }, t("../featureManager").register("dataView", u), t("../../../echarts").registerAction({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function(t, e) {
            var i = [];
            d.each(t.newOption[me], function(t) {
                var n = e.getSeriesByName(t.name)[0];
                if (n) {
                    var r = n.get("data");
                    i.push({ name: t.name, data: h(t.data, r) }) } else i.push(d[be]({ type: "scatter" }, t)) }), e.mergeOption(d[xe]({ series: i }, t.newOption)) }), u
    }), e("echarts/component/toolbox/feature/DataZoom", [We, He, "../../../util/number", "../../helper/SelectController", "zrender/core/BoundingRect", "zrender/container/Group", "../../dataZoom/history", "../../helper/interactionMutex", "../../dataZoomSelect", "../featureManager", "../../../echarts"], function(t) {
        function e(t) { this.model = t, this._controllerGroup, this._controller, this._isZoomActive }

        function i(t, e) {
            var i = [{ axisModel: t[I]("x").model, axisIndex: 0 }, { axisModel: t[I]("y").model, axisIndex: 0 }];
            return i.grid = t, e[ze]({ mainType: "dataZoom", subType: "select" }, function(t) { n("xAxis", i[0].axisModel, t, e) && (i[0].dataZoomModel = t), n("yAxis", i[1].axisModel, t, e) && (i[1].dataZoomModel = t) }), i }

        function n(t, e, i, n) {
            var r = i.get(t + "Index");
            return null != r && n[M](t, r) === e }

        function r(t, e) {
            var i = e.grid,
                n = new u(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]);
            if (n.intersect(i.getRect())) {
                var r = i.getCartesian(e[0].axisIndex, e[1].axisIndex),
                    a = r.pointToData([t[0][0], t[1][0]], !0),
                    o = r.pointToData([t[0][1], t[1][1]], !0);
                return [m([a[0], o[0]]), m([a[1], o[1]])] } }

        function a(t, e, i) {
            var n = e[i],
                r = n.dataZoomModel;
            return r ? { dataZoomId: r.id, startValue: t[i][0], endValue: t[i][1] } : void 0 }

        function o(t, e) { t.setIconStatus("back", d.count(e) > 1 ? y : _) }
        var s = t(He),
            l = t("../../../util/number"),
            c = t("../../helper/SelectController"),
            u = t("zrender/core/BoundingRect"),
            h = t("zrender/container/Group"),
            d = t("../../dataZoom/history"),
            f = t("../../helper/interactionMutex"),
            p = s.each,
            m = l.asc;
        t("../../dataZoomSelect");
        var v = "\x00_ec_\x00toolbox-dataZoom_";
        e.defaultOption = { show: !0, icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: { zoom: "区域缩放", back: "区域缩放还原" } };
        var g = e[Ee];
        g.render = function(t, e) { o(t, e) }, g.onclick = function(t, e, i) {
            var n = this._controllerGroup;
            this._controllerGroup || (n = this._controllerGroup = new h, e.getZr().add(n)), x[i].call(this, n, this.model, t, e) }, g[we] = function(t, e) { this._disposeController(), f.release("globalPan", e.getZr()) }, g.dispose = function(t, e) {
            var i = e.getZr();
            f.release("globalPan", i), this._disposeController(), this._controllerGroup && i[we](this._controllerGroup) };
        var x = { zoom: function(t, e, i, n) {
                var r = this._isZoomActive = !this._isZoomActive,
                    a = n.getZr();
                f[r ? "take" : "release"]("globalPan", a), e.setIconStatus("zoom", r ? y : _), r ? (a.setDefaultCursorStyle("crosshair"), this._createController(t, e, i, n)) : (a.setDefaultCursorStyle("default"), this._disposeController()) }, back: function(t, e, i, n) { this._dispatchAction(d.pop(i), n) } };
        return g._createController = function(t, e, i, n) {
            var r = this._controller = new c("rect", n.getZr(), { lineWidth: 3, stroke: "#333", fill: "rgba(0,0,0,0.2)" });
            r.on("selectEnd", s.bind(this._onSelected, this, r, e, i, n)), r.enable(t, !1) }, g._disposeController = function() {
            var t = this._controller;
            t && (t.off("selected"), t.dispose()) }, g._onSelected = function(t, e, n, o, s) {
            if (s[ye]) {
                var l = s[0];
                t[Te]();
                var c = {};
                n[ze]("grid", function(t) {
                    var e = t[K],
                        o = i(e, n),
                        s = r(l, o);
                    if (s) {
                        var u = a(s, o, 0, "x"),
                            h = a(s, o, 1, "y");
                        u && (c[u.dataZoomId] = u), h && (c[h.dataZoomId] = h) } }, this), d.push(n, c), this._dispatchAction(c, o) } }, g._dispatchAction = function(t, e) {
            var i = [];
            p(t, function(t) { i.push(t) }), i[ye] && e[_e]({ type: "dataZoom", from: this.uid, batch: s.clone(i, !0) }) }, t("../featureManager").register("dataZoom", e), t("../../../echarts").registerPreprocessor(function(t) {
            function e(t, e) {
                if (e) {
                    var r = t + "Index",
                        a = e[r];
                    null == a || s[re](a) || (a = a === !1 ? [] : [a]), i(t, function(e, i) {
                        if (null == a || -1 !== s[ne](a, i)) {
                            var o = { type: "select", $fromToolbox: !0, id: v + t + i };
                            o[r] = i, n.push(o) } }) } }

            function i(e, i) {
                var n = t[e];
                s[re](n) || (n = n ? [n] : []), p(n, i) }
            if (t) {
                var n = t.dataZoom || (t.dataZoom = []);
                s[re](n) || (n = [n]);
                var r = t.toolbox;
                if (r && (s[re](r) && (r = r[0]), r && r.feature)) {
                    var a = r.feature.dataZoom;
                    e("xAxis", a), e("yAxis", a) } } }), e }), e("echarts/component/toolbox/feature/Restore", [We, "../../dataZoom/history", "../featureManager", "../../../echarts"], function(t) {
        function e(t) { this.model = t }
        var i = t("../../dataZoom/history");
        e.defaultOption = { show: !0, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: "还原" };
        var n = e[Ee];
        return n.onclick = function(t, e) { i.clear(t), e[_e]({ type: "restore", from: this.uid }) }, t("../featureManager").register("restore", e), t("../../../echarts").registerAction({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function(t, e) { e.resetOption("recreate") }), e }), e("echarts/scale/Interval", [We, "../util/number", "../util/format", "./Scale"], function(t) {
        var e = t("../util/number"),
            i = t("../util/format"),
            n = t("./Scale"),
            r = Math.floor,
            a = Math.ceil,
            o = n[be]({ type: "interval", _interval: 0, setExtent: function(t, e) {
                    var i = this._extent;
                    isNaN(t) || (i[0] = parseFloat(t)), isNaN(e) || (i[1] = parseFloat(e)) }, unionExtent: function(t) {
                    var e = this._extent;
                    t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), o[Ee].setExtent.call(this, e[0], e[1]) }, getInterval: function() {
                    return this._interval || this.niceTicks(), this._interval }, setInterval: function(t) { this._interval = t, this._niceExtent = this._extent.slice() }, getTicks: function() { this._interval || this.niceTicks();
                    var t = this._interval,
                        i = this._extent,
                        n = [],
                        r = 1e4;
                    if (t) {
                        var a = this._niceExtent;
                        i[0] < a[0] && n.push(i[0]);
                        for (var o = a[0]; o <= a[1];)
                            if (n.push(o), o = e.round(o + t), n[ye] > r) return [];
                        i[1] > a[1] && n.push(i[1]) }
                    return n }, getTicksLabels: function() {
                    for (var t = [], e = this.getTicks(), i = 0; i < e[ye]; i++) t.push(this.getLabel(e[i]));
                    return t }, getLabel: function(t) {
                    return i.addCommas(t) }, niceTicks: function(t) { t = t || 5;
                    var i = this._extent,
                        n = i[1] - i[0];
                    if (isFinite(n)) { 0 > n && (n = -n, i.reverse());
                        var o = e.nice(n / t, !0),
                            s = [e.round(a(i[0] / o) * o), e.round(r(i[1] / o) * o)];
                        this._interval = o, this._niceExtent = s } }, niceExtent: function(t, i, n) {
                    var o = this._extent;
                    if (o[0] === o[1])
                        if (0 !== o[0]) {
                            var s = o[0] / 2;
                            o[0] -= s, o[1] += s } else o[1] = 1;
                    var l = o[1] - o[0];
                    isFinite(l) || (o[0] = 0, o[1] = 1), this.niceTicks(t);
                    var c = this._interval;
                    i || (o[0] = e.round(r(o[0] / c) * c)), n || (o[1] = e.round(a(o[1] / c) * c)) } });
        return o[Ce] = function() {
            return new o }, o }), e("echarts/scale/Scale", [We, "../util/clazz"], function(t) {
        function e() { this._extent = [1 / 0, -1 / 0], this._interval = 0, this.init && this.init.apply(this, arguments) }
        var i = t("../util/clazz"),
            n = e[Ee];
        return n.parse = function(t) {
            return t }, n[G] = function(t) {
            var e = this._extent;
            return t >= e[0] && t <= e[1] }, n.normalize = function(t) {
            var e = this._extent;
            return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0]) }, n.scale = function(t) {
            var e = this._extent;
            return t * (e[1] - e[0]) + e[0] }, n.unionExtent = function(t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]) }, n[F] = function() {
            return this._extent.slice() }, n.setExtent = function(t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = t), isNaN(e) || (i[1] = e) }, n.getTicksLabels = function() {
            for (var t = [], e = this.getTicks(), i = 0; i < e[ye]; i++) t.push(this.getLabel(e[i]));
            return t }, i.enableClassExtend(e), i.enableClassManagement(e, { registerWhenExtend: !0 }), e }), e("zrender/graphic/Gradient", [We], function() {
        var t = function(t) { this.colorStops = t || [] };
        return t[Ee] = { constructor: t, addColorStop: function(t, e) { this.colorStops.push({ offset: t, color: e }) } }, t }), e("echarts/util/model", [We, "./format", "./number", He, "../model/Model"], function(t) {
        var e = t("./format"),
            i = t("./number"),
            n = t(He),
            r = t("../model/Model"),
            a = ["x", "y", "z", O, "angle"],
            o = {};
        return o.createNameEach = function(t, e) { t = t.slice();
            var i = n.map(t, o.capitalFirst);
            e = (e || []).slice();
            var r = n.map(e, o.capitalFirst);
            return function(a, o) { n.each(t, function(t, n) {
                    for (var s = { name: t, capital: i[n] }, l = 0; l < e[ye]; l++) s[e[l]] = t + r[l];
                    a.call(o, s) }) } }, o.capitalFirst = function(t) {
            return t ? t.charAt(0).toUpperCase() + t.substr(1) : t }, o.eachAxisDim = o.createNameEach(a, ["axisIndex", "axis", "index"]), o.normalizeToArray = function(t) {
            return n[re](t) ? t : null == t ? [] : [t] }, o.createLinkedNodesFinder = function(t, e, i) {
            function r(t, e) {
                return n[ne](e.nodes, t) >= 0 }

            function a(t, r) {
                var a = !1;
                return e(function(e) { n.each(i(t, e) || [], function(t) { r.records[e.name][t] && (a = !0) }) }), a }

            function o(t, r) { r.nodes.push(t), e(function(e) { n.each(i(t, e) || [], function(t) { r.records[e.name][t] = !0 }) }) }
            return function(i) {
                function n(t) {!r(t, s) && a(t, s) && (o(t, s), l = !0) }
                var s = { nodes: [], records: {} };
                if (e(function(t) { s.records[t.name] = {} }), !i) return s;
                o(i, s);
                var l;
                do l = !1, t(n); while (l);
                return s } }, o.defaultEmphasis = function(t, e) {
            if (t) {
                var i = t[y] = t[y] || {},
                    r = t[_] = t[_] || {};
                n.each(e, function(t) {
                    var e = n.retrieve(i[t], r[t]);
                    null != e && (i[t] = e) }) } }, o.createDataFormatModel = function(t, e, i) {
            var a = new r;
            return n.mixin(a, o.dataFormatMixin), a[ce] = t[ce], a.name = t.name || "", a[Ze] = function() {
                return e }, a.getRawDataArray = function() {
                return i }, a }, o.getDataItemValue = function(t) {
            return t && (null == t.value ? t : t.value) }, o.converDataValue = function(t, e) {
            var n = e && e.type;
            return n === A ? t : ("time" !== n || isFinite(t) || null == t || "-" === t || (t = +i.parseDate(t)), null == t || "" === t ? 0 / 0 : +t) }, o.dataFormatMixin = { getDataParams: function(t) {
                var e = this[Ze](),
                    i = this[ce],
                    n = this.name,
                    r = this.getRawValue(t),
                    a = e.getRawIndex(t),
                    o = e[p](t, !0),
                    s = this.getRawDataArray(),
                    l = s && s[a];
                return { componentType: "series", seriesType: this.subType, seriesIndex: i, seriesName: n, name: o, dataIndex: a, data: l, value: r, color: e[x](t, "color"), $vars: ["seriesName", "name", "value"] } }, getFormattedLabel: function(t, i, n) { i = i || _;
                var r = this[Ze](),
                    a = r[T](t),
                    o = this[le](t);
                return null == n && (n = a.get(["label", i, "formatter"])), typeof n === ie ? (o.status = i, n(o)) : typeof n === Be ? e.formatTpl(n, o) : void 0 }, getRawValue: function(t) {
                var e = this[Ze]()[T](t);
                if (e && null != e[u]) {
                    var i = e[u];
                    return n[Me](i) && !n[re](i) ? i.value : i } } }, o.mappingToExists = function(t, e) { e = (e || []).slice();
            var i = n.map(t || [], function(t) {
                return { exist: t } });
            return n.each(e, function(t, r) {
                if (n[Me](t))
                    for (var a = 0; a < i[ye]; a++) {
                        var s = i[a].exist;
                        if (!i[a][u] && (null != t.id && s.id === t.id + "" || null != t.name && !o.isIdInner(t) && !o.isIdInner(s) && s.name === t.name + "")) { i[a][u] = t, e[r] = null;
                            break } } }), n.each(e, function(t) {
                if (n[Me](t)) {
                    for (var e = 0; e < i[ye]; e++) {
                        var r = i[e].exist;
                        if (!i[e][u] && !o.isIdInner(r) && null == t.id) { i[e][u] = t;
                            break } }
                    e >= i[ye] && i.push({ option: t }) } }), i }, o.isIdInner = function(t) {
            return n[Me](t) && t.id && 0 === (t.id + "")[ne]("\x00_ec_\x00") }, o }), e("echarts/model/Model", [We, He, "../util/clazz", "./mixin/lineStyle", "./mixin/areaStyle", "./mixin/textStyle", "./mixin/itemStyle"], function(t) {
        function e(t, e, i, n) { this.parentModel = e, this[c] = i, this[u] = t, this.init && (arguments[ye] <= 4 ? this.init(t, e, i, n) : this.init.apply(this, arguments)) }
        var i = t(He),
            n = t("../util/clazz");
        e[Ee] = { constructor: e, init: null, mergeOption: function(t) { i.merge(this[u], t, !0) }, get: function(t, e) {
                if (!t) return this[u];
                typeof t === Be && (t = t.split("."));
                for (var i = this[u], n = this.parentModel, r = 0; r < t[ye] && (i = i && "object" == typeof i ? i[t[r]] : null, null != i); r++);
                return null == i && n && !e && (i = n.get(t)), i }, getShallow: function(t, e) {
                var i = this[u],
                    n = i && i[t],
                    r = this.parentModel;
                return null == n && r && !e && (n = r.getShallow(t)), n }, getModel: function(t, i) {
                var n = this.get(t, !0),
                    r = this.parentModel,
                    a = new e(n, i || r && r[Oe](t), this[c]);
                return a }, isEmpty: function() {
                return null == this[u] }, restoreData: function() {}, clone: function() {
                var t = this.constructor;
                return new t(i.clone(this[u])) }, setReadOnly: function(t) { n.setReadOnly(this, t) } }, n.enableClassExtend(e);
        var r = i.mixin;
        return r(e, t("./mixin/lineStyle")), r(e, t("./mixin/areaStyle")), r(e, t("./mixin/textStyle")), r(e, t("./mixin/itemStyle")), e }), e("echarts/model/globalDefault", [], function() {
        var t = "";
        return typeof navigator !== r && (t = navigator.platform || ""), { color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"], grid: {}, textStyle: { fontFamily: t.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, animation: !0, animationThreshold: 2e3, animationDuration: 1e3, animationDurationUpdate: 300, animationEasing: "exponentialOut", animationEasingUpdate: "cubicOut" } }), e("zrender/graphic/Path", [We, "./Displayable", n, "../core/PathProxy", "../contain/path", "./Gradient"], function(t) {
        function e(t) {
            var e = t.fill;
            return null != e && "none" !== e }

        function r(t) {
            var e = t[o];
            return null != e && "none" !== e && t[s] > 0 }

        function a(t) { l.call(this, t), this.path = new u }
        var l = t("./Displayable"),
            c = t(n),
            u = t("../core/PathProxy"),
            h = t("../contain/path"),
            d = t("./Gradient"),
            f = Math.abs;
        return a[Ee] = { constructor: a, type: "path", __dirtyPath: !0, strokeContainThreshold: 5, brush: function(t) { t.save();
                var n = this.style,
                    a = this.path,
                    s = r(n),
                    l = e(n);
                this.__dirtyPath && (l && n.fill instanceof d && n.fill.updateCanvasGradient(this, t), s && n[o] instanceof d && n[o].updateCanvasGradient(this, t)), n.bind(t, this), this.setTransform(t);
                var c = n.lineDash,
                    u = n.lineDashOffset,
                    h = !!t.setLineDash;
                this.__dirtyPath || c && !h && s ? (a = this.path.beginPath(t), c && !h && (a.setLineDash(c), a.setLineDashOffset(u)), this[i](a, this.shape), this.__dirtyPath = !1) : (t.beginPath(), this.path.rebuildPath(t)), l && a.fill(t), c && h && (t.setLineDash(c), t.lineDashOffset = u), s && a[o](t), null != n.text && this.drawRectText(t, this[U]()), t.restore() }, buildPath: function() {}, getBoundingRect: function() {
                var t = this._rect,
                    n = this.style,
                    a = !t;
                if (a) {
                    var o = this.path;
                    this.__dirtyPath && (o.beginPath(), this[i](o, this.shape)), t = o[U]() }
                if (this._rect = t, r(n)) {
                    var l = this._rectWithStroke;
                    if (this.__dirty || a) {
                        var l = this._rectWithStroke || (this._rectWithStroke = t.clone());
                        l.copy(t);
                        var c = n[s],
                            u = n.strokeNoScale ? this.getLineScale() : 1;
                        e(n) || (c = Math.max(c, this.strokeContainThreshold)), u > 1e-10 && (l.width += c / u, l[Ae] += c / u, l.x -= c / u / 2, l.y -= c / u / 2) }
                    return l }
                return t }, contain: function(t, i) {
                var n = this.transformCoordToLocal(t, i),
                    a = this[U](),
                    o = this.style;
                if (t = n[0], i = n[1], a[G](t, i)) {
                    var l = this.path.data;
                    if (r(o)) {
                        var c = o[s],
                            u = o.strokeNoScale ? this.getLineScale() : 1;
                        if (u > 1e-10 && (e(o) || (c = Math.max(c, this.strokeContainThreshold)), h.containStroke(l, c / u, t, i))) return !0 }
                    if (e(o)) return h[G](l, t, i) }
                return !1 }, dirty: function(t) { 0 === arguments[ye] && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty() }, animateShape: function(t) {
                return this.animate("shape", t) }, attrKV: function(t, e) { "shape" === t ? this.setShape(e) : l[Ee].attrKV.call(this, t, e) }, setShape: function(t, e) {
                var i = this.shape;
                if (i) {
                    if (c[Me](t))
                        for (var n in t) i[n] = t[n];
                    else i[t] = e;
                    this.dirty(!0) }
                return this }, getLineScale: function() {
                var t = this[Ne];
                return t && f(t[0] - 1) > 1e-10 && f(t[3] - 1) > 1e-10 ? Math.sqrt(f(t[0] * t[3] - t[2] * t[1])) : 1 } }, a[be] = function(t) {
            var e = function(e) { a.call(this, e), t.style && this.style.extendFrom(t.style, !1);
                var i = t.shape;
                if (i) { this.shape = this.shape || {};
                    var n = this.shape;
                    for (var r in i) !n.hasOwnProperty(r) && i.hasOwnProperty(r) && (n[r] = i[r]) }
                t.init && t.init.call(this, e) };
            c[te](e, a);
            for (var i in t) "style" !== i && "shape" !== i && (e[Ee][i] = t[i]);
            return e }, c[te](a, l), a }), e("zrender/tool/path", [We, "../graphic/Path", "../core/PathProxy", "./transformPath", "../core/matrix"], function(t) {
        function e(t, e, i, n, r, a, o, s, l, c, u) {
            var m = l * (p / 180),
                y = f(m) * (t - i) / 2 + d(m) * (e - n) / 2,
                x = -1 * d(m) * (t - i) / 2 + f(m) * (e - n) / 2,
                _ = y * y / (o * o) + x * x / (s * s);
            _ > 1 && (o *= h(_), s *= h(_));
            var b = (r === a ? -1 : 1) * h((o * o * s * s - o * o * x * x - s * s * y * y) / (o * o * x * x + s * s * y * y)) || 0,
                w = b * o * x / s,
                M = b * -s * y / o,
                S = (t + i) / 2 + f(m) * w - d(m) * M,
                T = (e + n) / 2 + d(m) * w + f(m) * M,
                C = g([1, 0], [(y - w) / o, (x - M) / s]),
                A = [(y - w) / o, (x - M) / s],
                k = [(-1 * y - w) / o, (-1 * x - M) / s],
                L = g(A, k);
            v(A, k) <= -1 && (L = p), v(A, k) >= 1 && (L = 0), 0 === a && L > 0 && (L -= 2 * p), 1 === a && 0 > L && (L += 2 * p), u.addData(c, S, T, o, s, C, L, m, a) }

        function n(t) {
            if (!t) return [];
            var i, n = t[ae](/-/g, " -")[ae](/  /g, " ")[ae](/ /g, ",")[ae](/,,/g, ",");
            for (i = 0; i < u[ye]; i++) n = n[ae](new RegExp(u[i], "g"), "|" + u[i]);
            var r, a = n.split("|"),
                s = 0,
                l = 0,
                c = new o,
                h = o.CMD;
            for (i = 1; i < a[ye]; i++) {
                var d, f = a[i],
                    p = f.charAt(0),
                    m = 0,
                    v = f.slice(1)[ae](/e,-/g, "e-").split(",");
                v[ye] > 0 && "" === v[0] && v.shift();
                for (var g = 0; g < v[ye]; g++) v[g] = parseFloat(v[g]);
                for (; m < v[ye] && !isNaN(v[m]) && !isNaN(v[0]);) {
                    var y, x, _, b, w, M, S, T = s,
                        C = l;
                    switch (p) {
                        case "l":
                            s += v[m++], l += v[m++], d = h.L, c.addData(d, s, l);
                            break;
                        case "L":
                            s = v[m++], l = v[m++], d = h.L, c.addData(d, s, l);
                            break;
                        case "m":
                            s += v[m++], l += v[m++], d = h.M, c.addData(d, s, l), p = "l";
                            break;
                        case "M":
                            s = v[m++], l = v[m++], d = h.M, c.addData(d, s, l), p = "L";
                            break;
                        case "h":
                            s += v[m++], d = h.L, c.addData(d, s, l);
                            break;
                        case "H":
                            s = v[m++], d = h.L, c.addData(d, s, l);
                            break;
                        case "v":
                            l += v[m++], d = h.L, c.addData(d, s, l);
                            break;
                        case "V":
                            l = v[m++], d = h.L, c.addData(d, s, l);
                            break;
                        case "C":
                            d = h.C, c.addData(d, v[m++], v[m++], v[m++], v[m++], v[m++], v[m++]), s = v[m - 2], l = v[m - 1];
                            break;
                        case "c":
                            d = h.C, c.addData(d, v[m++] + s, v[m++] + l, v[m++] + s, v[m++] + l, v[m++] + s, v[m++] + l), s += v[m - 2], l += v[m - 1];
                            break;
                        case "S":
                            y = s, x = l;
                            var A = c.len(),
                                k = c.data;
                            r === h.C && (y += s - k[A - 4], x += l - k[A - 3]), d = h.C, T = v[m++], C = v[m++], s = v[m++], l = v[m++], c.addData(d, y, x, T, C, s, l);
                            break;
                        case "s":
                            y = s, x = l;
                            var A = c.len(),
                                k = c.data;
                            r === h.C && (y += s - k[A - 4], x += l - k[A - 3]), d = h.C, T = s + v[m++], C = l + v[m++], s += v[m++], l += v[m++], c.addData(d, y, x, T, C, s, l);
                            break;
                        case "Q":
                            T = v[m++], C = v[m++], s = v[m++], l = v[m++], d = h.Q, c.addData(d, T, C, s, l);
                            break;
                        case "q":
                            T = v[m++] + s, C = v[m++] + l, s += v[m++], l += v[m++], d = h.Q, c.addData(d, T, C, s, l);
                            break;
                        case "T":
                            y = s, x = l;
                            var A = c.len(),
                                k = c.data;
                            r === h.Q && (y += s - k[A - 4], x += l - k[A - 3]), s = v[m++], l = v[m++], d = h.Q, c.addData(d, y, x, s, l);
                            break;
                        case "t":
                            y = s, x = l;
                            var A = c.len(),
                                k = c.data;
                            r === h.Q && (y += s - k[A - 4], x += l - k[A - 3]), s += v[m++], l += v[m++], d = h.Q, c.addData(d, y, x, s, l);
                            break;
                        case "A":
                            _ = v[m++], b = v[m++], w = v[m++], M = v[m++], S = v[m++], T = s, C = l, s = v[m++], l = v[m++], d = h.A, e(T, C, s, l, M, S, _, b, w, d, c);
                            break;
                        case "a":
                            _ = v[m++], b = v[m++], w = v[m++], M = v[m++], S = v[m++], T = s, C = l, s += v[m++], l += v[m++], d = h.A, e(T, C, s, l, M, S, _, b, w, d, c) } }("z" === p || "Z" === p) && (d = h.Z, c.addData(d)), r = d }
            return c.toStatic(), c }

        function r(t, e) {
            var r, a = n(t);
            return e = e || {}, e[i] = function(t) { t.setData(a.data), r && s(t, r);
                var e = t[V]();
                e && t.rebuildPath(e) }, e[l] = function(t) { r || (r = c[Ce]()), c.mul(r, t, r) }, e }
        var a = t("../graphic/Path"),
            o = t("../core/PathProxy"),
            s = t("./transformPath"),
            c = t("../core/matrix"),
            u = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"],
            h = Math.sqrt,
            d = Math.sin,
            f = Math.cos,
            p = Math.PI,
            m = function(t) {
                return Math.sqrt(t[0] * t[0] + t[1] * t[1]) },
            v = function(t, e) {
                return (t[0] * e[0] + t[1] * e[1]) / (m(t) * m(e)) },
            g = function(t, e) {
                return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(v(t, e)) };
        return { createFromString: function(t, e) {
                return new a(r(t, e)) }, extendFromString: function(t, e) {
                return a[be](r(t, e)) }, mergePath: function(t, e) {
                var n, r, o = [],
                    s = t[ye];
                for (r = 0; s > r; r++) n = t[r], n.__dirty && n[i](n.path, n.shape), o.push(n.path);
                var l = new a(e);
                return l[i] = function(t) { t.appendPath(o);
                    var e = t[V]();
                    e && t.rebuildPath(e) }, l } } }), e("zrender/container/Group", [We, n, "../Element", "../core/BoundingRect"], function(t) {
        var e = t(n),
            i = t("../Element"),
            r = t("../core/BoundingRect"),
            o = function(t) { t = t || {}, i.call(this, t);
                for (var e in t) this[e] = t[e];
                this._children = [], this.__storage = null, this.__dirty = !0 };
        return o[Ee] = { constructor: o, type: "group", silent: !1, children: function() {
                return this._children.slice() }, childAt: function(t) {
                return this._children[t] }, childOfName: function(t) {
                for (var e = this._children, i = 0; i < e[ye]; i++)
                    if (e[i].name === t) return e[i] }, childCount: function() {
                return this._children[ye] }, add: function(t) {
                return t && t !== this && t[a] !== this && (this._children.push(t), this._doAdd(t)), this }, addBefore: function(t, e) {
                if (t && t !== this && t[a] !== this && e && e[a] === this) {
                    var i = this._children,
                        n = i[ne](e);
                    n >= 0 && (i[pe](n, 0, t), this._doAdd(t)) }
                return this }, _doAdd: function(t) { t[a] && t[a][we](t), t[a] = this;
                var e = this.__storage,
                    i = this.__zr;
                e && e !== t.__storage && (e.addToMap(t), t instanceof o && t.addChildrenToStorage(e)), i && i.refresh() }, remove: function(t) {
                var i = this.__zr,
                    n = this.__storage,
                    r = this._children,
                    s = e[ne](r, t);
                return 0 > s ? this : (r[pe](s, 1), t[a] = null, n && (n.delFromMap(t.id), t instanceof o && t.delChildrenFromStorage(n)), i && i.refresh(), this) }, removeAll: function() {
                var t, e, i = this._children,
                    n = this.__storage;
                for (e = 0; e < i[ye]; e++) t = i[e], n && (n.delFromMap(t.id), t instanceof o && t.delChildrenFromStorage(n)), t[a] = null;
                return i[ye] = 0, this }, eachChild: function(t, e) {
                for (var i = this._children, n = 0; n < i[ye]; n++) {
                    var r = i[n];
                    t.call(e, r, n) }
                return this }, traverse: function(t, e) {
                for (var i = 0; i < this._children[ye]; i++) {
                    var n = this._children[i];
                    t.call(e, n), "group" === n.type && n[oe](t, e) }
                return this }, addChildrenToStorage: function(t) {
                for (var e = 0; e < this._children[ye]; e++) {
                    var i = this._children[e];
                    t.addToMap(i), i instanceof o && i.addChildrenToStorage(t) } }, delChildrenFromStorage: function(t) {
                for (var e = 0; e < this._children[ye]; e++) {
                    var i = this._children[e];
                    t.delFromMap(i.id), i instanceof o && i.delChildrenFromStorage(t) } }, dirty: function() {
                return this.__dirty = !0, this.__zr && this.__zr.refresh(), this }, getBoundingRect: function(t) {
                for (var e = null, i = new r(0, 0, 0, 0), n = t || this._children, a = [], o = 0; o < n[ye]; o++) {
                    var s = n[o];
                    if (!s[Le] && !s.invisible) {
                        var c = s[U](),
                            u = s.getLocalTransform(a);
                        u ? (i.copy(c), i[l](u), e = e || i.clone(), e.union(i)) : (e = e || c.clone(), e.union(c)) } }
                return e || i } }, e[te](o, i), o }), e("zrender/graphic/Image", [We, "./Displayable", "../core/BoundingRect", n, "./helper/roundRect", "../core/LRU"], function(t) {
        function e(t) { r.call(this, t) }
        var r = t("./Displayable"),
            a = t("../core/BoundingRect"),
            o = t(n),
            s = t("./helper/roundRect"),
            l = t("../core/LRU"),
            c = new l(50);
        return e[Ee] = { constructor: e, type: "image", brush: function(t) {
                var e, n = this.style,
                    r = n.image;
                if (e = typeof r === Be ? this._image : r, !e && r) {
                    var a = c.get(r);
                    if (!a) return e = new Image, e.onload = function() { e.onload = null;
                        for (var t = 0; t < a.pending[ye]; t++) a.pending[t].dirty() }, a = { image: e, pending: [this] }, e.src = r, c.put(r, a), void(this._image = e);
                    if (e = a.image, this._image = e, !e.width || !e[Ae]) return void a.pending.push(this) }
                if (e) {
                    var o = n.width || e.width,
                        l = n[Ae] || e[Ae],
                        u = n.x || 0,
                        h = n.y || 0;
                    if (!e.width || !e[Ae]) return;
                    if (t.save(), n.bind(t), this.setTransform(t), n.r && (t.beginPath(), s[i](t, n), t.clip()), n.sWidth && n.sHeight) {
                        var d = n.sx || 0,
                            f = n.sy || 0;
                        t.drawImage(e, d, f, n.sWidth, n.sHeight, u, h, o, l) } else if (n.sx && n.sy) {
                        var d = n.sx,
                            f = n.sy,
                            p = o - d,
                            m = l - f;
                        t.drawImage(e, d, f, p, m, u, h, o, l) } else t.drawImage(e, u, h, o, l);
                    null == n.width && (n.width = o), null == n[Ae] && (n[Ae] = l), null != n.text && this.drawRectText(t, this[U]()), t.restore() } }, getBoundingRect: function() {
                var t = this.style;
                return this._rect || (this._rect = new a(t.x || 0, t.y || 0, t.width || 0, t[Ae] || 0)), this._rect } }, o[te](e, r), e }), e("zrender/graphic/Text", [We, "./Displayable", n, "../contain/text"], function(t) {
        var e = t("./Displayable"),
            i = t(n),
            r = t("../contain/text"),
            a = function(t) { e.call(this, t) };
        return a[Ee] = { constructor: a, type: "text", brush: function(t) {
                var e = this.style,
                    i = e.x || 0,
                    n = e.y || 0,
                    a = e.text,
                    s = e.fill,
                    l = e[o];
                if (null != a && (a += ""), a) {
                    if (t.save(), this.style.bind(t), this.setTransform(t), s && (t.fillStyle = s), l && (t.strokeStyle = l), t.font = e.textFont || e.font, t[$] = e[$], e.textVerticalAlign) {
                        var c = r[U](a, t.font, e[$], "top");
                        switch (t.textBaseline = "top", e.textVerticalAlign) {
                            case j:
                                n -= c[Ae] / 2;
                                break;
                            case ke:
                                n -= c[Ae] } } else t.textBaseline = e.textBaseline;
                    for (var u = r.measureText("国", t.font).width, h = a.split("\n"), d = 0; d < h[ye]; d++) s && t.fillText(h[d], i, n), l && t.strokeText(h[d], i, n), n += u;
                    t.restore() } }, getBoundingRect: function() {
                if (!this._rect) {
                    var t = this.style,
                        e = t.textVerticalAlign,
                        i = r[U](t.text + "", t.textFont || t.font, t[$], e ? "top" : t.textBaseline);
                    switch (e) {
                        case j:
                            i.y -= i[Ae] / 2;
                            break;
                        case ke:
                            i.y -= i[Ae] }
                    i.x += t.x || 0, i.y += t.y || 0, this._rect = i }
                return this._rect } }, i[te](a, e), a }), e("zrender/graphic/shape/Circle", [We, "../Path"], function(t) {
        return t("../Path")[be]({ type: "circle", shape: { cx: 0, cy: 0, r: 0 }, buildPath: function(t, e) { t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0) } }) }), e("zrender/graphic/shape/Sector", [We, "../Path"], function(t) {
        return t("../Path")[be]({ type: "sector", shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, buildPath: function(t, e) {
                var i = e.cx,
                    n = e.cy,
                    r = Math.max(e.r0 || 0, 0),
                    a = Math.max(e.r, 0),
                    o = e.startAngle,
                    s = e.endAngle,
                    l = e.clockwise,
                    c = Math.cos(o),
                    u = Math.sin(o);
                t.moveTo(c * r + i, u * r + n), t.lineTo(c * a + i, u * a + n), t.arc(i, n, a, o, s, !l), t.lineTo(Math.cos(s) * r + i, Math.sin(s) * r + n), 0 !== r && t.arc(i, n, r, s, o, l), t.closePath() } }) }), e("zrender/graphic/shape/Ring", [We, "../Path"], function(t) {
        return t("../Path")[be]({ type: "ring", shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function(t, e) {
                var i = e.cx,
                    n = e.cy,
                    r = 2 * Math.PI;
                t.moveTo(i + e.r, n), t.arc(i, n, e.r, 0, r, !1), t.moveTo(i + e.r0, n), t.arc(i, n, e.r0, 0, r, !0) } }) }), e("zrender/graphic/shape/Polygon", [We, "../helper/poly", "../Path"], function(t) {
        var e = t("../helper/poly");
        return t("../Path")[be]({ type: "polygon", shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath: function(t, n) { e[i](t, n, !0) } }) }), e("zrender/graphic/shape/Polyline", [We, "../helper/poly", "../Path"], function(t) {
        var e = t("../helper/poly");
        return t("../Path")[be]({ type: "polyline", shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: "#000", fill: null }, buildPath: function(t, n) { e[i](t, n, !1) } }) }), e("zrender/graphic/shape/Rect", [We, "../helper/roundRect", "../Path"], function(t) {
        var e = t("../helper/roundRect");
        return t("../Path")[be]({ type: "rect", shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function(t, n) {
                var r = n.x,
                    a = n.y,
                    o = n.width,
                    s = n[Ae];
                n.r ? e[i](t, n) : t.rect(r, a, o, s), t.closePath() } }) }), e("zrender/graphic/shape/Line", [We, "../Path"], function(t) {
        return t("../Path")[be]({ type: "line", shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) {
                var i = e.x1,
                    n = e.y1,
                    r = e.x2,
                    a = e.y2,
                    o = e.percent;
                0 !== o && (t.moveTo(i, n), 1 > o && (r = i * (1 - o) + r * o, a = n * (1 - o) + a * o), t.lineTo(r, a)) }, pointAt: function(t) {
                var e = this.shape;
                return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t] } }) }), e("zrender/graphic/shape/BezierCurve", [We, "../../core/curve", "../Path"], function(t) {
        var e = t("../../core/curve"),
            i = e.quadraticSubdivide,
            n = e.cubicSubdivide,
            r = e.quadraticAt,
            a = e.cubicAt,
            o = [];
        return t("../Path")[be]({ type: "bezier-curve", shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) {
                var r = e.x1,
                    a = e.y1,
                    s = e.x2,
                    l = e.y2,
                    c = e.cpx1,
                    u = e.cpy1,
                    h = e.cpx2,
                    d = e.cpy2,
                    f = e.percent;
                0 !== f && (t.moveTo(r, a), null == h || null == d ? (1 > f && (i(r, c, s, f, o), c = o[1], s = o[2], i(a, u, l, f, o), u = o[1], l = o[2]), t.quadraticCurveTo(c, u, s, l)) : (1 > f && (n(r, c, h, s, f, o), c = o[1], h = o[2], s = o[3], n(a, u, d, l, f, o), u = o[1], d = o[2], l = o[3]), t.bezierCurveTo(c, u, h, d, s, l))) }, pointAt: function(t) {
                var e = this.shape,
                    i = e.cpx2,
                    n = e.cpy2;
                return null === i || null === n ? [r(e.x1, e.cpx1, e.x2, t), r(e.y1, e.cpy1, e.y2, t)] : [a(e.x1, e.cpx1, e.cpx1, e.x2, t), a(e.y1, e.cpy1, e.cpy1, e.y2, t)] } }) }), e("zrender/graphic/shape/Arc", [We, "../Path"], function(t) {
        return t("../Path")[be]({ type: "arc", shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: "#000", fill: null }, buildPath: function(t, e) {
                var i = e.cx,
                    n = e.cy,
                    r = Math.max(e.r, 0),
                    a = e.startAngle,
                    o = e.endAngle,
                    s = e.clockwise,
                    l = Math.cos(a),
                    c = Math.sin(a);
                t.moveTo(l * r + i, c * r + n), t.arc(i, n, r, a, o, !s) } }) }), e("zrender/graphic/LinearGradient", [We, n, "./Gradient"], function(t) {
        var e = t(n),
            i = t("./Gradient"),
            r = function(t, e, n, r, a) { this.x = null == t ? 0 : t, this.y = null == e ? 0 : e, this.x2 = null == n ? 1 : n, this.y2 = null == r ? 0 : r, i.call(this, a) };
        return r[Ee] = { constructor: r, type: "linear", updateCanvasGradient: function(t, e) {
                for (var i = t[U](), n = this.x * i.width + i.x, r = this.x2 * i.width + i.x, a = this.y * i[Ae] + i.y, o = this.y2 * i[Ae] + i.y, s = e.createLinearGradient(n, a, r, o), l = this.colorStops, c = 0; c < l[ye]; c++) s.addColorStop(l[c].offset, l[c].color);
                this.canvasGradient = s } }, e[te](r, i), r }), e("zrender/contain/text", [We, n, "../core/BoundingRect"], function(t) {
        function e(t, e) {
            var i = t + ":" + e;
            if (l[i]) return l[i];
            for (var n = (t + "").split("\n"), r = 0, a = 0, o = n[ye]; o > a; a++) r = Math.max(p.measureText(n[a], e).width, r);
            return c > u && (c = 0, l = {}), c++, l[i] = r, r }

        function i(t, i, n, r) {
            var a = ((t || "") + "").split("\n")[ye],
                o = e(t, i),
                s = e("国", i),
                l = a * s,
                c = new d(0, 0, o, l);
            switch (c.lineHeight = s, r) {
                case ke:
                case "alphabetic":
                    c.y -= s;
                    break;
                case j:
                    c.y -= s / 2 }
            switch (n) {
                case "end":
                case "right":
                    c.x -= c.width;
                    break;
                case q:
                    c.x -= c.width / 2 }
            return c }

        function r(t, e, i, n) {
            var r = e.x,
                a = e.y,
                o = e[Ae],
                s = e.width,
                l = i[Ae],
                c = o / 2 - l / 2,
                u = "left";
            switch (t) {
                case "left":
                    r -= n, a += c, u = "right";
                    break;
                case "right":
                    r += n + s, a += c, u = "left";
                    break;
                case "top":
                    r += s / 2, a -= n + l, u = q;
                    break;
                case ke:
                    r += s / 2, a += o + n, u = q;
                    break;
                case f:
                    r += s / 2, a += c, u = q;
                    break;
                case "insideLeft":
                    r += n, a += c, u = "left";
                    break;
                case "insideRight":
                    r += s - n, a += c, u = "right";
                    break;
                case "insideTop":
                    r += s / 2, a += n, u = q;
                    break;
                case "insideBottom":
                    r += s / 2, a += o - l - n, u = q;
                    break;
                case "insideTopLeft":
                    r += n, a += n, u = "left";
                    break;
                case "insideTopRight":
                    r += s - n, a += n, u = "right";
                    break;
                case "insideBottomLeft":
                    r += n, a += o - l - n;
                    break;
                case "insideBottomRight":
                    r += s - n, a += o - l - n, u = "right" }
            return { x: r, y: a, textAlign: u, textBaseline: "top" } }

        function a(t, i, n, r) {
            if (!n) return "";
            r = h[xe]({ ellipsis: "...", minCharacters: 3, maxIterations: 3, cnCharWidth: e("国", i), ascCharWidth: e("a", i) }, r, !0), n -= e(r.ellipsis);
            for (var a = (t + "").split("\n"), s = 0, l = a[ye]; l > s; s++) a[s] = o(a[s], i, n, r);
            return a.join("\n") }

        function o(t, i, n, r) {
            for (var a = 0;; a++) {
                var o = e(t, i);
                if (n > o || a >= r.maxIterations) { t += r.ellipsis;
                    break }
                var l = 0 === a ? s(t, n, r) : Math.floor(t[ye] * n / o);
                if (l < r.minCharacters) { t = "";
                    break }
                t = t.substr(0, l) }
            return t }

        function s(t, e, i) {
            for (var n = 0, r = 0, a = t[ye]; a > r && e > n; r++) {
                var o = t.charCodeAt(r);
                n += o >= 0 && 127 >= o ? i.ascCharWidth : i.cnCharWidth }
            return r }
        var l = {},
            c = 0,
            u = 5e3,
            h = t(n),
            d = t("../core/BoundingRect"),
            p = {
                getWidth: e,
                getBoundingRect: i,
                adjustTextPositionOnRect: r,
                ellipsis: a,
                measureText: function(t, e) {
                    var i = h[V]();
                    return i.font = e, i.measureText(t)
                }
            };
        return p
    }), e("zrender/graphic/RadialGradient", [We, n, "./Gradient"], function(t) {
        var e = t(n),
            i = t("./Gradient"),
            r = function(t, e, n, r) { this.x = null == t ? .5 : t, this.y = null == e ? .5 : e, this.r = null == n ? .5 : n, i.call(this, r) };
        return r[Ee] = { constructor: r, type: "radial", updateCanvasGradient: function(t, e) {
                for (var i = t[U](), n = i.width, r = i[Ae], a = Math.min(n, r), o = this.x * n + i.x, s = this.y * r + i.y, l = this.r * a, c = e.createRadialGradient(o, s, 0, o, s, l), u = this.colorStops, h = 0; h < u[ye]; h++) c.addColorStop(u[h].offset, u[h].color);
                this.canvasGradient = c } }, e[te](r, i), r }), e("zrender/core/BoundingRect", [We, "./vector", "./matrix"], function(t) {
        function e(t, e, i, n) { this.x = t, this.y = e, this.width = i, this[Ae] = n }
        var i = t("./vector"),
            n = t("./matrix"),
            r = i[l],
            a = Math.min,
            o = Math.abs,
            s = Math.max;
        return e[Ee] = { constructor: e, union: function(t) {
                var e = a(t.x, this.x),
                    i = a(t.y, this.y);
                this.width = s(t.x + t.width, this.x + this.width) - e, this[Ae] = s(t.y + t[Ae], this.y + this[Ae]) - i, this.x = e, this.y = i }, applyTransform: function() {
                var t = [],
                    e = [];
                return function(i) { i && (t[0] = this.x, t[1] = this.y, e[0] = this.x + this.width, e[1] = this.y + this[Ae], r(t, t, i), r(e, e, i), this.x = a(t[0], e[0]), this.y = a(t[1], e[1]), this.width = o(e[0] - t[0]), this[Ae] = o(e[1] - t[1])) } }(), calculateTransform: function(t) {
                var e = this,
                    i = t.width / e.width,
                    r = t[Ae] / e[Ae],
                    a = n[Ce]();
                return n.translate(a, a, [-e.x, -e.y]), n.scale(a, a, [i, r]), n.translate(a, a, [t.x, t.y]), a }, intersect: function(t) {
                var e = this,
                    i = e.x,
                    n = e.x + e.width,
                    r = e.y,
                    a = e.y + e[Ae],
                    o = t.x,
                    s = t.x + t.width,
                    l = t.y,
                    c = t.y + t[Ae];
                return !(o > n || i > s || l > a || r > c) }, contain: function(t, e) {
                var i = this;
                return t >= i.x && t <= i.x + i.width && e >= i.y && e <= i.y + i[Ae] }, clone: function() {
                return new e(this.x, this.y, this.width, this[Ae]) }, copy: function(t) { this.x = t.x, this.y = t.y, this.width = t.width, this[Ae] = t[Ae] } }, e }), e("zrender/core/PathProxy", [We, "./curve", "./vector", "./bbox", "./BoundingRect"], function(t) {
        var e = t("./curve"),
            i = t("./vector"),
            n = t("./bbox"),
            a = t("./BoundingRect"),
            s = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 },
            l = [],
            c = [],
            u = [],
            h = [],
            d = Math.min,
            f = Math.max,
            p = Math.cos,
            m = Math.sin,
            v = Math.sqrt,
            g = typeof Float32Array != r,
            y = function() { this.data = [], this._len = 0, this._ctx = null, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0 };
        return y[Ee] = { constructor: y, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, getContext: function() {
                return this._ctx }, beginPath: function(t) {
                return this._ctx = t, t && t.beginPath(), this._len = 0, this._lineDash && (this._lineDash = null, this._dashOffset = 0), this }, moveTo: function(t, e) {
                return this.addData(s.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this }, lineTo: function(t, e) {
                return this.addData(s.L, t, e), this._ctx && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), this._xi = t, this._yi = e, this }, bezierCurveTo: function(t, e, i, n, r, a) {
                return this.addData(s.C, t, e, i, n, r, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, r, a) : this._ctx.bezierCurveTo(t, e, i, n, r, a)), this._xi = r, this._yi = a, this }, quadraticCurveTo: function(t, e, i, n) {
                return this.addData(s.Q, t, e, i, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)), this._xi = i, this._yi = n, this }, arc: function(t, e, i, n, r, a) {
                return this.addData(s.A, t, e, i, i, n, r - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, i, n, r, a), this._xi = p(r) * i + t, this._xi = m(r) * i + t, this }, arcTo: function(t, e, i, n, r) {
                return this._ctx && this._ctx.arcTo(t, e, i, n, r), this }, rect: function(t, e, i, n) {
                return this._ctx && this._ctx.rect(t, e, i, n), this.addData(s.R, t, e, i, n), this }, closePath: function() { this.addData(s.Z);
                var t = this._ctx,
                    e = this._x0,
                    i = this._y0;
                return t && (this._needsDash() && this._dashedLineTo(e, i), t.closePath()), this._xi = e, this._yi = i, this }, fill: function(t) { t && t.fill(), this.toStatic() }, stroke: function(t) { t && t[o](), this.toStatic() }, setLineDash: function(t) {
                if (t instanceof Array) { this._lineDash = t, this._dashIdx = 0;
                    for (var e = 0, i = 0; i < t[ye]; i++) e += t[i];
                    this._dashSum = e }
                return this }, setLineDashOffset: function(t) {
                return this._dashOffset = t, this }, len: function() {
                return this._len }, setData: function(t) {
                var e = t[ye];
                this.data && this.data[ye] == e || !g || (this.data = new Float32Array(e));
                for (var i = 0; e > i; i++) this.data[i] = t[i];
                this._len = e }, appendPath: function(t) { t instanceof Array || (t = [t]);
                for (var e = t[ye], i = 0, n = this._len, r = 0; e > r; r++) i += t[r].len();
                g && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
                for (var r = 0; e > r; r++)
                    for (var a = t[r].data, o = 0; o < a[ye]; o++) this.data[n++] = a[o];
                this._len = n }, addData: function(t) {
                var e = this.data;
                this._len + arguments[ye] > e[ye] && (this._expandData(), e = this.data);
                for (var i = 0; i < arguments[ye]; i++) e[this._len++] = arguments[i];
                this._prevCmd = t }, _expandData: function() {
                if (!(this.data instanceof Array)) {
                    for (var t = [], e = 0; e < this._len; e++) t[e] = this.data[e];
                    this.data = t } }, _needsDash: function() {
                return this._lineDash }, _dashedLineTo: function(t, e) {
                var i, n, r = this._dashSum,
                    a = this._dashOffset,
                    o = this._lineDash,
                    s = this._ctx,
                    l = this._xi,
                    c = this._yi,
                    u = t - l,
                    h = e - c,
                    p = v(u * u + h * h),
                    m = l,
                    g = c,
                    y = o[ye];
                for (u /= p, h /= p, 0 > a && (a = r + a), a %= r, m -= a * u, g -= a * h; u >= 0 && t >= m || 0 > u && m > t;) n = this._dashIdx, i = o[n], m += u * i, g += h * i, this._dashIdx = (n + 1) % y, u > 0 && l > m || 0 > u && m > l || s[n % 2 ? "moveTo" : "lineTo"](u >= 0 ? d(m, t) : f(m, t), h >= 0 ? d(g, e) : f(g, e));
                u = m - t, h = g - e, this._dashOffset = -v(u * u + h * h) }, _dashedBezierTo: function(t, i, n, r, a, o) {
                var s, l, c, u, h, d = this._dashSum,
                    f = this._dashOffset,
                    p = this._lineDash,
                    m = this._ctx,
                    g = this._xi,
                    y = this._yi,
                    x = e.cubicAt,
                    _ = 0,
                    b = this._dashIdx,
                    w = p[ye],
                    M = 0;
                for (0 > f && (f = d + f), f %= d, s = 0; 1 > s; s += .1) l = x(g, t, n, a, s + .1) - x(g, t, n, a, s), c = x(y, i, r, o, s + .1) - x(y, i, r, o, s), _ += v(l * l + c * c);
                for (; w > b && (M += p[b], !(M > f)); b++);
                for (s = (M - f) / _; 1 >= s;) u = x(g, t, n, a, s), h = x(y, i, r, o, s), b % 2 ? m.moveTo(u, h) : m.lineTo(u, h), s += p[b] / _, b = (b + 1) % w;
                b % 2 !== 0 && m.lineTo(a, o), l = a - u, c = o - h, this._dashOffset = -v(l * l + c * c) }, _dashedQuadraticTo: function(t, e, i, n) {
                var r = i,
                    a = n;
                i = (i + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, i, n, r, a) }, toStatic: function() {
                var t = this.data;
                t instanceof Array && (t[ye] = this._len, g && (this.data = new Float32Array(t))) }, getBoundingRect: function() { l[0] = l[1] = u[0] = u[1] = Number.MAX_VALUE, c[0] = c[1] = h[0] = h[1] = -Number.MAX_VALUE;
                for (var t = this.data, e = 0, r = 0, o = 0, d = 0, f = 0; f < t[ye];) {
                    var v = t[f++];
                    switch (1 == f && (e = t[f], r = t[f + 1], o = e, d = r), v) {
                        case s.M:
                            o = t[f++], d = t[f++], e = o, r = d, u[0] = o, u[1] = d, h[0] = o, h[1] = d;
                            break;
                        case s.L:
                            n.fromLine(e, r, t[f], t[f + 1], u, h), e = t[f++], r = t[f++];
                            break;
                        case s.C:
                            n.fromCubic(e, r, t[f++], t[f++], t[f++], t[f++], t[f], t[f + 1], u, h), e = t[f++], r = t[f++];
                            break;
                        case s.Q:
                            n.fromQuadratic(e, r, t[f++], t[f++], t[f], t[f + 1], u, h), e = t[f++], r = t[f++];
                            break;
                        case s.A:
                            var g = t[f++],
                                y = t[f++],
                                x = t[f++],
                                _ = t[f++],
                                b = t[f++],
                                w = t[f++] + b,
                                M = (t[f++], 1 - t[f++]);
                            1 == f && (o = p(b) * x + g, d = m(b) * _ + y), n.fromArc(g, y, x, _, b, w, M, u, h), e = p(w) * x + g, r = m(w) * _ + y;
                            break;
                        case s.R:
                            o = e = t[f++], d = r = t[f++];
                            var S = t[f++],
                                T = t[f++];
                            n.fromLine(o, d, o + S, d + T, u, h);
                            break;
                        case s.Z:
                            e = o, r = d }
                    i.min(l, l, u), i.max(c, c, h) }
                return 0 === f && (l[0] = l[1] = c[0] = c[1] = 0), new a(l[0], l[1], c[0] - l[0], c[1] - l[1]) }, rebuildPath: function(t) {
                for (var e = this.data, i = 0; i < this._len;) {
                    var n = e[i++];
                    switch (n) {
                        case s.M:
                            t.moveTo(e[i++], e[i++]);
                            break;
                        case s.L:
                            t.lineTo(e[i++], e[i++]);
                            break;
                        case s.C:
                            t.bezierCurveTo(e[i++], e[i++], e[i++], e[i++], e[i++], e[i++]);
                            break;
                        case s.Q:
                            t.quadraticCurveTo(e[i++], e[i++], e[i++], e[i++]);
                            break;
                        case s.A:
                            var r = e[i++],
                                a = e[i++],
                                o = e[i++],
                                l = e[i++],
                                c = e[i++],
                                u = e[i++],
                                h = e[i++],
                                d = e[i++],
                                f = o > l ? o : l,
                                p = o > l ? 1 : o / l,
                                m = o > l ? l / o : 1,
                                v = Math.abs(o - l) > .001;
                            v ? (t.translate(r, a), t.rotate(h), t.scale(p, m), t.arc(0, 0, f, c, c + u, 1 - d), t.scale(1 / p, 1 / m), t.rotate(-h), t.translate(-r, -a)) : t.arc(r, a, f, c, c + u, 1 - d);
                            break;
                        case s.R:
                            t.rect(e[i++], e[i++], e[i++], e[i++]);
                            break;
                        case s.Z:
                            t.closePath() } } } }, y.CMD = s, y }), e("zrender/graphic/mixin/RectText", [We, "../../contain/text", "../../core/BoundingRect"], function(t) {
        function e(t, e) {
            return typeof t === Be ? t.lastIndexOf("%") >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t }

        function i(t, e) { t[Ne](e[0], e[1], e[2], e[3], e[4], e[5]) }
        var n = t("../../contain/text"),
            r = t("../../core/BoundingRect"),
            a = new r,
            o = function() {};
        return o[Ee] = { constructor: o, drawRectText: function(t, r, o) {
                var s = this.style,
                    c = s.text;
                if (null != c && (c += ""), c) {
                    var u, h, d = s.textPosition,
                        f = s.textDistance,
                        p = s[$],
                        m = s.textFont || s.font,
                        v = s.textBaseline,
                        g = s.textVerticalAlign;
                    o = o || n[U](c, m, p, v);
                    var y = this[Ne],
                        x = this.invTransform;
                    if (y && (a.copy(r), a[l](y), r = a, i(t, x)), d instanceof Array) u = r.x + e(d[0], r.width), h = r.y + e(d[1], r[Ae]), p = p || "left", v = v || "top";
                    else {
                        var _ = n.adjustTextPositionOnRect(d, r, o, f);
                        u = _.x, h = _.y, p = p || _[$], v = v || _.textBaseline }
                    if (t[$] = p, g) {
                        switch (g) {
                            case j:
                                h -= o[Ae] / 2;
                                break;
                            case ke:
                                h -= o[Ae] }
                        t.textBaseline = "top" } else t.textBaseline = v;
                    var b = s.textFill,
                        w = s.textStroke;
                    b && (t.fillStyle = b), w && (t.strokeStyle = w), t.font = m, t.shadowColor = s.textShadowColor, t.shadowBlur = s.textShadowBlur, t.shadowOffsetX = s.textShadowOffsetX, t.shadowOffsetY = s.textShadowOffsetY;
                    for (var M = c.split("\n"), S = 0; S < M[ye]; S++) b && t.fillText(M[S], u, h), w && t.strokeText(M[S], u, h), h += o.lineHeight;
                    y && i(t, y) } } }, o }), e("zrender/graphic/Displayable", [We, n, "./Style", "../Element", "./mixin/RectText"], function(t) {
        function e(t) { t = t || {}, a.call(this, t);
            for (var e in t) t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
            this.style = new r(t.style), this._rect = null, this.__clipPaths = [] }
        var i = t(n),
            r = t("./Style"),
            a = t("../Element"),
            o = t("./mixin/RectText");
        return e[Ee] = { constructor: e, type: "displayable", __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: "pointer", rectHover: !1, beforeBrush: function() {}, afterBrush: function() {}, brush: function() {}, getBoundingRect: function() {}, contain: function(t, e) {
                return this.rectContain(t, e) }, traverse: function(t, e) { t.call(e, this) }, rectContain: function(t, e) {
                var i = this.transformCoordToLocal(t, e),
                    n = this[U]();
                return n[G](i[0], i[1]) }, dirty: function() { this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh() }, animateStyle: function(t) {
                return this.animate("style", t) }, attrKV: function(t, e) { "style" !== t ? a[Ee].attrKV.call(this, t, e) : this.style.set(e) }, setStyle: function(t, e) {
                return this.style.set(t, e), this.dirty(!1), this } }, i[te](e, a), i.mixin(e, o), e }), e("zrender/vml/core", [We, "exports", "module", "../core/env"], function(t, e, i) {
        if (!t("../core/env")[Pe]) {
            var n, r = "urn:schemas-microsoft-com:vml",
                a = window,
                o = a.document,
                s = !1;
            try {!o.namespaces.zrvml && o.namespaces.add("zrvml", r), n = function(t) {
                    return o[N]("<zrvml:" + t + ' class="zrvml">') } } catch (l) { n = function(t) {
                    return o[N]("<" + t + ' xmlns="' + r + '" class="zrvml">') } }
            var c = function() {
                if (!s) { s = !0;
                    var t = o.styleSheets;
                    t[ye] < 31 ? o.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)") } };
            i.exports = { doc: o, initVML: c, createNode: n } } }), e("echarts/component/toolbox/featureManager", [We], function() {
        var t = {};
        return { register: function(e, i) { t[e] = i }, get: function(e) {
                return t[e] } } }), e("echarts/coord/axisHelper", [We, "../scale/Ordinal", "../scale/Interval", "../scale/Time", "../scale/Log", "../scale/Scale", "../util/number", He, "zrender/contain/text"], function(t) {
        var e = t("../scale/Ordinal"),
            i = t("../scale/Interval");
        t("../scale/Time"), t("../scale/Log");
        var n = t("../scale/Scale"),
            r = t("../util/number"),
            a = t(He),
            o = t("zrender/contain/text"),
            s = {};
        return s.getScaleExtent = function(t, e) {
            var i = t.scale,
                n = i[F](),
                o = n[1] - n[0];
            if (i.type === A) return isFinite(o) ? n : [0, 0];
            var s = e.getMin ? e.getMin() : e.get("min"),
                l = e.getMax ? e.getMax() : e.get("max"),
                c = e.getNeedCrossZero ? e.getNeedCrossZero() : !e.get("scale"),
                u = e.get("boundaryGap");
            a[re](u) || (u = [u || 0, u || 0]), u[0] = r[v](u[0], 1), u[1] = r[v](u[1], 1);
            var h = !0,
                d = !0;
            return null == s && (s = n[0] - u[0] * o, h = !1), null == l && (l = n[1] + u[1] * o, d = !1), "dataMin" === s && (s = n[0]), "dataMax" === l && (l = n[1]), c && (s > 0 && l > 0 && !h && (s = 0), 0 > s && 0 > l && !d && (l = 0)), [s, l] }, s.niceScaleExtent = function(t, e) {
            var i = t.scale,
                n = s.getScaleExtent(t, e),
                r = null != (e.getMin ? e.getMin() : e.get("min")),
                a = null != (e.getMax ? e.getMax() : e.get("max"));
            i.setExtent(n[0], n[1]), i.niceExtent(e.get("splitNumber"), r, a);
            var o = e.get("interval");
            null != o && i.setInterval && i.setInterval(o) }, s.createScaleByModel = function(t, r) {
            if (r = r || t.get("type")) switch (r) {
                case w:
                    return new e(t.getCategories(), [1 / 0, -1 / 0]);
                case "value":
                    return new i;
                default:
                    return (n.getClass(r) || i)[Ce](t) } }, s.ifAxisCrossZero = function(t) {
            var e = t.scale[F](),
                i = e[0],
                n = e[1];
            return !(i > 0 && n > 0 || 0 > i && 0 > n) }, s.getAxisLabelInterval = function(t, e, i, n) {
            var r, a = 0,
                s = 0,
                l = 1;
            e[ye] > 40 && (l = Math.round(e[ye] / 40));
            for (var c = 0; c < t[ye]; c += l) {
                var u = t[c],
                    h = o[U](e[c], i, q, "top");
                h[n ? "x" : "y"] += u, h[n ? "width" : Ae] *= 1.5, r ? r.intersect(h) ? (s++, a = Math.max(a, s)) : (r.union(h), s = 0) : r = h.clone() }
            return 0 === a && l > 1 ? l : a * l }, s.getFormattedLabels = function(t, e) {
            var i = t.scale,
                n = i.getTicksLabels(),
                r = i.getTicks();
            return typeof e === Be ? (e = function(t) {
                return function(e) {
                    return t[ae]("{value}", e) } }(e), a.map(n, e)) : typeof e === ie ? a.map(r, function(n, r) {
                return e(t.type === w ? i.getLabel(n) : n, r) }, this) : n }, s }), e("echarts/coord/cartesian/Cartesian2D", [We, He, "./Cartesian"], function(t) {
        function e(t) { n.call(this, t) }
        var i = t(He),
            n = t("./Cartesian");
        return e[Ee] = { constructor: e, type: "cartesian2d", dimensions: ["x", "y"], getBaseAxis: function() {
                return this.getAxesByScale(A)[0] || this.getAxesByScale("time")[0] || this[I]("x") }, containPoint: function(t) {
                var e = this[I]("x"),
                    i = this[I]("y");
                return e[G](e.toLocalCoord(t[0])) && i[G](i.toLocalCoord(t[1])) }, containData: function(t) {
                return this[I]("x").containData(t[0]) && this[I]("y").containData(t[1]) }, dataToPoints: function(t, e) {
                return t.mapArray(["x", "y"], function(t, e) {
                    return this.dataToPoint([t, e]) }, e, this) }, dataToPoint: function(t, e) {
                var i = this[I]("x"),
                    n = this[I]("y");
                return [i.toGlobalCoord(i.dataToCoord(t[0], e)), n.toGlobalCoord(n.dataToCoord(t[1], e))] }, pointToData: function(t, e) {
                var i = this[I]("x"),
                    n = this[I]("y");
                return [i.coordToData(i.toLocalCoord(t[0]), e), n.coordToData(n.toLocalCoord(t[1]), e)] }, getOtherAxis: function(t) {
                return this[I]("x" === t.dim ? "y" : "x") } }, i[te](e, n), e }), e("echarts/coord/cartesian/Axis2D", [We, He, "../Axis", "./axisLabelInterval"], function(t) {
        var e = t(He),
            i = t("../Axis"),
            n = t("./axisLabelInterval"),
            r = function(t, e, n, r, a) { i.call(this, t, e, n), this.type = r || "value", this[W] = a || ke };
        return r[Ee] = { constructor: r, index: 0, onZero: !1, model: null, isHorizontal: function() {
                var t = this[W];
                return "top" === t || t === ke }, getGlobalExtent: function() {
                var t = this[F]();
                return t[0] = this.toGlobalCoord(t[0]), t[1] = this.toGlobalCoord(t[1]), t }, getLabelInterval: function() {
                var t = this._labelInterval;
                return t || (t = this._labelInterval = n(this)), t }, isLabelIgnored: function(t) {
                if (this.type === w) {
                    var e = this.getLabelInterval();
                    return typeof e === ie && !e(t, this.scale.getLabel(t)) || t % (e + 1) } }, toLocalCoord: null, toGlobalCoord: null }, e[te](r, i), r }), e("echarts/coord/cartesian/GridModel", [We, "./AxisModel", "../../model/Component"], function(t) { t("./AxisModel");
        var e = t("../../model/Component");
        return e[be]({ type: "grid", dependencies: ["xAxis", "yAxis"], layoutMode: "box", coordinateSystem: null, defaultOption: { show: !1, zlevel: 0, z: 0, left: "10%", top: 60, right: "10%", bottom: 60, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" } }) }), e("echarts/util/clazz", [We, He], function(t) {
        function e(t, e) {
            var i = n.slice(arguments, 2);
            return this.superClass[Ee][e].apply(t, i) }

        function i(t, e, i) {
            return this.superClass[Ee][e].apply(t, i) }
        var n = t(He),
            r = {},
            a = ".",
            o = "___EC__COMPONENT__CONTAINER___",
            s = r.parseClassType = function(t) {
                var e = { main: "", sub: "" };
                return t && (t = t.split(a), e.main = t[0] || "", e.sub = t[1] || ""), e };
        return r.enableClassExtend = function(t, r) { t[be] = function(a) {
                var o = function() { r && r.apply(this, arguments), t.apply(this, arguments) };
                return n[be](o[Ee], a), o[be] = this[be], o.superCall = e, o.superApply = i, n[te](o, this), o.superClass = this, o } }, r.enableClassManagement = function(t, e) {
            function i(t) {
                var e = r[t.main];
                return e && e[o] || (e = r[t.main] = {}, e[o] = !0), e }
            e = e || {};
            var r = {};
            if (t.registerClass = function(t, e) {
                    if (e)
                        if (e = s(e), e.sub) {
                            if (e.sub !== o) {
                                var n = i(e);
                                n[e.sub] = t } } else {
                            if (r[e.main]) throw new Error(e.main + "exists.");
                            r[e.main] = t }
                    return t }, t.getClass = function(t, e, i) {
                    var n = r[t];
                    if (n && n[o] && (n = e ? n[e] : null), i && !n) throw new Error("Component " + t + "." + (e || "") + " not exists. Load it first.");
                    return n }, t.getClassesByMainType = function(t) { t = s(t);
                    var e = [],
                        i = r[t.main];
                    return i && i[o] ? n.each(i, function(t, i) { i !== o && e.push(t) }) : e.push(i), e }, t.hasClass = function(t) {
                    return t = s(t), !!r[t.main] }, t.getAllClassMainTypes = function() {
                    var t = [];
                    return n.each(r, function(e, i) { t.push(i) }), t }, t.hasSubTypes = function(t) { t = s(t);
                    var e = r[t.main];
                    return e && e[o] }, t.parseClassType = s, e.registerWhenExtend) {
                var a = t[be];
                a && (t[be] = function(e) {
                    var i = a.call(this, e);
                    return t.registerClass(i, e.type) }) }
            return t }, r.setReadOnly = function() {}, r }), e("echarts/model/mixin/lineStyle", [We, "./makeStyleMapper"], function(t) {
        var e = t("./makeStyleMapper")([
            [s, "width"],
            [o, "color"],
            [Z],
            ["shadowBlur"],
            ["shadowOffsetX"],
            ["shadowOffsetY"],
            ["shadowColor"]
        ]);
        return { getLineStyle: function(t) {
                var i = e.call(this, t),
                    n = this.getLineDash();
                return n && (i.lineDash = n), i }, getLineDash: function() {
                var t = this.get("type");
                return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1] } } }), e("echarts/model/mixin/textStyle", [We, "zrender/contain/text"], function(t) {
        function e(t, e) {
            return t && t.getShallow(e) }
        var i = t("zrender/contain/text");
        return { getTextColor: function() {
                var t = this[c];
                return this.getShallow("color") || t && t.get("textStyle.color") }, getFont: function() {
                var t = this[c],
                    i = t && t[Oe](Q);
                return [this.getShallow("fontStyle") || e(i, "fontStyle"), this.getShallow("fontWeight") || e(i, "fontWeight"), (this.getShallow("fontSize") || e(i, "fontSize") || 12) + "px", this.getShallow("fontFamily") || e(i, "fontFamily") || "sans-serif"].join(" ") }, getTextRect: function(t) {
                var e = this.get(Q) || {};
                return i[U](t, this[Y](), e.align, e.baseline) }, ellipsis: function(t, e, n) {
                return i.ellipsis(t, this[Y](), e, n) } } }), e("echarts/model/mixin/areaStyle", [We, "./makeStyleMapper"], function(t) {
        return { getAreaStyle: t("./makeStyleMapper")([
                ["fill", "color"],
                ["shadowBlur"],
                ["shadowOffsetX"],
                ["shadowOffsetY"],
                [Z],
                ["shadowColor"]
            ]) } }), e("zrender/tool/transformPath", [We, "../core/PathProxy", "../core/vector"], function(t) {
        function e(t, e) {
            var n, l, c, u, h, d, f = t.data,
                p = i.M,
                m = i.C,
                v = i.L,
                g = i.R,
                y = i.A,
                x = i.Q;
            for (c = 0, u = 0; c < f[ye];) {
                switch (n = f[c++], u = c, l = 0, n) {
                    case p:
                        l = 1;
                        break;
                    case v:
                        l = 1;
                        break;
                    case m:
                        l = 3;
                        break;
                    case x:
                        l = 2;
                        break;
                    case y:
                        var _ = e[4],
                            b = e[5],
                            w = o(e[0] * e[0] + e[1] * e[1]),
                            M = o(e[2] * e[2] + e[3] * e[3]),
                            S = s(-e[1] / M, e[0] / w);
                        f[c++] += _, f[c++] += b, f[c++] *= w, f[c++] *= M, f[c++] += S, f[c++] += S, c += 2, u = c;
                        break;
                    case g:
                        d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1], d[0] += f[c++], d[1] += f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1] }
                for (h = 0; l > h; h++) {
                    var d = a[h];
                    d[0] = f[c++], d[1] = f[c++], r(d, d, e), f[u++] = d[0], f[u++] = d[1] } } }
        var i = t("../core/PathProxy").CMD,
            n = t("../core/vector"),
            r = n[l],
            a = [
                [],
                [],
                []
            ],
            o = Math.sqrt,
            s = Math.atan2;
        return e }), e("echarts/model/mixin/itemStyle", [We, "./makeStyleMapper"], function(t) {
        return { getItemStyle: t("./makeStyleMapper")([
                ["fill", "color"],
                [o, "borderColor"],
                [s, "borderWidth"],
                [Z],
                ["shadowBlur"],
                ["shadowOffsetX"],
                ["shadowOffsetY"],
                ["shadowColor"]
            ]) } }), e("zrender/contain/path", [We, "../core/PathProxy", "./line", "./cubic", "./quadratic", "./arc", "./util", "../core/curve", "./windingLine"], function(t) {
        function e(t, e) {
            return Math.abs(t - e) < g }

        function i() {
            var t = x[0];
            x[0] = x[1], x[1] = t }

        function n(t, e, n, r, a, o, s, l, c, u) {
            if (u > e && u > r && u > o && u > l || e > u && r > u && o > u && l > u) return 0;
            var h = f.cubicRootAt(e, r, o, l, u, y);
            if (0 === h) return 0;
            for (var d, p, m = 0, v = -1, g = 0; h > g; g++) {
                var _ = y[g],
                    b = f.cubicAt(t, n, a, s, _);
                c > b || (0 > v && (v = f.cubicExtrema(e, r, o, l, x), x[1] < x[0] && v > 1 && i(), d = f.cubicAt(e, r, o, l, x[0]), v > 1 && (p = f.cubicAt(e, r, o, l, x[1]))), m += 2 == v ? _ < x[0] ? e > d ? 1 : -1 : _ < x[1] ? d > p ? 1 : -1 : p > l ? 1 : -1 : _ < x[0] ? e > d ? 1 : -1 : d > l ? 1 : -1) }
            return m }

        function r(t, e, i, n, r, a, o, s) {
            if (s > e && s > n && s > a || e > s && n > s && a > s) return 0;
            var l = f.quadraticRootAt(e, n, a, s, y);
            if (0 === l) return 0;
            var c = f.quadraticExtremum(e, n, a);
            if (c >= 0 && 1 >= c) {
                for (var u = 0, h = f.quadraticAt(e, n, a, c), d = 0; l > d; d++) {
                    var p = f.quadraticAt(t, i, r, y[d]);
                    o > p || (u += y[d] < c ? e > h ? 1 : -1 : h > a ? 1 : -1) }
                return u }
            var p = f.quadraticAt(t, i, r, y[0]);
            return o > p ? 0 : e > a ? 1 : -1 }

        function a(t, e, i, n, r, a, o, s) {
            if (s -= e, s > i || -i > s) return 0;
            var l = Math.sqrt(i * i - s * s);
            y[0] = -l, y[1] = l;
            var c = Math.abs(n - r);
            if (1e-4 > c) return 0;
            if (1e-4 > c % v) { n = 0, r = v;
                var u = a ? 1 : -1;
                return o >= y[0] + t && o <= y[1] + t ? u : 0 }
            if (a) {
                var l = n;
                n = d(r), r = d(l) } else n = d(n), r = d(r);
            n > r && (r += v);
            for (var h = 0, f = 0; 2 > f; f++) {
                var p = y[f];
                if (p + t > o) {
                    var m = Math.atan2(s, p),
                        u = a ? 1 : -1;
                    0 > m && (m = v + m), (m >= n && r >= m || m + v >= n && r >= m + v) && (m > Math.PI / 2 && m < 1.5 * Math.PI && (u = -u), h += u) } }
            return h }

        function o(t, i, o, l, d) {
            for (var f = 0, v = 0, g = 0, y = 0, x = 0, _ = 0; _ < t[ye];) {
                var b = t[_++];
                if (b === s.M && _ > 1 && (o || (f += p(v, g, y, x, l, d)), 0 !== f)) return !0;
                switch (1 == _ && (v = t[_], g = t[_ + 1], y = v, x = g), b) {
                    case s.M:
                        y = t[_++], x = t[_++], v = y, g = x;
                        break;
                    case s.L:
                        if (o) {
                            if (m(v, g, t[_], t[_ + 1], i, l, d)) return !0 } else f += p(v, g, t[_], t[_ + 1], l, d) || 0;
                        v = t[_++], g = t[_++];
                        break;
                    case s.C:
                        if (o) {
                            if (c.containStroke(v, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], i, l, d)) return !0 } else f += n(v, g, t[_++], t[_++], t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        v = t[_++], g = t[_++];
                        break;
                    case s.Q:
                        if (o) {
                            if (u.containStroke(v, g, t[_++], t[_++], t[_], t[_ + 1], i, l, d)) return !0 } else f += r(v, g, t[_++], t[_++], t[_], t[_ + 1], l, d) || 0;
                        v = t[_++], g = t[_++];
                        break;
                    case s.A:
                        var w = t[_++],
                            M = t[_++],
                            S = t[_++],
                            T = t[_++],
                            C = t[_++],
                            A = t[_++],
                            k = (t[_++], 1 - t[_++]),
                            L = Math.cos(C) * S + w,
                            z = Math.sin(C) * T + M;
                        _ > 1 ? f += p(v, g, L, z, l, d) : (y = L, x = z);
                        var P = (l - w) * T / S + w;
                        if (o) {
                            if (h.containStroke(w, M, T, C, C + A, k, i, P, d)) return !0 } else f += a(w, M, T, C, C + A, k, P, d);
                        v = Math.cos(C + A) * S + w, g = Math.sin(C + A) * T + M;
                        break;
                    case s.R:
                        y = v = t[_++], x = g = t[_++];
                        var D = t[_++],
                            I = t[_++],
                            L = y + D,
                            z = x + I;
                        if (o) {
                            if (m(y, x, L, x, i, l, d) || m(L, x, L, z, i, l, d) || m(L, z, y, z, i, l, d) || m(y, z, L, z, i, l, d)) return !0 } else f += p(L, x, L, z, l, d), f += p(y, z, y, x, l, d);
                        break;
                    case s.Z:
                        if (o) {
                            if (m(v, g, y, x, i, l, d)) return !0 } else if (f += p(v, g, y, x, l, d), 0 !== f) return !0;
                        v = y, g = x } }
            return o || e(g, x) || (f += p(v, g, y, x, l, d) || 0), 0 !== f }
        var s = t("../core/PathProxy").CMD,
            l = t("./line"),
            c = t("./cubic"),
            u = t("./quadratic"),
            h = t("./arc"),
            d = t("./util").normalizeRadian,
            f = t("../core/curve"),
            p = t("./windingLine"),
            m = l.containStroke,
            v = 2 * Math.PI,
            g = 1e-4,
            y = [-1, -1, -1],
            x = [-1, -1];
        return { contain: function(t, e, i) {
                return o(t, 0, !1, e, i) }, containStroke: function(t, e, i, n) {
                return o(t, e, !0, i, n) } } }), e("zrender/graphic/Style", [We], function() {
        var t = ["lineCap", "lineJoin", "miterLimit", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "shadowColor"],
            e = function(t) { this.extendFrom(t) };
        e[Ee] = { constructor: e, fill: "#000000", stroke: null, opacity: 1, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, textFill: "#000", textStroke: null, textPosition: "inside", textBaseline: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, bind: function(e, i) {
                for (var n = this.fill, r = this[o], a = 0; a < t[ye]; a++) {
                    var l = t[a];
                    null != this[l] && (e[l] = this[l]) }
                if (null != r) {
                    var c = this[s];
                    e[s] = c / (this.strokeNoScale && i && i.getLineScale ? i.getLineScale() : 1) }
                null != n && (e.fillStyle = n.canvasGradient ? n.canvasGradient : n), null != r && (e.strokeStyle = r.canvasGradient ? r.canvasGradient : r), null != this[Z] && (e.globalAlpha = this[Z]) }, extendFrom: function(t, e) {
                if (t) {
                    var i = this;
                    for (var n in t) !t.hasOwnProperty(n) || !e && i.hasOwnProperty(n) || (i[n] = t[n]) } }, set: function(t, e) { typeof t === Be ? this[t] = e : this.extendFrom(t, !0) }, clone: function() {
                var t = new this.constructor;
                return t.extendFrom(this, !0), t } };
        var i, n, r = e[Ee];
        for (n = 0; n < t[ye]; n++) i = t[n], i in r || (r[i] = null);
        return e }), e("zrender/core/curve", [We, "./vector"], function(t) {
        function e(t) {
            return t > -_ && _ > t }

        function i(t) {
            return t > _ || -_ > t }

        function n(t, e, i, n, r) {
            var a = 1 - r;
            return a * a * (a * t + 3 * r * e) + r * r * (r * n + 3 * a * i) }

        function r(t, e, i, n, r) {
            var a = 1 - r;
            return 3 * (((e - t) * a + 2 * (i - e) * r) * a + (n - i) * r * r) }

        function a(t, i, n, r, a, o) {
            var s = r + 3 * (i - n) - t,
                l = 3 * (n - 2 * i + t),
                c = 3 * (i - t),
                u = t - a,
                h = l * l - 3 * s * c,
                d = l * c - 9 * s * u,
                f = c * c - 3 * l * u,
                p = 0;
            if (e(h) && e(d))
                if (e(l)) o[0] = 0;
                else {
                    var m = -c / l;
                    m >= 0 && 1 >= m && (o[p++] = m) }
            else {
                var v = d * d - 4 * h * f;
                if (e(v)) {
                    var g = d / h,
                        m = -l / s + g,
                        _ = -g / 2;
                    m >= 0 && 1 >= m && (o[p++] = m), _ >= 0 && 1 >= _ && (o[p++] = _) } else if (v > 0) {
                    var b = x(v),
                        S = h * l + 1.5 * s * (-d + b),
                        T = h * l + 1.5 * s * (-d - b);
                    S = 0 > S ? -y(-S, M) : y(S, M), T = 0 > T ? -y(-T, M) : y(T, M);
                    var m = (-l - (S + T)) / (3 * s);
                    m >= 0 && 1 >= m && (o[p++] = m) } else {
                    var C = (2 * h * l - 3 * s * d) / (2 * x(h * h * h)),
                        A = Math.acos(C) / 3,
                        k = x(h),
                        L = Math.cos(A),
                        m = (-l - 2 * k * L) / (3 * s),
                        _ = (-l + k * (L + w * Math.sin(A))) / (3 * s),
                        z = (-l + k * (L - w * Math.sin(A))) / (3 * s);
                    m >= 0 && 1 >= m && (o[p++] = m), _ >= 0 && 1 >= _ && (o[p++] = _), z >= 0 && 1 >= z && (o[p++] = z) } }
            return p }

        function o(t, n, r, a, o) {
            var s = 6 * r - 12 * n + 6 * t,
                l = 9 * n + 3 * a - 3 * t - 9 * r,
                c = 3 * n - 3 * t,
                u = 0;
            if (e(l)) {
                if (i(s)) {
                    var h = -c / s;
                    h >= 0 && 1 >= h && (o[u++] = h) } } else {
                var d = s * s - 4 * l * c;
                if (e(d)) o[0] = -s / (2 * l);
                else if (d > 0) {
                    var f = x(d),
                        h = (-s + f) / (2 * l),
                        p = (-s - f) / (2 * l);
                    h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p) } }
            return u }

        function s(t, e, i, n, r, a) {
            var o = (e - t) * r + t,
                s = (i - e) * r + e,
                l = (n - i) * r + i,
                c = (s - o) * r + o,
                u = (l - s) * r + s,
                h = (u - c) * r + c;
            a[0] = t, a[1] = o, a[2] = c, a[3] = h, a[4] = h, a[5] = u, a[6] = l, a[7] = n }

        function l(t, e, i, r, a, o, s, l, c, u, h) {
            var d, f, p, m, v, y = .005,
                _ = 1 / 0;
            S[0] = c, S[1] = u;
            for (var w = 0; 1 > w; w += .05) T[0] = n(t, i, a, s, w), T[1] = n(e, r, o, l, w), m = g(S, T), _ > m && (d = w, _ = m);
            _ = 1 / 0;
            for (var M = 0; 32 > M && !(b > y); M++) f = d - y, p = d + y, T[0] = n(t, i, a, s, f), T[1] = n(e, r, o, l, f), m = g(T, S), f >= 0 && _ > m ? (d = f, _ = m) : (C[0] = n(t, i, a, s, p), C[1] = n(e, r, o, l, p), v = g(C, S), 1 >= p && _ > v ? (d = p, _ = v) : y *= .5);
            return h && (h[0] = n(t, i, a, s, d), h[1] = n(e, r, o, l, d)), x(_) }

        function c(t, e, i, n) {
            var r = 1 - n;
            return r * (r * t + 2 * n * e) + n * n * i }

        function u(t, e, i, n) {
            return 2 * ((1 - n) * (e - t) + n * (i - e)) }

        function h(t, n, r, a, o) {
            var s = t - 2 * n + r,
                l = 2 * (n - t),
                c = t - a,
                u = 0;
            if (e(s)) {
                if (i(l)) {
                    var h = -c / l;
                    h >= 0 && 1 >= h && (o[u++] = h) } } else {
                var d = l * l - 4 * s * c;
                if (e(d)) {
                    var h = -l / (2 * s);
                    h >= 0 && 1 >= h && (o[u++] = h) } else if (d > 0) {
                    var f = x(d),
                        h = (-l + f) / (2 * s),
                        p = (-l - f) / (2 * s);
                    h >= 0 && 1 >= h && (o[u++] = h), p >= 0 && 1 >= p && (o[u++] = p) } }
            return u }

        function d(t, e, i) {
            var n = t + i - 2 * e;
            return 0 === n ? .5 : (t - e) / n }

        function f(t, e, i, n, r) {
            var a = (e - t) * n + t,
                o = (i - e) * n + e,
                s = (o - a) * n + a;
            r[0] = t, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i }

        function p(t, e, i, n, r, a, o, s, l) {
            var u, h = .005,
                d = 1 / 0;
            S[0] = o, S[1] = s;
            for (var f = 0; 1 > f; f += .05) { T[0] = c(t, i, r, f), T[1] = c(e, n, a, f);
                var p = g(S, T);
                d > p && (u = f, d = p) }
            d = 1 / 0;
            for (var m = 0; 32 > m && !(b > h); m++) {
                var v = u - h,
                    y = u + h;
                T[0] = c(t, i, r, v), T[1] = c(e, n, a, v);
                var p = g(T, S);
                if (v >= 0 && d > p) u = v, d = p;
                else { C[0] = c(t, i, r, y), C[1] = c(e, n, a, y);
                    var _ = g(C, S);
                    1 >= y && d > _ ? (u = y, d = _) : h *= .5 } }
            return l && (l[0] = c(t, i, r, u), l[1] = c(e, n, a, u)), x(d) }
        var m = t("./vector"),
            v = m[Ce],
            g = m.distSquare,
            y = Math.pow,
            x = Math.sqrt,
            _ = 1e-8,
            b = 1e-4,
            w = x(3),
            M = 1 / 3,
            S = v(),
            T = v(),
            C = v();
        return { cubicAt: n, cubicDerivativeAt: r, cubicRootAt: a, cubicExtrema: o, cubicSubdivide: s, cubicProjectPoint: l, quadraticAt: c, quadraticDerivativeAt: u, quadraticRootAt: h, quadraticExtremum: d, quadraticSubdivide: f, quadraticProjectPoint: p } }), e("zrender/core/bbox", [We, "./vector", "./curve"], function(t) {
        var e = t("./vector"),
            i = t("./curve"),
            n = {},
            r = Math.min,
            a = Math.max,
            o = Math.sin,
            s = Math.cos,
            l = e[Ce](),
            c = e[Ce](),
            u = e[Ce](),
            h = 2 * Math.PI;
        n.fromPoints = function(t, e, i) {
            if (0 !== t[ye]) {
                var n, o = t[0],
                    s = o[0],
                    l = o[0],
                    c = o[1],
                    u = o[1];
                for (n = 1; n < t[ye]; n++) o = t[n], s = r(s, o[0]), l = a(l, o[0]), c = r(c, o[1]), u = a(u, o[1]);
                e[0] = s, e[1] = c, i[0] = l, i[1] = u } }, n.fromLine = function(t, e, i, n, o, s) { o[0] = r(t, i), o[1] = r(e, n), s[0] = a(t, i), s[1] = a(e, n) };
        var d = [],
            f = [];
        return n.fromCubic = function(t, e, n, o, s, l, c, u, h, p) {
            var m, v = i.cubicExtrema,
                g = i.cubicAt,
                y = v(t, n, s, c, d);
            for (h[0] = 1 / 0, h[1] = 1 / 0, p[0] = -1 / 0, p[1] = -1 / 0, m = 0; y > m; m++) {
                var x = g(t, n, s, c, d[m]);
                h[0] = r(x, h[0]), p[0] = a(x, p[0]) }
            for (y = v(e, o, l, u, f), m = 0; y > m; m++) {
                var _ = g(e, o, l, u, f[m]);
                h[1] = r(_, h[1]), p[1] = a(_, p[1]) }
            h[0] = r(t, h[0]), p[0] = a(t, p[0]), h[0] = r(c, h[0]), p[0] = a(c, p[0]), h[1] = r(e, h[1]), p[1] = a(e, p[1]), h[1] = r(u, h[1]), p[1] = a(u, p[1]) }, n.fromQuadratic = function(t, e, n, o, s, l, c, u) {
            var h = i.quadraticExtremum,
                d = i.quadraticAt,
                f = a(r(h(t, n, s), 1), 0),
                p = a(r(h(e, o, l), 1), 0),
                m = d(t, n, s, f),
                v = d(e, o, l, p);
            c[0] = r(t, s, m), c[1] = r(e, l, v), u[0] = a(t, s, m), u[1] = a(e, l, v) }, n.fromArc = function(t, i, n, r, a, d, f, p, m) {
            var v = e.min,
                g = e.max,
                y = Math.abs(a - d);
            if (1e-4 > y % h && y > 1e-4) return p[0] = t - n, p[1] = i - r, m[0] = t + n, void(m[1] = i + r);
            if (l[0] = s(a) * n + t, l[1] = o(a) * r + i, c[0] = s(d) * n + t, c[1] = o(d) * r + i, v(p, l, c), g(m, l, c), a %= h, 0 > a && (a += h), d %= h, 0 > d && (d += h), a > d && !f ? d += h : d > a && f && (a += h), f) {
                var x = d;
                d = a, a = x }
            for (var _ = 0; d > _; _ += Math.PI / 2) _ > a && (u[0] = s(_) * n + t, u[1] = o(_) * r + i, v(p, u, p), g(m, u, m)) }, n }), e("zrender/Element", [We, "./core/guid", "./mixin/Eventful", "./mixin/Transformable", "./mixin/Animatable", "./core/util"], function(t) {
        var e = t("./core/guid"),
            i = t("./mixin/Eventful"),
            n = t("./mixin/Transformable"),
            r = t("./mixin/Animatable"),
            a = t("./core/util"),
            o = function(t) { n.call(this, t), i.call(this, t), r.call(this, t), this.id = t.id || e() };
        return o[Ee] = { type: "element", name: "", __zr: null, ignore: !1, clipPath: null, drift: function(t, e) {
                switch (this.draggable) {
                    case "horizontal":
                        e = 0;
                        break;
                    case "vertical":
                        t = 0 }
                var i = this[Ne];
                i || (i = this[Ne] = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.dirty() }, beforeUpdate: function() {}, afterUpdate: function() {}, update: function() { this.updateTransform() }, traverse: function() {}, attrKV: function(t, e) {
                if (t === W || "scale" === t || "origin" === t) {
                    if (e) {
                        var i = this[t];
                        i || (i = this[t] = []), i[0] = e[0], i[1] = e[1] } } else this[t] = e }, hide: function() { this[Le] = !0, this.__zr && this.__zr.refresh() }, show: function() { this[Le] = !1, this.__zr && this.__zr.refresh() }, attr: function(t, e) {
                if (typeof t === Be) this.attrKV(t, e);
                else if (a[Me](t))
                    for (var i in t) t.hasOwnProperty(i) && this.attrKV(i, t[i]);
                return this.dirty(), this }, setClipPath: function(t) {
                var e = this.__zr;
                e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty() }, removeClipPath: function() {
                var t = this.clipPath;
                t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty()) }, addSelfToZr: function(t) { this.__zr = t;
                var e = this.animators;
                if (e)
                    for (var i = 0; i < e[ye]; i++) t[P].addAnimator(e[i]);
                this.clipPath && this.clipPath.addSelfToZr(t) }, removeSelfFromZr: function(t) { this.__zr = null;
                var e = this.animators;
                if (e)
                    for (var i = 0; i < e[ye]; i++) t[P].removeAnimator(e[i]);
                this.clipPath && this.clipPath.removeSelfFromZr(t) } }, a.mixin(o, r), a.mixin(o, n), a.mixin(o, i), o }), e("echarts/scale/Ordinal", [We, He, "./Scale"], function(t) {
        var e = t(He),
            i = t("./Scale"),
            n = i[Ee],
            r = i[be]({ type: "ordinal", init: function(t, e) { this._data = t, this._extent = e || [0, t[ye] - 1] }, parse: function(t) {
                    return typeof t === Be ? e[ne](this._data, t) : Math.round(t) }, contain: function(t) {
                    return t = this.parse(t), n[G].call(this, t) && null != this._data[t] }, normalize: function(t) {
                    return n.normalize.call(this, this.parse(t)) }, scale: function(t) {
                    return Math.round(n.scale.call(this, t)) }, getTicks: function() {
                    for (var t = [], e = this._extent, i = e[0]; i <= e[1];) t.push(i), i++;
                    return t }, getLabel: function(t) {
                    return this._data[t] }, count: function() {
                    return this._extent[1] - this._extent[0] + 1 }, niceTicks: e.noop, niceExtent: e.noop });
        return r[Ce] = function() {
            return new r }, r }), e("echarts/model/mixin/makeStyleMapper", [We, He], function(t) {
        var e = t(He);
        return function(t) {
            for (var i = 0; i < t[ye]; i++) t[i][1] || (t[i][1] = t[i][0]);
            return function(i) {
                for (var n = {}, r = 0; r < t[ye]; r++) {
                    var a = t[r][1];
                    if (!(i && e[ne](i, a) >= 0)) {
                        var o = this.getShallow(a);
                        null != o && (n[t[r][0]] = o) } }
                return n } } }), e("zrender/core/guid", [], function() {
        var t = 2311;
        return function() {
            return "zr_" + t++ } }), e("zrender/mixin/Transformable", [We, "../core/matrix", "../core/vector"], function(t) {
        function e(t) {
            return t > o || -o > t }
        var i = t("../core/matrix"),
            n = t("../core/vector"),
            r = i.identity,
            o = 5e-5,
            s = function(t) { t = t || {}, t[W] || (this[W] = [0, 0]), null == t[d] && (this[d] = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null },
            c = s[Ee];
        c[Ne] = null, c.needLocalTransform = function() {
            return e(this[d]) || e(this[W][0]) || e(this[W][1]) || e(this.scale[0] - 1) || e(this.scale[1] - 1) }, c.updateTransform = function() {
            var t = this[a],
                e = t && t[Ne],
                n = this.needLocalTransform(),
                o = this[Ne];
            return n || e ? (o = o || i[Ce](), n ? this.getLocalTransform(o) : r(o), e && (n ? i.mul(o, t[Ne], o) : i.copy(o, t[Ne])), this[Ne] = o, this.invTransform = this.invTransform || i[Ce](), void i.invert(this.invTransform, o)) : void(o && r(o)) }, c.getLocalTransform = function(t) { t = t || [], r(t);
            var e = this.origin,
                n = this.scale,
                a = this[d],
                o = this[W];
            return e && (t[4] -= e[0], t[5] -= e[1]), i.scale(t, t, n), a && i.rotate(t, t, a), e && (t[4] += e[0], t[5] += e[1]), t[4] += o[0], t[5] += o[1], t }, c.setTransform = function(t) {
            var e = this[Ne];
            e && t[Ne](e[0], e[1], e[2], e[3], e[4], e[5]) };
        var u = [];
        return c.decomposeTransform = function() {
            if (this[Ne]) {
                var t = this[a],
                    n = this[Ne];
                t && t[Ne] && (i.mul(u, t.invTransform, n), n = u);
                var r = n[0] * n[0] + n[1] * n[1],
                    o = n[2] * n[2] + n[3] * n[3],
                    s = this[W],
                    l = this.scale;
                e(r - 1) && (r = Math.sqrt(r)), e(o - 1) && (o = Math.sqrt(o)), n[0] < 0 && (r = -r), n[3] < 0 && (o = -o), s[0] = n[4], s[1] = n[5], l[0] = r, l[1] = o, this[d] = Math.atan2(-n[1] / o, n[0] / r) } }, c.transformCoordToLocal = function(t, e) {
            var i = [t, e],
                r = this.invTransform;
            return r && n[l](i, i, r), i }, c.transformCoordToGlobal = function(t, e) {
            var i = [t, e],
                r = this[Ne];
            return r && n[l](i, i, r), i }, s }), e("zrender/mixin/Animatable", [We, "../animation/Animator", n, "../core/log"], function(t) {
        var e = t("../animation/Animator"),
            i = t(n),
            r = i.isString,
            a = i.isFunction,
            o = i[Me],
            s = t("../core/log"),
            l = function() { this.animators = [] };
        return l[Ee] = {
            constructor: l,
            animate: function(t, n) {
                var r, a = !1,
                    o = this,
                    l = this.__zr;
                if (t) {
                    var c = t.split("."),
                        u = o;
                    a = "shape" === c[0];
                    for (var h = 0, d = c[ye]; d > h; h++) u && (u = u[c[h]]);
                    u && (r = u) } else r = o;
                if (!r) return void s('Property "' + t + '" is not existed in element ' + o.id);
                var f = o.animators,
                    p = new e(r, n);
                return p.during(function() { o.dirty(a) }).done(function() { f[pe](i[ne](f, p), 1) }), f.push(p), l && l[P].addAnimator(p), p
            },
            stopAnimation: function(t) {
                for (var e = this.animators, i = e[ye], n = 0; i > n; n++) e[n].stop(t);
                return e[ye] = 0, this },
            animateTo: function(t, e, i, n, o) {
                function s() { c--, c || o && o() }
                r(i) ? (o = n, n = i, i = 0) : a(n) ? (o = n, n = "linear", i = 0) : a(i) ? (o = i, i = 0) : a(e) ? (o = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow("", this, t, e, i, n, o);
                var l = this.animators.slice(),
                    c = l[ye];
                c || o && o();
                for (var u = 0; u < l[ye]; u++) l[u].done(s).start(n) },
            _animateToShallow: function(t, e, n, r, a) {
                var s = {},
                    l = 0;
                for (var c in n)
                    if (null != e[c]) o(n[c]) && !i.isArrayLike(n[c]) ? this._animateToShallow(t ? t + "." + c : c, e[c], n[c], r, a) : (s[c] = n[c], l++);
                    else if (null != n[c])
                    if (t) {
                        var u = {};
                        u[t] = {}, u[t][c] = n[c], this.attr(u) } else this.attr(c, n[c]);
                return l > 0 && this.animate(t, !1).when(null == r ? 500 : r, s).delay(a || 0), this }
        }, l
    }), e("echarts/util/component", [We, He, "./clazz"], function(t) {
        var e = t(He),
            i = t("./clazz"),
            n = i.parseClassType,
            r = 0,
            a = {},
            o = "_";
        return a.getUID = function(t) {
            return [t || "", r++, Math.random()].join(o) }, a.enableSubTypeDefaulter = function(t) {
            var e = {};
            return t.registerSubTypeDefaulter = function(t, i) { t = n(t), e[t.main] = i }, t.determineSubType = function(i, r) {
                var a = r.type;
                if (!a) {
                    var o = n(i).main;
                    t.hasSubTypes(i) && e[o] && (a = e[o](r)) }
                return a }, t }, a.enableTopologicalTravel = function(t, i) {
            function n(t) {
                var n = {},
                    o = [];
                return e.each(t, function(s) {
                    var l = r(n, s),
                        c = l.originalDeps = i(s),
                        u = a(c, t);
                    l.entryCount = u[ye], 0 === l.entryCount && o.push(s), e.each(u, function(t) { e[ne](l.predecessor, t) < 0 && l.predecessor.push(t);
                        var i = r(n, t);
                        e[ne](i.successor, t) < 0 && i.successor.push(s) }) }), { graph: n, noEntryList: o } }

            function r(t, e) {
                return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e] }

            function a(t, i) {
                var n = [];
                return e.each(t, function(t) { e[ne](i, t) >= 0 && n.push(t) }), n }
            t.topologicalTravel = function(t, i, r, a) {
                function o(t) { c[t].entryCount--, 0 === c[t].entryCount && u.push(t) }

                function s(t) { h[t] = !0, o(t) }
                if (t[ye]) {
                    var l = n(i),
                        c = l.graph,
                        u = l.noEntryList,
                        h = {};
                    for (e.each(t, function(t) { h[t] = !0 }); u[ye];) {
                        var d = u.pop(),
                            f = c[d],
                            p = !!h[d];
                        p && (r.call(a, d, f.originalDeps.slice()), delete h[d]), e.each(f.successor, p ? s : o) }
                    e.each(h, function() {
                        throw new Error("Circle dependency may exists") }) } } }, a }), e("echarts/model/mixin/boxLayout", [We], function() {
        return { getBoxLayoutParams: function() {
                return { left: this.get("left"), top: this.get("top"), right: this.get("right"), bottom: this.get(ke), width: this.get("width"), height: this.get(Ae) } } } }), e("echarts/coord/cartesian/Cartesian", [We, He], function(t) {
        function e(t) {
            return this._axes[t] }
        var i = t(He),
            n = function(t) { this._axes = {}, this._dimList = [], this.name = t || "" };
        return n[Ee] = { constructor: n, type: "cartesian", getAxis: function(t) {
                return this._axes[t] }, getAxes: function() {
                return i.map(this._dimList, e, this) }, getAxesByScale: function(t) {
                return t = t[Ve](), i[Ge](this.getAxes(), function(e) {
                    return e.scale.type === t }) }, addAxis: function(t) {
                var e = t.dim;
                this._axes[e] = t, this._dimList.push(e) }, dataToCoord: function(t) {
                return this._dataCoordConvert(t, "dataToCoord") }, coordToData: function(t) {
                return this._dataCoordConvert(t, "coordToData") }, _dataCoordConvert: function(t, e) {
                for (var i = this._dimList, n = t instanceof Array ? [] : {}, r = 0; r < i[ye]; r++) {
                    var a = i[r],
                        o = this._axes[a];
                    n[a] = o[e](t[a]) }
                return n } }, n }), e("zrender/animation/Animator", [We, "./Clip", "../tool/color", n], function(t) {
        function e(t, e) {
            return t[e] }

        function i(t, e, i) { t[e] = i }

        function r(t, e, i) {
            return (e - t) * i + t }

        function a(t, e, i) {
            return i > .5 ? e : t }

        function o(t, e, i, n, a) {
            var o = t[ye];
            if (1 == a)
                for (var s = 0; o > s; s++) n[s] = r(t[s], e[s], i);
            else
                for (var l = t[0][ye], s = 0; o > s; s++)
                    for (var c = 0; l > c; c++) n[s][c] = r(t[s][c], e[s][c], i) }

        function s(t, e, i) {
            var n = t[ye],
                r = e[ye];
            if (n !== r) {
                var a = n > r;
                if (a) t[ye] = r;
                else
                    for (var o = n; r > o; o++) t.push(1 === i ? e[o] : y.call(e[o])) } }

        function l(t, e, i) {
            if (t === e) return !0;
            var n = t[ye];
            if (n !== e[ye]) return !1;
            if (1 === i) {
                for (var r = 0; n > r; r++)
                    if (t[r] !== e[r]) return !1 } else
                for (var a = t[0][ye], r = 0; n > r; r++)
                    for (var o = 0; a > o; o++)
                        if (t[r][o] !== e[r][o]) return !1; return !0 }

        function c(t, e, i, n, r, a, o, s, l) {
            var c = t[ye];
            if (1 == l)
                for (var h = 0; c > h; h++) s[h] = u(t[h], e[h], i[h], n[h], r, a, o);
            else
                for (var d = t[0][ye], h = 0; c > h; h++)
                    for (var f = 0; d > f; f++) s[h][f] = u(t[h][f], e[h][f], i[h][f], n[h][f], r, a, o) }

        function u(t, e, i, n, r, a, o) {
            var s = .5 * (i - t),
                l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e }

        function h(t) {
            if (g(t)) {
                var e = t[ye];
                if (g(t[0])) {
                    for (var i = [], n = 0; e > n; n++) i.push(y.call(t[n]));
                    return i }
                return y.call(t) }
            return t }

        function d(t) {
            return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), "rgba(" + t.join(",") + ")" }

        function f(t, e, i, n, h) {
            var f = t._getter,
                v = t._setter,
                y = "spline" === e,
                x = n[ye];
            if (x) {
                var _, b = n[0].value,
                    w = g(b),
                    M = !1,
                    S = !1,
                    T = w && g(b[0]) ? 2 : 1;
                n.sort(function(t, e) {
                    return t.time - e.time }), _ = n[x - 1].time;
                for (var C = [], A = [], k = n[0].value, L = !0, z = 0; x > z; z++) { C.push(n[z].time / _);
                    var P = n[z].value;
                    if (w && l(P, k, T) || !w && P === k || (L = !1), k = P, typeof P == Be) {
                        var D = m.parse(P);
                        D ? (P = D, M = !0) : S = !0 }
                    A.push(P) }
                if (!L) {
                    if (w) {
                        for (var I = A[x - 1], z = 0; x - 1 > z; z++) s(A[z], I, T);
                        s(f(t._target, h), I, T) }
                    var O, R, B, E, V, N, F = 0,
                        G = 0;
                    if (M) var Z = [0, 0, 0, 0];
                    var H = function(t, e) {
                            var i;
                            if (G > e) {
                                for (O = Math.min(F + 1, x - 1), i = O; i >= 0 && !(C[i] <= e); i--);
                                i = Math.min(i, x - 2) } else {
                                for (i = F; x > i && !(C[i] > e); i++);
                                i = Math.min(i - 1, x - 2) }
                            F = i, G = e;
                            var n = C[i + 1] - C[i];
                            if (0 !== n)
                                if (R = (e - C[i]) / n, y)
                                    if (E = A[i], B = A[0 === i ? i : i - 1], V = A[i > x - 2 ? x - 1 : i + 1], N = A[i > x - 3 ? x - 1 : i + 2], w) c(B, E, V, N, R, R * R, R * R * R, f(t, h), T);
                                    else {
                                        var s;
                                        if (M) s = c(B, E, V, N, R, R * R, R * R * R, Z, 1), s = d(Z);
                                        else {
                                            if (S) return a(E, V, R);
                                            s = u(B, E, V, N, R, R * R, R * R * R) }
                                        v(t, h, s) }
                            else if (w) o(A[i], A[i + 1], R, f(t, h), T);
                            else {
                                var s;
                                if (M) o(A[i], A[i + 1], R, Z, 1), s = d(Z);
                                else {
                                    if (S) return a(A[i], A[i + 1], R);
                                    s = r(A[i], A[i + 1], R) }
                                v(t, h, s) } },
                        W = new p({ target: t._target, life: _, loop: t._loop, delay: t._delay, onframe: H, ondestroy: i });
                    return e && "spline" !== e && (W.easing = e), W } } }
        var p = t("./Clip"),
            m = t("../tool/color"),
            v = t(n),
            g = v.isArrayLike,
            y = Array[Ee].slice,
            x = function(t, n, r, a) { this._tracks = {}, this._target = t, this._loop = n || !1, this._getter = r || e, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [] };
        return x[Ee] = { when: function(t, e) {
                var i = this._tracks;
                for (var n in e) {
                    if (!i[n]) { i[n] = [];
                        var r = this._getter(this._target, n);
                        if (null == r) continue;
                        0 !== t && i[n].push({ time: 0, value: h(r) }) }
                    i[n].push({ time: t, value: e[n] }) }
                return this }, during: function(t) {
                return this._onframeList.push(t), this }, _doneCallback: function() { this._tracks = {}, this._clipList[ye] = 0;
                for (var t = this._doneList, e = t[ye], i = 0; e > i; i++) t[i].call(this) }, start: function(t) {
                var e, i = this,
                    n = 0,
                    r = function() { n--, n || i._doneCallback() };
                for (var a in this._tracks) {
                    var o = f(this, t, r, this._tracks[a], a);
                    o && (this._clipList.push(o), n++, this[P] && this[P].addClip(o), e = o) }
                if (e) {
                    var s = e.onframe;
                    e.onframe = function(t, e) { s(t, e);
                        for (var n = 0; n < i._onframeList[ye]; n++) i._onframeList[n](t, e) } }
                return n || this._doneCallback(), this }, stop: function(t) {
                for (var e = this._clipList, i = this[P], n = 0; n < e[ye]; n++) {
                    var r = e[n];
                    t && r.onframe(this._target, 1), i && i.removeClip(r) }
                e[ye] = 0 }, delay: function(t) {
                return this._delay = t, this }, done: function(t) {
                return t && this._doneList.push(t), this }, getClips: function() {
                return this._clipList } }, x }), e("zrender/core/log", [We, "../config"], function(t) {
        var e = t("../config");
        return function() {
            if (0 !== e.debugMode)
                if (1 == e.debugMode)
                    for (var t in arguments) throw new Error(arguments[t]);
                else if (e.debugMode > 1)
                for (var t in arguments) console.log(arguments[t]) } }), e("echarts/coord/Axis", [We, "../util/number", He], function(t) {
        function e(t, e) {
            var i = t[1] - t[0],
                n = e,
                r = i / n / 2;
            t[0] += r, t[1] -= r }
        var i = t("../util/number"),
            n = i.linearMap,
            r = t(He),
            a = [0, 1],
            o = function(t, e, i) { this.dim = t, this.scale = e, this._extent = i || [0, 0], this.inverse = !1, this.onBand = !1 };
        return o[Ee] = { constructor: o, contain: function(t) {
                var e = this._extent,
                    i = Math.min(e[0], e[1]),
                    n = Math.max(e[0], e[1]);
                return t >= i && n >= t }, containData: function(t) {
                return this[G](this.dataToCoord(t)) }, getExtent: function() {
                var t = this._extent.slice();
                return t }, getPixelPrecision: function(t) {
                return i.getPixelPrecision(t || this.scale[F](), this._extent) }, setExtent: function(t, e) {
                var i = this._extent;
                i[0] = t, i[1] = e }, dataToCoord: function(t, i) {
                var r = this._extent,
                    o = this.scale;
                return t = o.normalize(t), this.onBand && o.type === A && (r = r.slice(), e(r, o.count())), n(t, a, r, i) }, coordToData: function(t, i) {
                var r = this._extent,
                    o = this.scale;
                this.onBand && o.type === A && (r = r.slice(), e(r, o.count()));
                var s = n(t, r, a, i);
                return this.scale.scale(s) }, getTicksCoords: function() {
                if (this.onBand) {
                    for (var t = this.getBands(), e = [], i = 0; i < t[ye]; i++) e.push(t[i][0]);
                    return t[i - 1] && e.push(t[i - 1][1]), e }
                return r.map(this.scale.getTicks(), this.dataToCoord, this) }, getLabelsCoords: function() {
                if (this.onBand) {
                    for (var t, e = this.getBands(), i = [], n = 0; n < e[ye]; n++) t = e[n], i.push((t[0] + t[1]) / 2);
                    return i }
                return r.map(this.scale.getTicks(), this.dataToCoord, this) }, getBands: function() {
                for (var t = this[F](), e = [], i = this.scale.count(), n = t[0], r = t[1], a = r - n, o = 0; i > o; o++) e.push([a * o / i + n, a * (o + 1) / i + n]);
                return e }, getBandWidth: function() {
                var t = this._extent,
                    e = this.scale[F](),
                    i = e[1] - e[0] + (this.onBand ? 1 : 0);
                0 === i && (i = 1);
                var n = Math.abs(t[1] - t[0]);
                return Math.abs(n) / i } }, o }), e("echarts/coord/cartesian/axisLabelInterval", [We, He, "../axisHelper"], function(t) {
        var e = t(He),
            i = t("../axisHelper");
        return function(t) {
            var n = t.model,
                r = n[Oe]("axisLabel"),
                a = r.get("interval");
            return t.type !== w || "auto" !== a ? "auto" === a ? 0 : a : i.getAxisLabelInterval(e.map(t.scale.getTicks(), t.dataToCoord, t), n.getFormattedLabels(), r[Oe](Q)[Y](), t.isHorizontal()) } }), e("zrender/animation/Clip", [We, "./easing"], function(t) {
        function e(t) { this._target = t[he], this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = null == t.loop ? !1 : t.loop, this.gap = t.gap || 0, this.easing = t.easing || "Linear", this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart }
        var i = t("./easing");
        return e[Ee] = { constructor: e, step: function(t) { this._initialized || (this._startTime = (new Date).getTime() + this._delay, this._initialized = !0);
                var e = (t - this._startTime) / this._life;
                if (!(0 > e)) { e = Math.min(e, 1);
                    var n = this.easing,
                        r = typeof n == Be ? i[n] : n,
                        a = typeof r === ie ? r(e) : e;
                    return this.fire("frame", a), 1 == e ? this.loop ? (this.restart(), "restart") : (this._needsRemove = !0, "destroy") : null } }, restart: function() {
                var t = (new Date).getTime(),
                    e = (t - this._startTime) % this._life;
                this._startTime = (new Date).getTime() - e + this.gap, this._needsRemove = !1 }, fire: function(t, e) { t = "on" + t, this[t] && this[t](this._target, e) } }, e }), e("echarts/coord/cartesian/AxisModel", [We, "../../model/Component", He, "../axisModelCreator", "../axisModelCommonMixin"], function(t) {
        function e(t, e) {
            return e.type || (e.data ? w : "value") }
        var i = t("../../model/Component"),
            n = t(He),
            r = t("../axisModelCreator"),
            a = i[be]({ type: "cartesian2dAxis", axis: null, init: function() { a.superApply(this, "init", arguments), this._resetRange() }, mergeOption: function() { a.superApply(this, "mergeOption", arguments), this._resetRange() }, restoreData: function() { a.superApply(this, "restoreData", arguments), this._resetRange() }, setRange: function(t, e) { this[u].rangeStart = t, this[u].rangeEnd = e }, getMin: function() {
                    var t = this[u];
                    return null != t.rangeStart ? t.rangeStart : t.min }, getMax: function() {
                    var t = this[u];
                    return null != t.rangeEnd ? t.rangeEnd : t.max }, getNeedCrossZero: function() {
                    var t = this[u];
                    return null != t.rangeStart || null != t.rangeEnd ? !1 : !t.scale }, _resetRange: function() { this[u].rangeStart = this[u].rangeEnd = null } });
        n.merge(a[Ee], t("../axisModelCommonMixin"));
        var o = { gridIndex: 0 };
        return r("x", a, e, o), r("y", a, e, o), a }), e("zrender/animation/easing", [], function() {
        var t = { linear: function(t) {
                return t }, quadraticIn: function(t) {
                return t * t }, quadraticOut: function(t) {
                return t * (2 - t) }, quadraticInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) }, cubicIn: function(t) {
                return t * t * t }, cubicOut: function(t) {
                return --t * t * t + 1 }, cubicInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) }, quarticIn: function(t) {
                return t * t * t * t }, quarticOut: function(t) {
                return 1 - --t * t * t * t }, quarticInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) }, quinticIn: function(t) {
                return t * t * t * t * t }, quinticOut: function(t) {
                return --t * t * t * t * t + 1 }, quinticInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) }, sinusoidalIn: function(t) {
                return 1 - Math.cos(t * Math.PI / 2) }, sinusoidalOut: function(t) {
                return Math.sin(t * Math.PI / 2) }, sinusoidalInOut: function(t) {
                return .5 * (1 - Math.cos(Math.PI * t)) }, exponentialIn: function(t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1) }, exponentialOut: function(t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, exponentialInOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (-Math.pow(2, -10 * (t - 1)) + 2) }, circularIn: function(t) {
                return 1 - Math.sqrt(1 - t * t) }, circularOut: function(t) {
                return Math.sqrt(1 - --t * t) }, circularInOut: function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, elasticIn: function(t) {
                var e, i = .1,
                    n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n))) }, elasticOut: function(t) {
                var e, i = .1,
                    n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / n) + 1) }, elasticInOut: function(t) {
                var e, i = .1,
                    n = .4;
                return 0 === t ? 0 : 1 === t ? 1 : (!i || 1 > i ? (i = 1, e = n / 4) : e = n * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) : i * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / n) * .5 + 1) }, backIn: function(t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e) }, backOut: function(t) {
                var e = 1.70158;
                return --t * t * ((e + 1) * t + e) + 1 }, backInOut: function(t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? .5 * t * t * ((e + 1) * t - e) : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) }, bounceIn: function(e) {
                return 1 - t.bounceOut(1 - e) }, bounceOut: function(t) {
                return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, bounceInOut: function(e) {
                return .5 > e ? .5 * t.bounceIn(2 * e) : .5 * t.bounceOut(2 * e - 1) + .5 } };
        return t }), e("echarts/coord/axisModelCreator", [We, "./axisDefault", He, "../model/Component", "../util/layout"], function(t) {
        var e = t("./axisDefault"),
            i = t(He),
            n = t("../model/Component"),
            r = t("../util/layout"),
            a = ["value", w, "time", "log"];
        return function(t, o, s, l) { i.each(a, function(n) { o[be]({ type: t + "Axis." + n, mergeDefaultAndTheme: function(e, a) {
                        var o = this.layoutMode,
                            l = o ? r.getLayoutParams(e) : {},
                            c = a.getTheme();
                        i.merge(e, c.get(n + "Axis")), i.merge(e, this.getDefaultOption()), e.type = s(t, e), o && r.mergeLayoutParam(e, l, o) }, defaultOption: i.mergeAll([{}, e[n + "Axis"], l], !0) }) }), n.registerSubTypeDefaulter(t + "Axis", i.curry(s, t)) } }), e("echarts/coord/axisModelCommonMixin", [We, He, "./axisHelper"], function(t) {
        function e(t) {
            return r[Me](t) && null != t.value ? t.value : t }

        function i() {
            return this.get("type") === w && r.map(this.get("data"), e) }

        function n() {
            return a.getFormattedLabels(this.axis, this.get("axisLabel.formatter")) }
        var r = t(He),
            a = t("./axisHelper");
        return { getFormattedLabels: n, getCategories: i } }), e("zrender/config", [], function() {
        var t = 1;
        typeof window !== r && (t = Math.max(window.devicePixelRatio || 1, 1));
        var e = { debugMode: 0, devicePixelRatio: t };
        return e }), e("echarts/coord/axisDefault", [We, He], function(t) {
        var e = t(He),
            i = { show: !0, zlevel: 0, z: 0, inverse: !1, name: "", nameLocation: "end", nameTextStyle: {}, nameGap: 15, silent: !0, axisLine: { show: !0, onZero: !0, lineStyle: { color: "#333", width: 1, type: "solid" } }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { color: "#333", width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, margin: 8, textStyle: { color: "#333", fontSize: 12 } }, splitLine: { show: !0, lineStyle: { color: ["#ccc"], width: 1, type: "solid" } }, splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"] } } },
            n = e.merge({ boundaryGap: !0, axisTick: { interval: "auto" }, axisLabel: { interval: "auto" } }, i),
            r = e[xe]({ boundaryGap: [0, 0], splitNumber: 5 }, i),
            a = e[xe]({ scale: !0, min: "dataMin", max: "dataMax" }, r),
            o = e[xe]({}, r);
        return o.scale = !0, { categoryAxis: n, valueAxis: r, timeAxis: a, logAxis: o } }), e("zrender/contain/line", [], function() {
        return { containStroke: function(t, e, i, n, r, a, o) {
                if (0 === r) return !1;
                var s = r,
                    l = 0,
                    c = t;
                if (o > e + s && o > n + s || e - s > o && n - s > o || a > t + s && a > i + s || t - s > a && i - s > a) return !1;
                if (t === i) return Math.abs(a - t) <= s / 2;
                l = (e - n) / (t - i), c = (t * n - i * e) / (t - i);
                var u = l * a - o + c,
                    h = u * u / (l * l + 1);
                return s / 2 * s / 2 >= h } } }), e("zrender/contain/cubic", [We, "../core/curve"], function(t) {
        var e = t("../core/curve");
        return { containStroke: function(t, i, n, r, a, o, s, l, c, u, h) {
                if (0 === c) return !1;
                var d = c;
                if (h > i + d && h > r + d && h > o + d && h > l + d || i - d > h && r - d > h && o - d > h && l - d > h || u > t + d && u > n + d && u > a + d && u > s + d || t - d > u && n - d > u && a - d > u && s - d > u) return !1;
                var f = e.cubicProjectPoint(t, i, n, r, a, o, s, l, u, h, null);
                return d / 2 >= f } } }), e("zrender/contain/quadratic", [We, "../core/curve"], function(t) {
        var e = t("../core/curve");
        return { containStroke: function(t, i, n, r, a, o, s, l, c) {
                if (0 === s) return !1;
                var u = s;
                if (c > i + u && c > r + u && c > o + u || i - u > c && r - u > c && o - u > c || l > t + u && l > n + u && l > a + u || t - u > l && n - u > l && a - u > l) return !1;
                var h = e.quadraticProjectPoint(t, i, n, r, a, o, l, c, null);
                return u / 2 >= h } } }), e("zrender/contain/arc", [We, "./util"], function(t) {
        var e = t("./util").normalizeRadian,
            i = 2 * Math.PI;
        return { containStroke: function(t, n, r, a, o, s, l, c, u) {
                if (0 === l) return !1;
                var h = l;
                c -= t, u -= n;
                var d = Math.sqrt(c * c + u * u);
                if (d - h > r || r > d + h) return !1;
                if (Math.abs(a - o) % i < 1e-4) return !0;
                if (s) {
                    var f = a;
                    a = e(o), o = e(f) } else a = e(a), o = e(o);
                a > o && (o += i);
                var p = Math.atan2(u, c);
                return 0 > p && (p += i), p >= a && o >= p || p + i >= a && o >= p + i } } }), e("zrender/contain/util", [We], function() {
        var t = 2 * Math.PI;
        return { normalizeRadian: function(e) {
                return e %= t, 0 > e && (e += t), e } } }), e("zrender/contain/windingLine", [], function() {
        return function(t, e, i, n, r, a) {
            if (a > e && a > n || e > a && n > a) return 0;
            if (n === e) return 0;
            var o = e > n ? 1 : -1,
                s = (a - e) / (n - e),
                l = s * (i - t) + t;
            return l > r ? o : 0 } }), e("zrender/core/LRU", [We], function() {
        var t = function() { this.head = null, this.tail = null, this._len = 0 },
            e = t[Ee];
        e.insert = function(t) {
            var e = new i(t);
            return this.insertEntry(e), e }, e.insertEntry = function(t) { this.head ? (this.tail.next = t, t.prev = this.tail, this.tail = t) : this.head = this.tail = t, this._len++ }, e[we] = function(t) {
            var e = t.prev,
                i = t.next;
            e ? e.next = i : this.head = i, i ? i.prev = e : this.tail = e, t.next = t.prev = null, this._len-- }, e.len = function() {
            return this._len };
        var i = function(t) { this.value = t, this.next, this.prev },
            n = function(e) { this._list = new t, this._map = {}, this._maxSize = e || 10 },
            r = n[Ee];
        return r.put = function(t, e) {
            var i = this._list,
                n = this._map;
            if (null == n[t]) {
                var r = i.len();
                if (r >= this._maxSize && r > 0) {
                    var a = i.head;
                    i[we](a), delete n[a.key] }
                var o = i.insert(e);
                o.key = t, n[t] = o } }, r.get = function(t) {
            var e = this._map[t],
                i = this._list;
            return null != e ? (e !== i.tail && (i[we](e), i.insertEntry(e)), e.value) : void 0 }, r.clear = function() { this._list.clear(), this._map = {} }, n }), e("zrender/graphic/helper/roundRect", [We], function() {
        return { buildPath: function(t, e) {
                var i, n, r, a, o = e.x,
                    s = e.y,
                    l = e.width,
                    c = e[Ae],
                    u = e.r;
                0 > l && (o += l, l = -l), 0 > c && (s += c, c = -c), typeof u === ee ? i = n = r = a = u : u instanceof Array ? 1 === u[ye] ? i = n = r = a = u[0] : 2 === u[ye] ? (i = r = u[0], n = a = u[1]) : 3 === u[ye] ? (i = u[0], n = a = u[1], r = u[2]) : (i = u[0], n = u[1], r = u[2], a = u[3]) : i = n = r = a = 0;
                var h;
                i + n > l && (h = i + n, i *= l / h, n *= l / h), r + a > l && (h = r + a, r *= l / h, a *= l / h), n + r > c && (h = n + r, n *= c / h, r *= c / h), i + a > c && (h = i + a, i *= c / h, a *= c / h), t.moveTo(o + i, s), t.lineTo(o + l - n, s), 0 !== n && t.quadraticCurveTo(o + l, s, o + l, s + n), t.lineTo(o + l, s + c - r), 0 !== r && t.quadraticCurveTo(o + l, s + c, o + l - r, s + c), t.lineTo(o + a, s + c), 0 !== a && t.quadraticCurveTo(o, s + c, o, s + c - a), t.lineTo(o, s + i), 0 !== i && t.quadraticCurveTo(o, s, o + i, s) } } }), e("echarts/chart/helper/createListFromArray", [We, "../../data/List", "../../data/helper/completeDimensions", He, "../../util/model", "../../CoordinateSystem"], function(t) {
        function e(t) {
            for (var e = 0; e < t[ye] && null == t[e];) e++;
            return t[e] }

        function i(t) {
            var i = e(t);
            return null != i && !c[re](d(i)) }

        function n(t, e, n) { t = t || [];
            var r = e.get(K),
                a = p[r],
                u = h.get(r),
                m = a && a(t, e, n),
                v = m && m[S];
            v || (v = u && u[S] || ["x", "y"], v = l(v, t, v[E](["value"])));
            var g, y = m && m.categoryAxisModel,
                x = v[0].type === A ? 0 : v[1].type === A ? 1 : -1,
                _ = new s(v, e),
                b = o(m, t),
                w = y && i(t) ? function(t, e, i, n) {
                    return n === x ? i : f(d(t), v[n]) } : function(t, e, i, n) {
                    var r = d(t),
                        a = f(r && r[n], v[n]);
                    return x === n && typeof a === Be && (g = g || y.getCategories(), a = c[ne](g, a), 0 > a && !isNaN(a) && (a = +a)), a };
            return _.initData(t, b, w), _ }

        function r(t) {
            return t !== w && "time" !== t }

        function a(t) {
            return t === w ? A : "time" === t ? "time" : "float" }

        function o(t, e) {
            var i = [];
            if (t && t.categoryAxisModel) {
                var n = t.categoryAxisModel.getCategories();
                if (n) {
                    var r = e[ye];
                    if (c[re](e[0]) && e[0][ye] > 1) { i = [];
                        for (var a = 0; r > a; a++) i[a] = n[e[a][t.categoryIndex || 0]] } else i = n.slice(0) } }
            return i }
        var s = t("../../data/List"),
            l = t("../../data/helper/completeDimensions"),
            c = t(He),
            u = t("../../util/model"),
            h = t("../../CoordinateSystem"),
            d = u.getDataItemValue,
            f = u.converDataValue,
            p = { cartesian2d: function(t, e, i) {
                    var n = i[M]("xAxis", e.get("xAxisIndex")),
                        o = i[M]("yAxis", e.get("yAxisIndex")),
                        s = n.get("type"),
                        c = o.get("type"),
                        u = [{ name: "x", type: a(s), stackable: r(s) }, { name: "y", type: a(c), stackable: r(c) }],
                        h = s === w;
                    return l(u, t, ["x", "y", "z"]), { dimensions: u, categoryIndex: h ? 0 : 1, categoryAxisModel: h ? n : c === w ? o : null } }, polar: function(t, e, i) {
                    var n = e.get("polarIndex") || 0,
                        o = function(t) {
                            return t.get("polarIndex") === n },
                        s = i.findComponents({ mainType: "angleAxis", filter: o })[0],
                        c = i.findComponents({ mainType: "radiusAxis", filter: o })[0],
                        u = c.get("type"),
                        h = s.get("type"),
                        d = [{ name: "radius", type: a(u), stackable: r(u) }, { name: "angle", type: a(h), stackable: r(h) }],
                        f = h === w;
                    return l(d, t, [O, "angle", "value"]), { dimensions: d, categoryIndex: f ? 1 : 0, categoryAxisModel: f ? s : u === w ? c : null } }, geo: function(t) {
                    return { dimensions: l([{ name: "lng" }, { name: "lat" }], t, ["lng", "lat", "value"]) } } };
        return n }), e("zrender/graphic/helper/poly", [We, "./smoothSpline", "./smoothBezier"], function(t) {
        var e = t("./smoothSpline"),
            i = t("./smoothBezier");
        return { buildPath: function(t, n, r) {
                var a = n.points,
                    o = n.smooth;
                if (a && a[ye] >= 2) {
                    if (o && "spline" !== o) {
                        var s = i(a, o, r, n.smoothConstraint);
                        t.moveTo(a[0][0], a[0][1]);
                        for (var l = a[ye], c = 0;
                            (r ? l : l - 1) > c; c++) {
                            var u = s[2 * c],
                                h = s[2 * c + 1],
                                d = a[(c + 1) % l];
                            t.bezierCurveTo(u[0], u[1], h[0], h[1], d[0], d[1]) } } else { "spline" === o && (a = e(a, r)), t.moveTo(a[0][0], a[0][1]);
                        for (var c = 1, f = a[ye]; f > c; c++) t.lineTo(a[c][0], a[c][1]) }
                    r && t.closePath() } } } }), e("zrender/Handler", [We, "./core/env", "./core/event", "./core/util", "./mixin/Draggable", "./core/GestureMgr", "./mixin/Eventful"], function(t) {
        function e(t, e, i) {
            return { type: t, event: i, target: e, cancelBubble: !1, offsetX: i.zrX, offsetY: i.zrY, gestureEvent: i.gestureEvent, pinchX: i.pinchX, pinchY: i.pinchY, pinchScale: i.pinchScale, wheelDelta: i.zrDelta } }

        function i(t, e, i) {
            var n = t._gestureMgr; "start" === i && n.clear();
            var r = n.recognize(e, t.findHover(e.zrX, e.zrY, null));
            if ("end" === i && n.clear(), r) {
                var a = r.type;
                e.gestureEvent = a, t._dispatchProxy(r[he], a, r.event) } }

        function n(t) {
            function e(t, e) {
                return function() {
                    return e._touching ? void 0 : t.apply(e, arguments) } }
            for (var i = g[E](y), n = 0; n < i[ye]; n++) {
                var r = i[n];
                t._handlers[r] = d.bind(M[r], t) }
            for (var n = 0; n < v[ye]; n++) {
                var r = v[n];
                t._handlers[r] = e(M[r], t) } }

        function r(t, e, i) {
            if (t[t.rectHover ? "rectContain" : G](e, i)) {
                for (var n = t; n;) {
                    if (n.silent || n.clipPath && !n.clipPath[G](e, i)) return !1;
                    n = n[a] }
                return !0 }
            return !1 }

        function o(t) { t._touching = !0, clearTimeout(t._touchTimer), t._touchTimer = setTimeout(function() { t._touching = !1 }, 700) }

        function s() {
            return !1 }

        function l() {
            return u.touchEventsSupported }

        function c(t) {
            return "mousewheel" === t && u.browser.firefox ? "DOMMouseScroll" : t }
        var u = t("./core/env"),
            h = t("./core/event"),
            d = t("./core/util"),
            f = t("./mixin/Draggable"),
            p = t("./core/GestureMgr"),
            m = t("./mixin/Eventful"),
            v = ["click", "dblclick", "mousewheel", de];!s() && v.push("mouseup", "mousedown", "mousemove");
        var g = ["touchstart", "touchend", "touchmove"],
            y = ["pointerdown", "pointerup", "pointermove"],
            x = 300,
            _ = h.addEventListener,
            b = h.removeEventListener,
            w = h.normalizeEvent,
            M = { mousemove: function(t) { t = w(this.root, t);
                    var e = t.zrX,
                        i = t.zrY,
                        n = this.findHover(e, i, null),
                        r = this._hovered;
                    this._hovered = n, this.root.style.cursor = n ? n.cursor : this._defaultCursorStyle, r && n !== r && r.__zr && this._dispatchProxy(r, de, t), this._dispatchProxy(n, "mousemove", t), n && n !== r && this._dispatchProxy(n, fe, t) }, mouseout: function(t) { t = w(this.root, t);
                    var e = t.toElement || t.relatedTarget;
                    if (e != this.root)
                        for (; e && 9 != e.nodeType;) {
                            if (e === this.root) return;
                            e = e.parentNode }
                    this._dispatchProxy(this._hovered, de, t), this[ge]("globalout", { event: t }) }, touchstart: function(t) { t = w(this.root, t), this._lastTouchMoment = new Date, i(this, t, "start"), M.mousemove.call(this, t), M.mousedown.call(this, t), o(this) }, touchmove: function(t) { t = w(this.root, t), i(this, t, "change"), M.mousemove.call(this, t), o(this) }, touchend: function(t) { t = w(this.root, t), i(this, t, "end"), M.mouseup.call(this, t), +new Date - this._lastTouchMoment < x && M.click.call(this, t), o(this) } };
        d.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick"], function(t) { M[t] = function(e) { e = w(this.root, e);
                var i = this.findHover(e.zrX, e.zrY, null);
                this._dispatchProxy(i, t, e) } });
        var S = function(t, e, i) {
            function r(e, i) { d.each(e, function(e) { _(t, c(e), i._handlers[e]) }, i) }
            m.call(this), this.root = t, this.storage = e, this.painter = i, this._hovered, this._lastTouchMoment, this._lastX, this._lastY, this._defaultCursorStyle = "default", this._gestureMgr = new p, this._handlers = [], this._touching = !1, this._touchTimer, n(this), s() ? r(y, this) : l() && r(g, this), r(v, this), f.call(this) };
        return S[Ee] = { constructor: S, resize: function() { this._hovered = null }, dispatch: function(t, e) {
                var i = this._handlers[t];
                i && i.call(this, e) }, dispose: function() {
                for (var t = this.root, e = v[E](g), i = 0; i < e[ye]; i++) {
                    var n = e[i];
                    b(t, c(n), this._handlers[n]) }
                this.root = this.storage = this.painter = null }, setDefaultCursorStyle: function(t) { this._defaultCursorStyle = t }, _dispatchProxy: function(t, i, n) {
                for (var r = "on" + i, o = e(i, t, n), s = t; s && (s[r] && (o.cancelBubble = s[r].call(s, o)), s[ge](i, o), s = s[a], !o.cancelBubble););
                o.cancelBubble || (this[ge](i, o), this.painter && this.painter.eachOtherLayer(function(t) { typeof t[r] == ie && t[r].call(t, o), t[ge] && t[ge](i, o) })) }, findHover: function(t, e, i) {
                for (var n = this.storage.getDisplayList(), a = n[ye] - 1; a >= 0; a--)
                    if (!n[a].silent && n[a] !== i && !n[a][Le] && r(n[a], t, e)) return n[a] } }, d.mixin(S, m), d.mixin(S, f), S }), e("zrender/Storage", [We, "./core/util", "./container/Group"], function(t) {
        function e(t, e) {
            return t[se] === e[se] ? t.z === e.z ? t.z2 === e.z2 ? t.__renderidx - e.__renderidx : t.z2 - e.z2 : t.z - e.z : t[se] - e[se] }
        var i = t("./core/util"),
            n = t("./container/Group"),
            r = function() { this._elements = {}, this._roots = [], this._displayList = [], this._displayListLen = 0 };
        return r[Ee] = { constructor: r, getDisplayList: function(t, e) {
                return e = e || !1, t && this.updateDisplayList(e), this._displayList }, updateDisplayList: function(t) { this._displayListLen = 0;
                for (var i = this._roots, n = this._displayList, r = 0, a = i[ye]; a > r; r++) this._updateAndAddDisplayable(i[r], null, t);
                n[ye] = this._displayListLen;
                for (var r = 0, a = n[ye]; a > r; r++) n[r].__renderidx = r;
                n.sort(e) }, _updateAndAddDisplayable: function(t, e, i) {
                if (!t[Le] || i) { t.beforeUpdate(), t[Te](), t.afterUpdate();
                    var n = t.clipPath;
                    if (n && (n[a] = t, n.updateTransform(), e ? (e = e.slice(), e.push(n)) : e = [n]), "group" == t.type) {
                        for (var r = t._children, o = 0; o < r[ye]; o++) {
                            var s = r[o];
                            s.__dirty = t.__dirty || s.__dirty, this._updateAndAddDisplayable(s, e, i) }
                        t.__dirty = !1 } else t.__clipPaths = e, this._displayList[this._displayListLen++] = t } }, addRoot: function(t) { this._elements[t.id] || (t instanceof n && t.addChildrenToStorage(this), this.addToMap(t), this._roots.push(t)) }, delRoot: function(t) {
                if (null == t) {
                    for (var e = 0; e < this._roots[ye]; e++) {
                        var r = this._roots[e];
                        r instanceof n && r.delChildrenFromStorage(this) }
                    return this._elements = {}, this._roots = [], this._displayList = [], void(this._displayListLen = 0) }
                if (t instanceof Array)
                    for (var e = 0, a = t[ye]; a > e; e++) this.delRoot(t[e]);
                else {
                    var o;
                    o = typeof t == Be ? this._elements[t] : t;
                    var s = i[ne](this._roots, o);
                    s >= 0 && (this.delFromMap(o.id), this._roots[pe](s, 1), o instanceof n && o.delChildrenFromStorage(this)) } }, addToMap: function(t) {
                return t instanceof n && (t.__storage = this), t.dirty(), this._elements[t.id] = t, this }, get: function(t) {
                return this._elements[t] }, delFromMap: function(t) {
                var e = this._elements,
                    i = e[t];
                return i && (delete e[t], i instanceof n && (i.__storage = null)), this }, dispose: function() { this._elements = this._renderList = this._roots = null } }, r }), e("zrender/animation/Animation", [We, n, "../core/event", "./Animator"], function(t) {
        var e = t(n),
            i = t("../core/event").Dispatcher,
            a = typeof window !== r && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) { setTimeout(t, 16) },
            o = t("./Animator"),
            s = function(t) { t = t || {}, this.stage = t.stage || {}, this.onframe = t.onframe || function() {}, this._clips = [], this._running = !1, this._time = 0, i.call(this) };
        return s[Ee] = { constructor: s, addClip: function(t) { this._clips.push(t) }, addAnimator: function(t) { t[P] = this;
                for (var e = t.getClips(), i = 0; i < e[ye]; i++) this.addClip(e[i]) }, removeClip: function(t) {
                var i = e[ne](this._clips, t);
                i >= 0 && this._clips[pe](i, 1) }, removeAnimator: function(t) {
                for (var e = t.getClips(), i = 0; i < e[ye]; i++) this.removeClip(e[i]);
                t[P] = null }, _update: function() {
                for (var t = (new Date).getTime(), e = t - this._time, i = this._clips, n = i[ye], r = [], a = [], o = 0; n > o; o++) {
                    var s = i[o],
                        l = s.step(t);
                    l && (r.push(l), a.push(s)) }
                for (var o = 0; n > o;) i[o]._needsRemove ? (i[o] = i[n - 1], i.pop(), n--) : o++;
                n = r[ye];
                for (var o = 0; n > o; o++) a[o].fire(r[o]);
                this._time = t, this.onframe(e), this[ge]("frame", e), this.stage[Te] && this.stage[Te]() }, start: function() {
                function t() { e._running && (a(t), e._update()) }
                var e = this;
                this._running = !0, this._time = (new Date).getTime(), a(t) }, stop: function() { this._running = !1 }, clear: function() { this._clips = [] }, animate: function(t, e) { e = e || {};
                var i = new o(t, e.loop, e.getter, e.setter);
                return i } }, e.mixin(s, i), s }), e("zrender/Painter", [We, "./config", "./core/util", "./core/log", "./core/BoundingRect", "./Layer", "./graphic/Image"], function(t) {
        function e(t) {
            return parseInt(t, 10) }

        function n(t) {
            return t ? t.isBuildin ? !0 : typeof t[Re] !== ie || typeof t.refresh !== ie ? !1 : !0 : !1 }

        function r(t) { t.__unusedCount++ }

        function a(t) { t.__dirty = !1, 1 == t.__unusedCount && t.clear() }

        function o(t, e, i) {
            return v.copy(t[U]()), t[Ne] && v[l](t[Ne]), g.width = e, g[Ae] = i, !v.intersect(g) }

        function s(t, e) {
            if (!t || !e || t[ye] !== e[ye]) return !0;
            for (var i = 0; i < t[ye]; i++)
                if (t[i] !== e[i]) return !0 }

        function c(t, e) {
            for (var n = 0; n < t[ye]; n++) {
                var r, a = t[n];
                a[Ne] && (r = a[Ne], e[Ne](r[0], r[1], r[2], r[3], r[4], r[5]));
                var o = a.path;
                o.beginPath(e), a[i](o, a.shape), e.clip(), a[Ne] && (r = a.invTransform, e[Ne](r[0], r[1], r[2], r[3], r[4], r[5])) } }
        var u = t("./config"),
            h = t("./core/util"),
            f = t("./core/log"),
            p = t("./core/BoundingRect"),
            m = t("./Layer"),
            v = new p(0, 0, 0, 0),
            g = new p(0, 0, 0, 0),
            y = function(t, e, i) {
                var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
                i = i || {}, this.dpr = i.devicePixelRatio || u.devicePixelRatio, this._singleCanvas = n, this.root = t;
                var r = t.style;
                if (r && (r["-webkit-tap-highlight-color"] = "transparent", r["-webkit-user-select"] = "none", r["user-select"] = "none", r["-webkit-touch-callout"] = "none", t.innerHTML = ""), this.storage = e, n) {
                    var a = t.width,
                        o = t[Ae];
                    this._width = a, this._height = o;
                    var s = new m(t, this, 1);
                    s.initContext(), this._layers = { 0: s }, this._zlevelList = [0] } else {
                    var a = this._getWidth(),
                        o = this._getHeight();
                    this._width = a, this._height = o;
                    var l = document[N]("div");
                    this._domRoot = l;
                    var c = l.style;
                    c[W] = "relative", c.overflow = "hidden", c.width = this._width + "px", c[Ae] = this._height + "px", t.appendChild(l), this._layers = {}, this._zlevelList = [] }
                this._layerConfig = {}, this.pathToImage = this._createPathToImage() };
        return y[Ee] = {
            constructor: y,
            isSingleCanvas: function() {
                return this._singleCanvas },
            getViewportRoot: function() {
                return this._singleCanvas ? this._layers[0].dom : this._domRoot },
            refresh: function(t) {
                var e = this.storage.getDisplayList(!0),
                    i = this._zlevelList;
                this._paintList(e, t);
                for (var n = 0; n < i[ye]; n++) {
                    var r = i[n],
                        a = this._layers[r];!a.isBuildin && a.refresh && a.refresh() }
                return this },
            _paintList: function(t, e) { null == e && (e = !1), this._updateLayerStatus(t);
                var i, n, l, u = this._width,
                    h = this._height;
                this.eachBuildinLayer(r);
                for (var d = null, p = 0, m = t[ye]; m > p; p++) {
                    var v = t[p],
                        g = this._singleCanvas ? 0 : v[se];
                    if (n !== g && (n = g, i = this.getLayer(n), i.isBuildin || f("ZLevel " + n + " has been used by unkown layer " + i.id), l = i.ctx, i.__unusedCount = 0, (i.__dirty || e) && i.clear()), (i.__dirty || e) && !v.invisible && 0 !== v.style[Z] && v.scale[0] && v.scale[1] && (!v.culling || !o(v, u, h))) {
                        var y = v.__clipPaths;
                        s(y, d) && (d && l.restore(), y && (l.save(), c(y, l)), d = y), v.beforeBrush && v.beforeBrush(l), v.brush(l, !1), v.afterBrush && v.afterBrush(l) }
                    v.__dirty = !1 }
                d && l.restore(), this.eachBuildinLayer(a) },
            getLayer: function(t) {
                if (this._singleCanvas) return this._layers[0];
                var e = this._layers[t];
                return e || (e = new m("zr_" + t, this, this.dpr), e.isBuildin = !0, this._layerConfig[t] && h.merge(e, this._layerConfig[t], !0), this.insertLayer(t, e), e.initContext()), e },
            insertLayer: function(t, e) {
                var i = this._layers,
                    r = this._zlevelList,
                    a = r[ye],
                    o = null,
                    s = -1,
                    l = this._domRoot;
                if (i[t]) return void f("ZLevel " + t + " has been used already");
                if (!n(e)) return void f("Layer of zlevel " + t + " is not valid");
                if (a > 0 && t > r[0]) {
                    for (s = 0; a - 1 > s && !(r[s] < t && r[s + 1] > t); s++);
                    o = i[r[s]] }
                if (r[pe](s + 1, 0, t), o) {
                    var c = o.dom;
                    c.nextSibling ? l.insertBefore(e.dom, c.nextSibling) : l.appendChild(e.dom) } else l.firstChild ? l.insertBefore(e.dom, l.firstChild) : l.appendChild(e.dom);
                i[t] = e
            },
            eachLayer: function(t, e) {
                var i, n, r = this._zlevelList;
                for (n = 0; n < r[ye]; n++) i = r[n], t.call(e, this._layers[i], i) },
            eachBuildinLayer: function(t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[ye]; r++) n = a[r], i = this._layers[n], i.isBuildin && t.call(e, i, n) },
            eachOtherLayer: function(t, e) {
                var i, n, r, a = this._zlevelList;
                for (r = 0; r < a[ye]; r++) n = a[r], i = this._layers[n], i.isBuildin || t.call(e, i, n) },
            getLayers: function() {
                return this._layers },
            _updateLayerStatus: function(t) {
                var e = this._layers,
                    i = {};
                this.eachBuildinLayer(function(t, e) { i[e] = t.elCount, t.elCount = 0 });
                for (var n = 0, r = t[ye]; r > n; n++) {
                    var a = t[n],
                        o = this._singleCanvas ? 0 : a[se],
                        s = e[o];
                    if (s) {
                        if (s.elCount++, s.__dirty) continue;
                        s.__dirty = a.__dirty } }
                this.eachBuildinLayer(function(t, e) { i[e] !== t.elCount && (t.__dirty = !0) }) },
            clear: function() {
                return this.eachBuildinLayer(this._clearLayer), this },
            _clearLayer: function(t) { t.clear() },
            configLayer: function(t, e) {
                if (e) {
                    var i = this._layerConfig;
                    i[t] ? h.merge(i[t], e, !0) : i[t] = e;
                    var n = this._layers[t];
                    n && h.merge(n, i[t], !0) } },
            delLayer: function(t) {
                var e = this._layers,
                    i = this._zlevelList,
                    n = e[t];
                n && (n.dom.parentNode.removeChild(n.dom), delete e[t], i[pe](h[ne](i, t), 1)) },
            resize: function(t, e) {
                var i = this._domRoot;
                if (i.style.display = "none", t = t || this._getWidth(), e = e || this._getHeight(), i.style.display = "", this._width != t || e != this._height) { i.style.width = t + "px", i.style[Ae] = e + "px";
                    for (var n in this._layers) this._layers[n][Re](t, e);
                    this.refresh(!0) }
                return this._width = t, this._height = e, this },
            clearLayer: function(t) {
                var e = this._layers[t];
                e && e.clear() },
            dispose: function() { this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null },
            getRenderedCanvas: function(t) {
                if (t = t || {}, this._singleCanvas) return this._layers[0].dom;
                var e = new m("image", this, t.pixelRatio || this.dpr);
                e.initContext();
                var i = e.ctx;
                e.clearColor = t.backgroundColor, e.clear();
                for (var n = this.storage.getDisplayList(!0), r = 0; r < n[ye]; r++) {
                    var a = n[r];
                    a.invisible || (a.beforeBrush && a.beforeBrush(i), a.brush(i, !1), a.afterBrush && a.afterBrush(i)) }
                return e.dom },
            getWidth: function() {
                return this._width },
            getHeight: function() {
                return this._height },
            _getWidth: function() {
                var t = this.root,
                    i = document.defaultView.getComputedStyle(t);
                return (t.clientWidth || e(i.width) || e(t.style.width)) - (e(i.paddingLeft) || 0) - (e(i.paddingRight) || 0) | 0 },
            _getHeight: function() {
                var t = this.root,
                    i = document.defaultView.getComputedStyle(t);
                return (t.clientHeight || e(i[Ae]) || e(t.style[Ae])) - (e(i.paddingTop) || 0) - (e(i.paddingBottom) || 0) | 0 },
            _pathToImage: function(e, i, n, r, a) {
                var o = document[N]("canvas"),
                    s = o[V]("2d");
                o.width = n * a, o[Ae] = r * a, s.clearRect(0, 0, n * a, r * a);
                var l = { position: i[W], rotation: i[d], scale: i.scale };
                i[W] = [0, 0, 0], i[d] = 0, i.scale = [1, 1], i && i.brush(s);
                var c = t("./graphic/Image"),
                    u = new c({ id: e, style: { x: 0, y: 0, image: o } });
                return null != l[W] && (u[W] = i[W] = l[W]), null != l[d] && (u[d] = i[d] = l[d]), null != l.scale && (u.scale = i.scale = l.scale), u },
            _createPathToImage: function() {
                var t = this;
                return function(e, i, n, r) {
                    return t._pathToImage(e, i, n, r, t.dpr) } }
        }, y
    }), e("echarts/data/List", [We, "../model/Model", "./DataDiffer", He, "../util/model"], function(t) {
        function e(t) {
            return d[re](t) || (t = [t]), t }

        function i(t, e) {
            var i = t[S],
                n = new y(d.map(i, t.getDimensionInfo, t), t.hostModel);
            g(n, t, t._wrappedMethods);
            for (var r = n._storage = {}, a = t._storage, o = 0; o < i[ye]; o++) {
                var s = i[o],
                    l = a[s];
                r[s] = d[ne](e, s) >= 0 ? new l.constructor(a[s][ye]) : a[s] }
            return n }
        var n = r,
            a = typeof window === r ? global : window,
            o = typeof a.Float64Array === n ? Array : a.Float64Array,
            s = typeof a.Int32Array === n ? Array : a.Int32Array,
            l = { "float": o, "int": s, ordinal: Array, number: Array, time: Array },
            u = t("../model/Model"),
            h = t("./DataDiffer"),
            d = t(He),
            f = t("../util/model"),
            m = d[Me],
            v = ["stackedOn", "_nameList", "_idList", "_rawData"],
            g = function(t, e, i) { d.each(v[E](i || []), function(i) { e.hasOwnProperty(i) && (t[i] = e[i]) }) },
            y = function(t, e) { t = t || ["x", "y"];
                for (var i = {}, n = [], r = 0; r < t[ye]; r++) {
                    var a, o = {};
                    typeof t[r] === Be ? (a = t[r], o = { name: a, stackable: !1, type: "number" }) : (o = t[r], a = o.name, o.type = o.type || ee), n.push(a), i[a] = o }
                this[S] = n, this._dimensionInfos = i, this.hostModel = e, this.indices = [], this._storage = {}, this._nameList = [], this._idList = [], this._optionModels = [], this.stackedOn = null, this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._rawData, this._extent },
            _ = y[Ee];
        _.type = "list", _.getDimension = function(t) {
            return isNaN(t) || (t = this[S][t] || t), t }, _.getDimensionInfo = function(t) {
            return d.clone(this._dimensionInfos[this.getDimension(t)]) }, _.initData = function(t, e, i) { t = t || [], this._rawData = t;
            var n = this._storage = {},
                r = this.indices = [],
                a = this[S],
                o = t[ye],
                s = this._dimensionInfos,
                c = [],
                u = {};
            e = e || [];
            for (var h = 0; h < a[ye]; h++) {
                var p = s[a[h]],
                    m = l[p.type];
                n[a[h]] = new m(o) }
            i = i || function(t, e, i, n) {
                var r = f.getDataItemValue(t);
                return f.converDataValue(d[re](r) ? r[n] : r, s[e]) };
            for (var v = 0; v < t[ye]; v++) {
                for (var g = t[v], y = 0; y < a[ye]; y++) {
                    var x = a[y],
                        _ = n[x];
                    _[v] = i(g, x, v, y) }
                r.push(v) }
            for (var h = 0; h < t[ye]; h++) {
                var b = "";
                e[h] || (e[h] = t[h].name, b = t[h].id);
                var w = e[h] || "";!b && w && (u[w] = u[w] || 0, b = w, u[w] > 0 && (b += "__ec__" + u[w]), u[w]++), b && (c[h] = b) }
            this._nameList = e, this._idList = c }, _.count = function() {
            return this.indices[ye] }, _.get = function(t, e, i) {
            var n = this._storage,
                r = this.indices[e];
            if (null == r) return 0 / 0;
            var a = n[t] && n[t][r];
            if (i) {
                var o = this._dimensionInfos[t];
                if (o && o.stackable)
                    for (var s = this.stackedOn; s;) {
                        var l = s.get(t, e);
                        (a >= 0 && l > 0 || 0 >= a && 0 > l) && (a += l), s = s.stackedOn } }
            return a }, _.getValues = function(t, e, i) {
            var n = [];
            d[re](t) || (i = e, e = t, t = this[S]);
            for (var r = 0, a = t[ye]; a > r; r++) n.push(this.get(t[r], e, i));
            return n }, _.hasValue = function(t) {
            for (var e = this[S], i = this._dimensionInfos, n = 0, r = e[ye]; r > n; n++)
                if (i[e[n]].type !== A && isNaN(this.get(e[n], t))) return !1;
            return !0 }, _.getDataExtent = function(t, e) {
            var i = this._storage[t],
                n = this.getDimensionInfo(t);
            e = n && n.stackable && e;
            var r, a = (this._extent || (this._extent = {}))[t + !!e];
            if (a) return a;
            if (i) {
                for (var o = 1 / 0, s = -1 / 0, l = 0, c = this.count(); c > l; l++) r = this.get(t, l, e), o > r && (o = r), r > s && (s = r);
                return this._extent[t + e] = [o, s] }
            return [1 / 0, -1 / 0] }, _.getSum = function(t, e) {
            var i = this._storage[t],
                n = 0;
            if (i)
                for (var r = 0, a = this.count(); a > r; r++) {
                    var o = this.get(t, r, e);
                    isNaN(o) || (n += o) }
            return n }, _[ne] = function(t, e) {
            var i = this._storage,
                n = i[t],
                r = this.indices;
            if (n)
                for (var a = 0, o = r[ye]; o > a; a++) {
                    var s = r[a];
                    if (n[s] === e) return a }
            return -1 }, _.indexOfName = function(t) {
            for (var e = this.indices, i = this._nameList, n = 0, r = e[ye]; r > n; n++) {
                var a = e[n];
                if (i[a] === t) return n }
            return -1 }, _.indexOfNearest = function(t, e, i) {
            var n = this._storage,
                r = n[t];
            if (r) {
                for (var a = Number.MAX_VALUE, o = -1, s = 0, l = this.count(); l > s; s++) {
                    var c = e - this.get(t, s, i),
                        u = Math.abs(c);
                    (a > u || u === a && c > 0) && (a = u, o = s) }
                return o }
            return -1 }, _.getRawIndex = function(t) {
            var e = this.indices[t];
            return null == e ? -1 : e }, _[p] = function(t) {
            return this._nameList[this.indices[t]] || "" }, _.getId = function(t) {
            return this._idList[this.indices[t]] || this.getRawIndex(t) + "" }, _.each = function(t, i, n, r) { typeof t === ie && (r = n, n = i, i = t, t = []), t = d.map(e(t), this.getDimension, this);
            var a = [],
                o = t[ye],
                s = this.indices;
            r = r || this;
            for (var l = 0; l < s[ye]; l++)
                if (0 === o) i.call(r, l);
                else if (1 === o) i.call(r, this.get(t[0], l, n), l);
            else {
                for (var c = 0; o > c; c++) a[c] = this.get(t[c], l, n);
                a[c] = l, i.apply(r, a) } }, _.filterSelf = function(t, i, n, r) { typeof t === ie && (r = n, n = i, i = t, t = []), t = d.map(e(t), this.getDimension, this);
            var a = [],
                o = [],
                s = t[ye],
                l = this.indices;
            r = r || this;
            for (var c = 0; c < l[ye]; c++) {
                var u;
                if (1 === s) u = i.call(r, this.get(t[0], c, n), c);
                else {
                    for (var h = 0; s > h; h++) o[h] = this.get(t[h], c, n);
                    o[h] = c, u = i.apply(r, o) }
                u && a.push(l[c]) }
            return this.indices = a, this._extent = {}, this }, _.mapArray = function(t, e, i, n) { typeof t === ie && (n = i, i = e, e = t, t = []);
            var r = [];
            return this.each(t, function() { r.push(e && e.apply(this, arguments)) }, i, n), r }, _.map = function(t, n, r, a) { t = d.map(e(t), this.getDimension, this);
            var o = i(this, t),
                s = o.indices = this.indices,
                l = o._storage,
                c = [];
            return this.each(t, function() {
                var e = arguments[arguments[ye] - 1],
                    i = n && n.apply(this, arguments);
                if (null != i) { typeof i === ee && (c[0] = i, i = c);
                    for (var r = 0; r < i[ye]; r++) {
                        var a = t[r],
                            o = l[a],
                            u = s[e];
                        o && (o[u] = i[r]) } } }, r, a), o }, _.downSample = function(t, e, n, r) {
            for (var a = i(this, [t]), o = this._storage, s = a._storage, l = this.indices, c = a.indices = [], u = [], h = [], d = Math.floor(1 / e), f = s[t], p = this.count(), m = 0; m < o[t][ye]; m++) s[t][m] = o[t][m];
            for (var m = 0; p > m; m += d) { d > p - m && (d = p - m, u[ye] = d);
                for (var v = 0; d > v; v++) {
                    var g = l[m + v];
                    u[v] = f[g], h[v] = g }
                var y = n(u),
                    g = h[r(u, y) || 0];
                f[g] = y, c.push(g) }
            return a }, _[T] = function(t) {
            var e = this.hostModel;
            return t = this.indices[t], new u(this._rawData[t], e, e[c]) }, _.diff = function(t) {
            var e = this._idList,
                i = t && t._idList;
            return new h(t ? t.indices : [], this.indices, function(t) {
                return i[t] || t + "" }, function(t) {
                return e[t] || t + "" }) }, _.getVisual = function(t) {
            var e = this._visual;
            return e && e[t] }, _.setVisual = function(t, e) {
            if (m(t))
                for (var i in t) t.hasOwnProperty(i) && this.setVisual(i, t[i]);
            else this._visual = this._visual || {}, this._visual[t] = e }, _.setLayout = function(t, e) {
            if (m(t))
                for (var i in t) t.hasOwnProperty(i) && this.setLayout(i, t[i]);
            else this._layout[t] = e }, _.getLayout = function(t) {
            return this._layout[t] }, _[D] = function(t) {
            return this._itemLayouts[t] }, _.setItemLayout = function(t, e, i) { this._itemLayouts[t] = i ? d[be](this._itemLayouts[t] || {}, e) : e }, _[x] = function(t, e, i) {
            var n = this._itemVisuals[t],
                r = n && n[e];
            return null != r || i ? r : this.getVisual(e) }, _.setItemVisual = function(t, e, i) {
            var n = this._itemVisuals[t] || {};
            if (this._itemVisuals[t] = n, m(e))
                for (var r in e) e.hasOwnProperty(r) && (n[r] = e[r]);
            else n[e] = i };
        var b = function(t) { t[ce] = this[ce], t[ue] = this[ue] };
        return _.setItemGraphicEl = function(t, e) {
            var i = this.hostModel;
            e && (e[ue] = t, e[ce] = i && i[ce], "group" === e.type && e[oe](b, e)), this._graphicEls[t] = e }, _[k] = function(t) {
            return this._graphicEls[t] }, _[z] = function(t, e) { d.each(this._graphicEls, function(i, n) { i && t && t.call(e, i, n) }) }, _.cloneShallow = function() {
            var t = d.map(this[S], this.getDimensionInfo, this),
                e = new y(t, this.hostModel);
            return e._storage = this._storage, g(e, this, this._wrappedMethods), e.indices = this.indices.slice(), e }, _.wrapMethod = function(t, e) {
            var i = this[t];
            typeof i === ie && (this._wrappedMethods = this._wrappedMethods || [], this._wrappedMethods.push(t), this[t] = function() {
                var t = i.apply(this, arguments);
                return e.call(this, t) }) }, y }), e("echarts/data/helper/completeDimensions", [We, He], function(t) {
        function e(t, e, a, o) {
            if (!e) return t;
            var s = n(e[0]),
                l = r[re](s) && s[ye] || 1;
            a = a || [], o = o || "extra";
            for (var c = 0; l > c; c++)
                if (!t[c]) {
                    var u = a[c] || o + (c - a[ye]);
                    t[c] = i(e, c) ? { type: "ordinal", name: u } : u }
            return t }

        function i(t, e) {
            for (var i = 0, a = t[ye]; a > i; i++) {
                var o = n(t[i]);
                if (!r[re](o)) return !1;
                var o = o[e];
                if (null != o && isFinite(o)) return !1;
                if (r.isString(o) && "-" !== o) return !0 }
            return !1 }

        function n(t) {
            return r[re](t) ? t : r[Me](t) ? t.value : t }
        var r = t(He);
        return e }), e("zrender/graphic/helper/smoothSpline", [We, "../../core/vector"], function(t) {
        function e(t, e, i, n, r, a, o) {
            var s = .5 * (i - t),
                l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * a + s * r + e }
        var i = t("../../core/vector");
        return function(t, n) {
            for (var r = t[ye], a = [], o = 0, s = 1; r > s; s++) o += i.distance(t[s - 1], t[s]);
            var l = o / 2;
            l = r > l ? r : l;
            for (var s = 0; l > s; s++) {
                var c, u, h, d = s / (l - 1) * (n ? r : r - 1),
                    f = Math.floor(d),
                    p = d - f,
                    m = t[f % r];
                n ? (c = t[(f - 1 + r) % r], u = t[(f + 1) % r], h = t[(f + 2) % r]) : (c = t[0 === f ? f : f - 1], u = t[f > r - 2 ? r - 1 : f + 1], h = t[f > r - 3 ? r - 1 : f + 2]);
                var v = p * p,
                    g = p * v;
                a.push([e(c[0], m[0], u[0], h[0], p, v, g), e(c[1], m[1], u[1], h[1], p, v, g)]) }
            return a } }), e("zrender/graphic/helper/smoothBezier", [We, "../../core/vector"], function(t) {
        var e = t("../../core/vector"),
            i = e.min,
            n = e.max,
            r = e.scale,
            a = e.distance,
            o = e.add;
        return function(t, s, l, c) {
            var u, h, d, f, p = [],
                m = [],
                v = [],
                g = [];
            if (c) { d = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
                for (var y = 0, x = t[ye]; x > y; y++) i(d, d, t[y]), n(f, f, t[y]);
                i(d, d, c[0]), n(f, f, c[1]) }
            for (var y = 0, x = t[ye]; x > y; y++) {
                var _ = t[y];
                if (l) u = t[y ? y - 1 : x - 1], h = t[(y + 1) % x];
                else {
                    if (0 === y || y === x - 1) { p.push(e.clone(t[y]));
                        continue }
                    u = t[y - 1], h = t[y + 1] }
                e.sub(m, h, u), r(m, m, s);
                var b = a(_, u),
                    w = a(_, h),
                    M = b + w;
                0 !== M && (b /= M, w /= M), r(v, m, -b), r(g, m, w);
                var S = o([], _, v),
                    T = o([], _, g);
                c && (n(S, S, d), i(S, S, f), n(T, T, d), i(T, T, f)), p.push(S), p.push(T) }
            return l && p.push(p.shift()), p } }), e("zrender/core/event", [We, "../mixin/Eventful"], function(t) {
        function e(t) {
            return t.getBoundingClientRect ? t.getBoundingClientRect() : { left: 0, top: 0 } }

        function i(t, i) {
            if (i = i || window.event, null != i.zrX) return i;
            var n = i.type,
                r = n && n[ne]("touch") >= 0;
            if (r) {
                var a = "touchend" != n ? i.targetTouches[0] : i.changedTouches[0];
                if (a) {
                    var o = e(t);
                    i.zrX = a.clientX - o.left, i.zrY = a.clientY - o.top } } else {
                var s = e(t);
                i.zrX = i.clientX - s.left, i.zrY = i.clientY - s.top, i.zrDelta = i.wheelDelta ? i.wheelDelta / 120 : -(i.detail || 0) / 3 }
            return i }

        function n(t, e, i) { s ? t.addEventListener(e, i) : t.attachEvent("on" + e, i) }

        function a(t, e, i) { s ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i) }
        var o = t("../mixin/Eventful"),
            s = typeof window !== r && !!window.addEventListener,
            l = s ? function(t) { t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0 } : function(t) { t.returnValue = !1, t.cancelBubble = !0 };
        return { normalizeEvent: i, addEventListener: n, removeEventListener: a, stop: l, Dispatcher: o } }), e("zrender/mixin/Draggable", [We], function() {
        function t() { this.on("mousedown", this._dragStart, this), this.on("mousemove", this._drag, this), this.on("mouseup", this._dragEnd, this), this.on("globalout", this._dragEnd, this) }
        return t[Ee] = { constructor: t, _dragStart: function(t) {
                var e = t[he];
                e && e.draggable && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this._dispatchProxy(e, "dragstart", t.event)) }, _drag: function(t) {
                var e = this._draggingTarget;
                if (e) {
                    var i = t.offsetX,
                        n = t.offsetY,
                        r = i - this._x,
                        a = n - this._y;
                    this._x = i, this._y = n, e.drift(r, a, t), this._dispatchProxy(e, "drag", t.event);
                    var o = this.findHover(i, n, e),
                        s = this._dropTarget;
                    this._dropTarget = o, e !== o && (s && o !== s && this._dispatchProxy(s, "dragleave", t.event), o && o !== s && this._dispatchProxy(o, "dragenter", t.event)) } }, _dragEnd: function(t) {
                var e = this._draggingTarget;
                e && (e.dragging = !1), this._dispatchProxy(e, "dragend", t.event), this._dropTarget && this._dispatchProxy(this._dropTarget, "drop", t.event), this._draggingTarget = null, this._dropTarget = null } }, t }), e("zrender/core/GestureMgr", [We], function() {
        function t(t) {
            var e = t[1][0] - t[0][0],
                i = t[1][1] - t[0][1];
            return Math.sqrt(e * e + i * i) }

        function e(t) {
            return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2] }
        var i = function() { this._track = [] };
        i[Ee] = { constructor: i, recognize: function(t, e) {
                return this._doTrack(t, e), this._recognize(t) }, clear: function() {
                return this._track[ye] = 0, this }, _doTrack: function(t, e) {
                var i = t.touches;
                if (i) {
                    for (var n = { points: [], touches: [], target: e, event: t }, r = 0, a = i[ye]; a > r; r++) {
                        var o = i[r];
                        n.points.push([o.clientX, o.clientY]), n.touches.push(o) }
                    this._track.push(n) } }, _recognize: function(t) {
                for (var e in n)
                    if (n.hasOwnProperty(e)) {
                        var i = n[e](this._track, t);
                        if (i) return i } } };
        var n = { pinch: function(i, n) {
                var r = i[ye];
                if (r) {
                    var a = (i[r - 1] || {}).points,
                        o = (i[r - 2] || {}).points || a;
                    if (o && o[ye] > 1 && a && a[ye] > 1) {
                        var s = t(a) / t(o);!isFinite(s) && (s = 1), n.pinchScale = s;
                        var l = e(a);
                        return n.pinchX = l[0], n.pinchY = l[1], { type: "pinch", target: i[0][he], event: n } } } } };
        return i }), e("echarts/data/DataDiffer", [We], function() {
        function t(t) {
            return t }

        function e(e, i, n, r) { this._old = e, this._new = i, this._oldKeyGetter = n || t, this._newKeyGetter = r || t }

        function i(t, e, i) {
            for (var n = 0; n < t[ye]; n++) {
                var r = i(t[n]),
                    a = e[r];
                null == a ? e[r] = n : (a[ye] || (e[r] = a = [a]), a.push(n)) } }
        return e[Ee] = { constructor: e, add: function(t) {
                return this._add = t, this }, update: function(t) {
                return this._update = t, this }, remove: function(t) {
                return this._remove = t, this }, execute: function() {
                var t, e = this._old,
                    n = this._new,
                    r = this._oldKeyGetter,
                    a = this._newKeyGetter,
                    o = {},
                    s = {};
                for (i(e, o, r), i(n, s, a), t = 0; t < e[ye]; t++) {
                    var l = r(e[t]),
                        c = s[l];
                    if (null != c) {
                        var u = c[ye];
                        u ? (1 === u && (s[l] = null), c = c.unshift()) : s[l] = null, this._update && this._update(c, t) } else this._remove && this._remove(t) }
                for (var l in s)
                    if (s.hasOwnProperty(l)) {
                        var c = s[l];
                        if (null == c) continue;
                        if (c[ye])
                            for (var t = 0, u = c[ye]; u > t; t++) this._add && this._add(c[t]);
                        else this._add && this._add(c) } } }, e }), e("echarts/component/axis/AxisView", [We, He, B, "./AxisBuilder", b], function(t) {
        function e(t, e) {
            function i(t) {
                var e = n[I](t);
                return e.toGlobalCoord(e.dataToCoord(0)) }
            var n = t[K],
                r = e.axis,
                a = {},
                o = r[W],
                s = r.onZero ? "onZero" : o,
                l = r.dim,
                c = n.getRect(),
                u = [c.x, c.x + c.width, c.y, c.y + c[Ae]],
                h = { x: { top: u[2], bottom: u[3] }, y: { left: u[0], right: u[1] } };
            h.x.onZero = Math.max(Math.min(i("y"), h.x[ke]), h.x.top), h.y.onZero = Math.max(Math.min(i("x"), h.y.right), h.y.left), a[W] = ["y" === l ? h.y[s] : u[0], "x" === l ? h.x[s] : u[3]];
            var p = { x: 0, y: 1 };
            a[d] = Math.PI / 2 * p[l];
            var m = { top: -1, bottom: 1, left: -1, right: 1 };
            a.labelDirection = a.tickDirection = a.nameDirection = m[o], r.onZero && (a.labelOffset = h[l][o] - h[l].onZero), e[Oe]("axisTick").get(f) && (a.tickDirection = -a.tickDirection), e[Oe]("axisLabel").get(f) && (a.labelDirection = -a.labelDirection);
            var v = e[Oe]("axisLabel").get("rotate");
            return a.labelRotation = "top" === s ? -v : v, a.labelInterval = r.getLabelInterval(), a.z2 = 1, a }
        var i = t(He),
            n = t(B),
            r = t("./AxisBuilder"),
            a = r.ifIgnoreOnTick,
            o = r.getInterval,
            s = ["axisLine", "axisLabel", "axisTick", "axisName"],
            l = ["splitLine", "splitArea"],
            c = t(b).extendComponentView({ type: "axis", render: function(t, n) {
                    if (this.group[J](), t.get("show")) {
                        var a = n[M]("grid", t.get("gridIndex")),
                            o = e(a, t),
                            c = new r(t, o);
                        i.each(s, c.add, c), this.group.add(c.getGroup()), i.each(l, function(e) { t.get(e + ".show") && this["_" + e](t, a, o.labelInterval) }, this) } }, _splitLine: function(t, e, r) {
                    var s = t.axis,
                        l = t[Oe]("splitLine"),
                        c = l[Oe]("lineStyle"),
                        u = c.get("width"),
                        h = c.get("color"),
                        d = o(l, r);
                    h = i[re](h) ? h : [h];
                    for (var f = e[K].getRect(), p = s.isHorizontal(), m = [], v = 0, g = s.getTicksCoords(), y = [], x = [], _ = 0; _ < g[ye]; _++)
                        if (!a(s, _, d)) {
                            var b = s.toGlobalCoord(g[_]);
                            p ? (y[0] = b, y[1] = f.y, x[0] = b, x[1] = f.y + f[Ae]) : (y[0] = f.x, y[1] = b, x[0] = f.x + f.width, x[1] = b);
                            var w = v++ % h[ye];
                            m[w] = m[w] || [], m[w].push(new n.Line(n.subPixelOptimizeLine({ shape: { x1: y[0], y1: y[1], x2: x[0], y2: x[1] }, style: { lineWidth: u }, silent: !0 }))) }
                    for (var M = c.getLineStyle(), _ = 0; _ < m[ye]; _++) this.group.add(n.mergePath(m[_], { style: i[xe]({ stroke: h[_ % h[ye]] }, M), silent: !0 })) }, _splitArea: function(t, e, r) {
                    var s = t.axis,
                        l = t[Oe]("splitArea"),
                        c = l[Oe]("areaStyle"),
                        u = c.get("color"),
                        h = e[K].getRect(),
                        d = s.getTicksCoords(),
                        f = s.toGlobalCoord(d[0]),
                        p = s.toGlobalCoord(d[0]),
                        m = [],
                        v = 0,
                        g = o(l, r);
                    u = i[re](u) ? u : [u];
                    for (var y = 1; y < d[ye]; y++)
                        if (!a(s, y, g)) {
                            var x, _, b, w, M = s.toGlobalCoord(d[y]);
                            s.isHorizontal() ? (x = f, _ = h.y, b = M - x, w = h[Ae]) : (x = h.x, _ = p, b = h.width, w = M - _);
                            var S = v++ % u[ye];
                            m[S] = m[S] || [], m[S].push(new n.Rect({ shape: { x: x, y: _, width: b, height: w }, silent: !0 })), f = x + b, p = _ + w }
                    for (var T = c.getAreaStyle(), y = 0; y < m[ye]; y++) this.group.add(n.mergePath(m[y], { style: i[xe]({ fill: u[y % u[ye]] }, T), silent: !0 })) } });
        c[be]({ type: "xAxis" }), c[be]({ type: "yAxis" }) }), e("zrender/Layer", [We, "./core/util", "./config"], function(t) {
        function e() {
            return !1 }

        function i(t, e, i, n) {
            var r = document[N](e),
                a = i[Ie](),
                o = i[De](),
                s = r.style;
            return s[W] = "absolute", s.left = 0, s.top = 0, s.width = a + "px", s[Ae] = o + "px", r.width = a * n, r[Ae] = o * n, r.setAttribute("data-zr-dom-id", t), r }
        var n = t("./core/util"),
            r = t("./config"),
            a = function(t, a, o) {
                var s;
                o = o || r.devicePixelRatio, typeof t === Be ? s = i(t, "canvas", a, o) : n[Me](t) && (s = t, t = s.id), this.id = t, this.dom = s;
                var l = s.style;
                l && (s.onselectstart = e, l["-webkit-user-select"] = "none", l["user-select"] = "none", l["-webkit-touch-callout"] = "none", l["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)"), this.domBack = null, this.ctxBack = null, this.painter = a, this.config = null, this.clearColor = 0, this.motionBlur = !1, this.lastFrameAlpha = .7, this.dpr = o };
        return a[Ee] = { constructor: a, elCount: 0, __dirty: !0, initContext: function() { this.ctx = this.dom[V]("2d");
                var t = this.dpr;
                1 != t && this.ctx.scale(t, t) }, createBackBuffer: function() {
                var t = this.dpr;
                this.domBack = i("back-" + this.id, "canvas", this.painter, t), this.ctxBack = this.domBack[V]("2d"), 1 != t && this.ctxBack.scale(t, t) }, resize: function(t, e) {
                var i = this.dpr,
                    n = this.dom,
                    r = n.style,
                    a = this.domBack;
                r.width = t + "px", r[Ae] = e + "px", n.width = t * i, n[Ae] = e * i, 1 != i && this.ctx.scale(i, i), a && (a.width = t * i, a[Ae] = e * i, 1 != i && this.ctxBack.scale(i, i)) }, clear: function(t) {
                var e = this.dom,
                    i = this.ctx,
                    n = e.width,
                    r = e[Ae],
                    a = this.clearColor,
                    o = this.motionBlur && !t,
                    s = this.lastFrameAlpha,
                    l = this.dpr;
                if (o && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(e, 0, 0, n / l, r / l)), i.clearRect(0, 0, n / l, r / l), a && (i.save(), i.fillStyle = this.clearColor, i.fillRect(0, 0, n / l, r / l), i.restore()), o) {
                    var c = this.domBack;
                    i.save(), i.globalAlpha = s, i.drawImage(c, 0, 0, n / l, r / l), i.restore() } } }, a }), e("echarts/chart/bar/barItemStyle", [We, "../../model/mixin/makeStyleMapper"], function(t) {
        return { getBarItemStyle: t("../../model/mixin/makeStyleMapper")([
                ["fill", "color"],
                [o, "borderColor"],
                [s, "borderWidth"],
                [o, "barBorderColor"],
                [s, "barBorderWidth"],
                [Z],
                ["shadowBlur"],
                ["shadowOffsetX"],
                ["shadowOffsetY"],
                ["shadowColor"]
            ]) } }), e("echarts/component/axis/AxisBuilder", [We, He, B, "../../model/Model", h], function(t) {
        function e(t) {
            var e = { componentType: t.mainType };
            return e[t.mainType + "Index"] = t.componentIndex, e }

        function i(t, e, i) {
            var n, r, a = u(e - t[d]);
            return f(a) ? (r = i > 0 ? "top" : ke, n = q) : f(a - p) ? (r = i > 0 ? ke : "top", n = q) : (r = j, n = a > 0 && p > a ? i > 0 ? "right" : "left" : i > 0 ? "left" : "right"), { rotation: a, textAlign: n, verticalAlign: r } }

        function n(t, e, i) {
            var n, r, a = u(-t[d]),
                o = i[0] > i[1],
                s = "start" === e && !o || "start" !== e && o;
            return f(a - p / 2) ? (r = s ? ke : "top", n = q) : f(a - 1.5 * p) ? (r = s ? "top" : ke, n = q) : (r = j, n = 1.5 * p > a && a > p / 2 ? s ? "left" : "right" : s ? "right" : "left"), { rotation: a, textAlign: n, verticalAlign: r } }
        var r = t(He),
            a = t(B),
            o = t("../../model/Model"),
            s = t(h),
            u = s.remRadian,
            f = s.isRadianAroundZero,
            p = Math.PI,
            m = function(t, e) { this.opt = e, this.axisModel = t, r[xe](e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0 }), this.group = new a.Group({ position: e[W].slice(), rotation: e[d] }) };
        m[Ee] = { constructor: m, hasBuilder: function(t) {
                return !!v[t] }, add: function(t) { v[t].call(this) }, getGroup: function() {
                return this.group } };
        var v = { axisLine: function() {
                    var t = this.opt,
                        e = this.axisModel;
                    if (e.get("axisLine.show")) {
                        var i = this.axisModel.axis[F]();
                        this.group.add(new a.Line({ shape: { x1: i[0], y1: 0, x2: i[1], y2: 0 }, style: r[be]({ lineCap: "round" }, e[Oe]("axisLine.lineStyle").getLineStyle()), strokeContainThreshold: t.strokeContainThreshold, silent: !!t.axisLineSilent, z2: 1 })) } }, axisTick: function() {
                    var t = this.axisModel;
                    if (t.get("axisTick.show")) {
                        for (var e = t.axis, i = t[Oe]("axisTick"), n = this.opt, r = i[Oe]("lineStyle"), o = i.get(ye), s = y(i, n.labelInterval), l = e.getTicksCoords(), c = [], u = 0; u < l[ye]; u++)
                            if (!g(e, u, s)) {
                                var h = l[u];
                                c.push(new a.Line(a.subPixelOptimizeLine({ shape: { x1: h, y1: 0, x2: h, y2: n.tickDirection * o }, style: { lineWidth: r.get("width") }, silent: !0 }))) }
                        this.group.add(a.mergePath(c, { style: r.getLineStyle(), z2: 2, silent: !0 })) } }, axisLabel: function() {
                    function t(t, e) {
                        var i = t && t[U]().clone(),
                            n = e && e[U]().clone();
                        return i && n ? (i[l](t.getLocalTransform()), n[l](e.getLocalTransform()), i.intersect(n)) : void 0 }
                    var n = this.axisModel;
                    if (n.get("axisLabel.show")) {
                        var r = this.opt,
                            s = n.axis,
                            u = n[Oe]("axisLabel"),
                            h = u[Oe](Q),
                            f = u.get("margin"),
                            m = s.scale.getTicks(),
                            v = n.getFormattedLabels(),
                            y = r.labelRotation;
                        null == y && (y = u.get("rotate") || 0), y = y * p / 180;
                        for (var x = i(r, y, r.labelDirection), _ = n.get("data"), b = [], M = n.get("silent"), S = 0; S < m[ye]; S++)
                            if (!g(s, S, r.labelInterval)) {
                                var T = h;
                                _ && _[S] && _[S][Q] && (T = new o(_[S][Q], h, n[c]));
                                var C = T[X](),
                                    A = s.dataToCoord(m[S]),
                                    k = [A, r.labelOffset + r.labelDirection * f],
                                    L = s.scale.getLabel(m[S]),
                                    z = new a.Text({ style: { text: v[S], textAlign: T.get("align", !0) || x[$], textVerticalAlign: T.get("baseline", !0) || x.verticalAlign, textFont: T[Y](), fill: typeof C === ie ? C(L) : C }, position: k, rotation: x[d], silent: M, z2: 10 });
                                z.eventData = e(n), z.eventData.targetType = "axisLabel", z.eventData.value = L, b.push(z), this.group.add(z) }
                        if (s.type !== w) {
                            if (n.getMin ? n.getMin() : n.get("min")) {
                                var P = b[0],
                                    D = b[1];
                                t(P, D) && (P[Le] = !0) }
                            if (n.getMax ? n.getMax() : n.get("max")) {
                                var I = b[b[ye] - 1],
                                    O = b[b[ye] - 2];
                                t(O, I) && (I[Le] = !0) } } } }, axisName: function() {
                    var t = this.opt,
                        r = this.axisModel,
                        o = this.opt.axisName;
                    if (null == o && (o = r.get("name")), o) {
                        var s, l = r.get("nameLocation"),
                            c = t.nameDirection,
                            u = r[Oe]("nameTextStyle"),
                            h = r.get("nameGap") || 0,
                            f = this.axisModel.axis[F](),
                            p = f[0] > f[1] ? -1 : 1,
                            m = ["start" === l ? f[0] - p * h : "end" === l ? f[1] + p * h : (f[0] + f[1]) / 2, l === j ? t.labelOffset + c * h : 0];
                        s = l === j ? i(t, t[d], c) : n(t, l, f);
                        var v = new a.Text({ style: { text: o, textFont: u[Y](), fill: u[X]() || r.get("axisLine.lineStyle.color"), textAlign: s[$], textVerticalAlign: s.verticalAlign }, position: m, rotation: s[d], silent: r.get("silent"), z2: 1 });
                        v.eventData = e(r), v.eventData.targetType = "axisName", v.eventData.name = o, this.group.add(v) } } },
            g = m.ifIgnoreOnTick = function(t, e, i) {
                var n, r = t.scale;
                return r.type === A && (typeof i === ie ? (n = r.getTicks()[e], !i(n, r.getLabel(n))) : e % (i + 1)) },
            y = m.getInterval = function(t, e) {
                var i = t.get("interval");
                return (null == i || "auto" == i) && (i = e), i };
        return m }), e("echarts/preprocessor/helper/compatStyle", [We, He], function(t) {
        function e(t) {
            var e = t && t.itemStyle;
            e && i.each(n, function(n) {
                var r = e[_],
                    a = e[y];
                r && r[n] && (t[n] = t[n] || {}, t[n][_] ? i.merge(t[n][_], r[n]) : t[n][_] = r[n], r[n] = null), a && a[n] && (t[n] = t[n] || {}, t[n][y] ? i.merge(t[n][y], a[n]) : t[n][y] = a[n], a[n] = null) }) }
        var i = t(He),
            n = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
        return function(t) {
            if (t) { e(t), e(t.markPoint), e(t.markLine);
                var n = t.data;
                if (n) {
                    for (var r = 0; r < n[ye]; r++) e(n[r]);
                    var a = t.markPoint;
                    if (a && a.data)
                        for (var o = a.data, r = 0; r < o[ye]; r++) e(o[r]);
                    var s = t.markLine;
                    if (s && s.data)
                        for (var l = s.data, r = 0; r < l[ye]; r++) i[re](l[r]) ? (e(l[r][0]), e(l[r][1])) : e(l[r]) } } } }), e("echarts/chart/line/poly", [We, "zrender/graphic/Path", Fe], function(t) {
        function e(t, e, i, n, d, f, p, m, v, g) {
            for (var y = i, x = 0; d > x; x++) {
                var _ = e[y];
                if (y >= n || 0 > y || isNaN(_[0]) || isNaN(_[1])) break;
                if (y === i) t[f > 0 ? "moveTo" : "lineTo"](_[0], _[1]), l(u, _);
                else if (v > 0) {
                    var b = y - f,
                        w = y + f,
                        M = .5,
                        S = e[b],
                        T = e[w];
                    if (f > 0 && (y === d - 1 || isNaN(T[0]) || isNaN(T[1])) || 0 >= f && (0 === y || isNaN(T[0]) || isNaN(T[1]))) l(h, _);
                    else {
                        (isNaN(T[0]) || isNaN(T[1])) && (T = _), r.sub(c, T, S);
                        var C, A;
                        if ("x" === g || "y" === g) {
                            var k = "x" === g ? 0 : 1;
                            C = Math.abs(_[k] - S[k]), A = Math.abs(_[k] - T[k]) } else C = r.dist(_, S), A = r.dist(_, T);
                        M = A / (A + C), s(h, _, c, -v * (1 - M)) }
                    a(u, u, m), o(u, u, p), a(h, h, m), o(h, h, p), t.bezierCurveTo(u[0], u[1], h[0], h[1], _[0], _[1]), s(u, _, c, v * M) } else t.lineTo(_[0], _[1]);
                y += f }
            return x }

        function i(t, e) {
            var i = [1 / 0, 1 / 0],
                n = [-1 / 0, -1 / 0];
            if (e)
                for (var r = 0; r < t[ye]; r++) {
                    var a = t[r];
                    a[0] < i[0] && (i[0] = a[0]), a[1] < i[1] && (i[1] = a[1]), a[0] > n[0] && (n[0] = a[0]), a[1] > n[1] && (n[1] = a[1]) }
            return { min: e ? i : n, max: e ? n : i } }
        var n = t("zrender/graphic/Path"),
            r = t(Fe),
            a = r.min,
            o = r.max,
            s = r.scaleAndAdd,
            l = r.copy,
            c = [],
            u = [],
            h = [];
        return { Polyline: n[be]({ type: "ec-polyline", shape: { points: [], smooth: 0, smoothConstraint: !0, smoothMonotone: null }, style: { fill: null, stroke: "#000" }, buildPath: function(t, n) {
                    for (var r = n.points, a = 0, o = r[ye], s = i(r, n.smoothConstraint); o > a;) a += e(t, r, a, o, o, 1, s.min, s.max, n.smooth, n.smoothMonotone) + 1 } }), Polygon: n[be]({ type: "ec-polygon", shape: { points: [], stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: !0, smoothMonotone: null }, buildPath: function(t, n) {
                    for (var r = n.points, a = n.stackedOnPoints, o = 0, s = r[ye], l = n.smoothMonotone, c = i(r, n.smoothConstraint), u = i(a, n.smoothConstraint); s > o;) {
                        var h = e(t, r, o, s, s, 1, c.min, c.max, n.smooth, l);
                        e(t, a, o + h - 1, s, h, -1, u.min, u.max, n.stackedOnSmooth, l), o += h + 1, t.closePath() } } }) } }), e("echarts/chart/helper/SymbolDraw", [We, B, "./Symbol"], function(t) {
        function e(t) { this.group = new n.Group, this._symbolCtor = t || r }

        function i(t, e, i) {
            var n = t[D](e);
            return !(!n || isNaN(n[0]) || isNaN(n[1]) || i && i(e) || "none" === t[x](e, "symbol")) }
        var n = t(B),
            r = t("./Symbol"),
            a = e[Ee];
        return a[L] = function(t, e) {
            var r = this.group,
                a = t.hostModel,
                o = this._data,
                s = this._symbolCtor;
            t.diff(o).add(function(n) {
                var a = t[D](n);
                if (i(t, n, e)) {
                    var o = new s(t, n);
                    o.attr(W, a), t.setItemGraphicEl(n, o), r.add(o) } })[Te](function(l, c) {
                var u = o[k](c),
                    h = t[D](l);
                return i(t, l, e) ? (u ? (u[L](t, l), n[C](u, { position: h }, a)) : (u = new s(t, l), u.attr(W, h)), r.add(u), void t.setItemGraphicEl(l, u)) : void r[we](u) })[we](function(t) {
                var e = o[k](t);
                e && e.fadeOut(function() { r[we](e) }) }).execute(), this._data = t }, a[Se] = function() {
            var t = this._data;
            t && t[z](function(e, i) { e.attr(W, t[D](i)) }) }, a[we] = function(t) {
            var e = this.group,
                i = this._data;
            i && (t ? i[z](function(t) { t.fadeOut(function() { e[we](t) }) }) : e[J]()) }, e }), e("echarts/chart/line/lineAnimationDiff", [We], function() {
        function t(t) {
            return t >= 0 ? 1 : -1 }

        function e(e, i, n) {
            for (var r, a = e[R](), o = e.getOtherAxis(a), s = a.onZero ? 0 : o.scale[F]()[0], l = o.dim, c = "x" === l || l === O ? 1 : 0, u = i.stackedOn, h = i.get(l, n); u && t(u.get(l, n)) === t(h);) { r = u;
                break }
            var d = [];
            return d[c] = i.get(a.dim, n), d[1 - c] = r ? r.get(l, n, !0) : s, e.dataToPoint(d) }

        function i(t, e) {
            var i = [];
            return e.diff(t).add(function(t) { i.push({ cmd: "+", idx: t }) })[Te](function(t, e) { i.push({ cmd: "=", idx: e, idx1: t }) })[we](function(t) { i.push({ cmd: "-", idx: t }) }).execute(), i }
        return function(t, n, r, a, o, s) {
            for (var l = i(t, n), c = [], u = [], h = [], d = [], f = [], p = [], m = [], v = s[S], g = 0; g < l[ye]; g++) {
                var y = l[g],
                    x = !0;
                switch (y.cmd) {
                    case "=":
                        var _ = t[D](y.idx),
                            b = n[D](y.idx1);
                        (isNaN(_[0]) || isNaN(_[1])) && (_ = b.slice()), c.push(_), u.push(b), h.push(r[y.idx]), d.push(a[y.idx1]), m.push(n.getRawIndex(y.idx1));
                        break;
                    case "+":
                        var w = y.idx;
                        c.push(o.dataToPoint([n.get(v[0], w, !0), n.get(v[1], w, !0)])), u.push(n[D](w).slice()), h.push(e(o, n, w)), d.push(a[w]), m.push(n.getRawIndex(w));
                        break;
                    case "-":
                        var w = y.idx,
                            M = t.getRawIndex(w);
                        M !== w ? (c.push(t[D](w)), u.push(s.dataToPoint([t.get(v[0], w, !0), t.get(v[1], w, !0)])), h.push(r[w]), d.push(e(s, t, w)), m.push(M)) : x = !1 }
                x && (f.push(y), p.push(p[ye])) }
            p.sort(function(t, e) {
                return m[t] - m[e] });
            for (var T = [], C = [], A = [], k = [], L = [], g = 0; g < p[ye]; g++) {
                var w = p[g];
                T[g] = c[w], C[g] = u[w], A[g] = h[w], k[g] = d[w], L[g] = f[w] }
            return { current: T, next: C, stackedOnCurrent: A, stackedOnNext: k, status: L } } }), e("echarts/chart/helper/dataSelectableMixin", [We, He], function(t) {
        var e = t(He);
        return { updateSelectedMap: function() {
                var t = this[u];
                this._dataOptMap = e.reduce(t.data, function(t, e) {
                    return t[e.name] = e, t }, {}) }, select: function(t) {
                var i = this._dataOptMap,
                    n = i[t],
                    r = this.get("selectedMode"); "single" === r && e.each(i, function(t) { t.selected = !1 }), n && (n.selected = !0) }, unSelect: function(t) {
                var e = this._dataOptMap[t];
                e && (e.selected = !1) }, toggleSelected: function(t) {
                var e = this._dataOptMap[t];
                return null != e ? (this[e.selected ? "unSelect" : "select"](t), e.selected) : void 0 }, isSelected: function(t) {
                var e = this._dataOptMap[t];
                return e && e.selected } } }), e("echarts/chart/helper/Symbol", [We, He, "../../util/symbol", B, h], function(t) {
        function e(t) {
            return r[re](t) || (t = [+t, +t]), t }

        function i(t, e) { s.Group.call(this), this[L](t, e) }

        function n(t, e) { this[a].drift(t, e) }
        var r = t(He),
            o = t("../../util/symbol"),
            s = t(B),
            l = t(h),
            c = i[Ee];
        c._createSymbol = function(t, i, r) { this[J]();
            var a = i.hostModel,
                l = i[x](r, "color"),
                c = o.createSymbol(t, -.5, -.5, 1, 1, l);
            c.attr({ style: { strokeNoScale: !0 }, z2: 100, culling: !0, scale: [0, 0] }), c.drift = n;
            var u = e(i[x](r, "symbolSize"));
            s.initProps(c, { scale: u }, a), this._symbolType = t, this.add(c) }, c.stopSymbolAnimation = function(t) { this.childAt(0).stopAnimation(t) }, c.getScale = function() {
            return this.childAt(0).scale }, c.highlight = function() { this.childAt(0)[ge](y) }, c.downplay = function() { this.childAt(0)[ge](_) }, c.setZ = function(t, e) {
            var i = this.childAt(0);
            i[se] = t, i.z = e }, c.setDraggable = function(t) {
            var e = this.childAt(0);
            e.draggable = t, e.cursor = t ? "move" : "pointer" }, c[L] = function(t, i) {
            var n = t[x](i, "symbol") || "circle",
                r = t.hostModel,
                a = e(t[x](i, "symbolSize"));
            if (n !== this._symbolType) this._createSymbol(n, t, i);
            else {
                var o = this.childAt(0);
                s[C](o, { scale: a }, r) }
            this._updateCommon(t, i, a), this._seriesModel = r };
        var u = ["itemStyle", _],
            f = ["itemStyle", y],
            p = ["label", _],
            m = ["label", y];
        return c._updateCommon = function(t, i, n) {
            var a = this.childAt(0),
                o = t.hostModel,
                c = t[T](i),
                h = c[Oe](u),
                b = t[x](i, "color"),
                w = a.style,
                M = c[Oe](f).getItemStyle();
            a[d] = c.getShallow("symbolRotate") * Math.PI / 180 || 0;
            var C = c.getShallow("symbolOffset");
            if (C) {
                var k = a[W];
                k[0] = l[v](C[0], n[0]), k[1] = l[v](C[1], n[1]) }
            a.setColor(b), r[be](w, h.getItemStyle(["color"]));
            var L = t[x](i, Z);
            null != L && (w[Z] = L);
            for (var z, P = c[Oe](p), D = c[Oe](m), I = t[S].slice(), O = I.pop();
                (z = t.getDimensionInfo(O).type) === A || "time" === z;) O = I.pop();
            P.get("show") ? (s.setText(w, P, b), w.text = r.retrieve(o.getFormattedLabel(i, _), t.get(O, i))) : w.text = "", D.getShallow("show") ? (s.setText(M, D, b), M.text = r.retrieve(o.getFormattedLabel(i, y), t.get(O, i))) : M.text = "";
            var R = e(t[x](i, "symbolSize"));
            if (a.off(fe).off(de).off(y).off(_), s[g](a, M), c.getShallow("hoverAnimation")) {
                var B = function() {
                        var t = R[1] / R[0];
                        this.animateTo({ scale: [Math.max(1.1 * R[0], R[0] + 3), Math.max(1.1 * R[1], R[1] + 3 * t)] }, 400, "elasticOut") },
                    E = function() { this.animateTo({ scale: R }, 400, "elasticOut") };
                a.on(fe, B).on(de, E).on(y, B).on(_, E) } }, c.fadeOut = function(t) {
            var e = this.childAt(0);
            e.style.text = "", s[C](e, { scale: [0, 0] }, this._seriesModel, t)
        }, r[te](i, s.Group), i
    }), e("echarts/util/symbol", [We, "./graphic", "zrender/core/BoundingRect"], function(t) {
        var e = t("./graphic"),
            n = t("zrender/core/BoundingRect"),
            r = e.extendShape({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(t, e) {
                    var i = e.cx,
                        n = e.cy,
                        r = e.width / 2,
                        a = e[Ae] / 2;
                    t.moveTo(i, n - a), t.lineTo(i + r, n + a), t.lineTo(i - r, n + a), t.closePath() } }),
            a = e.extendShape({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function(t, e) {
                    var i = e.cx,
                        n = e.cy,
                        r = e.width / 2,
                        a = e[Ae] / 2;
                    t.moveTo(i, n - a), t.lineTo(i + r, n), t.lineTo(i, n + a), t.lineTo(i - r, n), t.closePath() } }),
            s = e.extendShape({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(t, e) {
                    var i = e.x,
                        n = e.y,
                        r = e.width / 5 * 3,
                        a = Math.max(r, e[Ae]),
                        o = r / 2,
                        s = o * o / (a - o),
                        l = n - a + o + s,
                        c = Math.asin(s / o),
                        u = Math.cos(c) * o,
                        h = Math.sin(c),
                        d = Math.cos(c);
                    t.arc(i, l, o, Math.PI - c, 2 * Math.PI + c);
                    var f = .6 * o,
                        p = .7 * o;
                    t.bezierCurveTo(i + u - h * f, l + s + d * f, i, n - p, i, n), t.bezierCurveTo(i, n - p, i - u + h * f, l + s + d * f, i - u, l + s), t.closePath() } }),
            l = e.extendShape({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function(t, e) {
                    var i = e[Ae],
                        n = e.width,
                        r = e.x,
                        a = e.y,
                        o = n / 3 * 2;
                    t.moveTo(r, a), t.lineTo(r + o, a + i), t.lineTo(r, a + i / 4 * 3), t.lineTo(r - o, a + i), t.lineTo(r, a), t.closePath() } }),
            c = { line: e.Line, rect: e.Rect, roundRect: e.Rect, square: e.Rect, circle: e.Circle, diamond: a, pin: s, arrow: l, triangle: r },
            u = { line: function(t, e, i, n, r) { r.x1 = t, r.y1 = e + n / 2, r.x2 = t + i, r.y2 = e + n / 2 }, rect: function(t, e, i, n, r) { r.x = t, r.y = e, r.width = i, r[Ae] = n }, roundRect: function(t, e, i, n, r) { r.x = t, r.y = e, r.width = i, r[Ae] = n, r.r = Math.min(i, n) / 4 }, square: function(t, e, i, n, r) {
                    var a = Math.min(i, n);
                    r.x = t, r.y = e, r.width = a, r[Ae] = a }, circle: function(t, e, i, n, r) { r.cx = t + i / 2, r.cy = e + n / 2, r.r = Math.min(i, n) / 2 }, diamond: function(t, e, i, n, r) { r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[Ae] = n }, pin: function(t, e, i, n, r) { r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[Ae] = n }, arrow: function(t, e, i, n, r) { r.x = t + i / 2, r.y = e + n / 2, r.width = i, r[Ae] = n }, triangle: function(t, e, i, n, r) { r.cx = t + i / 2, r.cy = e + n / 2, r.width = i, r[Ae] = n } },
            h = {};
        for (var d in c) h[d] = new c[d];
        var p = e.extendShape({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, beforeBrush: function() {
                    var t = this.style,
                        e = this.shape; "pin" === e.symbolType && t.textPosition === f && (t.textPosition = ["50%", "40%"], t[$] = q, t.textVerticalAlign = j) }, buildPath: function(t, e) {
                    var n = e.symbolType,
                        r = h[n]; "none" !== e.symbolType && (r || (n = "rect", r = h[n]), u[n](e.x, e.y, e.width, e[Ae], r.shape), r[i](t, r.shape)) } }),
            m = function(t) {
                if ("image" !== this.type) {
                    var e = this.style,
                        i = this.shape;
                    i && "line" === i.symbolType ? e[o] = t : this.__isEmptyBrush ? (e[o] = t, e.fill = "#fff") : (e.fill && (e.fill = t), e[o] && (e[o] = t)), this.dirty() } },
            v = { createSymbol: function(t, i, r, a, o, s) {
                    var l = 0 === t[ne]("empty");
                    l && (t = t.substr(5, 1)[Ve]() + t.substr(6));
                    var c;
                    return c = 0 === t[ne]("image://") ? new e.Image({ style: { image: t.slice(8), x: i, y: r, width: a, height: o } }) : 0 === t[ne]("path://") ? e.makePath(t.slice(7), {}, new n(i, r, a, o)) : new p({ shape: { symbolType: t, x: i, y: r, width: a, height: o } }), c.__isEmptyBrush = l, c.setColor = m, c.setColor(s), c } };
        return v }), e("echarts/component/helper/listComponent", [We, "../../util/layout", "../../util/format", B], function(t) {
        function e(t, e, n) { i.positionGroup(t, e.getBoxLayoutParams(), { width: n[Ie](), height: n[De]() }, e.get("padding")) }
        var i = t("../../util/layout"),
            n = t("../../util/format"),
            r = t(B);
        return { layout: function(t, n, r) {
                var a = i.getLayoutRect(n.getBoxLayoutParams(), { width: r[Ie](), height: r[De]() }, n.get("padding"));
                i.box(n.get("orient"), t, n.get("itemGap"), a.width, a[Ae]), e(t, n, r) }, addBackground: function(t, e) {
                var i = n.normalizeCssArray(e.get("padding")),
                    a = t[U](),
                    o = e.getItemStyle(["color", Z]);
                o.fill = e.get("backgroundColor");
                var s = new r.Rect({ shape: { x: a.x - i[3], y: a.y - i[0], width: a.width + i[1] + i[3], height: a[Ae] + i[0] + i[2] }, style: o, silent: !0, z2: -1 });
                r.subPixelOptimizeRect(s), t.add(s) } } }), e("echarts/component/tooltip/TooltipContent", [We, He, "zrender/tool/color", "zrender/core/event", "../../util/format"], function(t) {
        function e(t) {
            var e = "cubic-bezier(0.23, 1, 0.32, 1)",
                i = "left " + t + "s " + e + ",top " + t + "s " + e;
            return o.map(d, function(t) {
                return t + "transition:" + i }).join(";") }

        function i(t) {
            var e = [],
                i = t.get("fontSize"),
                n = t[X]();
            return n && e.push("color:" + n), e.push("font:" + t[Y]()), i && e.push("line-height:" + Math.round(3 * i / 2) + "px"), u(["decoration", "align"], function(i) {
                var n = t.get(i);
                n && e.push("text-" + i + ":" + n) }), e.join(";") }

        function n(t) { t = t;
            var n = [],
                r = t.get("transitionDuration"),
                a = t.get("backgroundColor"),
                o = t[Oe](Q),
                l = t.get("padding");
            return r && n.push(e(r)), a && (n.push("background-Color:" + s.toHex(a)), n.push("filter:alpha(opacity=70)"), n.push("background-Color:" + a)), u(["width", "color", O], function(e) {
                var i = "border-" + e,
                    r = h(i),
                    a = t.get(r);
                null != a && n.push(i + ":" + a + ("color" === e ? "" : "px")) }), n.push(i(o)), null != l && n.push("padding:" + c.normalizeCssArray(l).join("px ") + "px"), n.join(";") + ";" }

        function r(t, e) {
            var i = document[N]("div"),
                n = e.getZr();
            this.el = i, this._x = e[Ie]() / 2, this._y = e[De]() / 2, t.appendChild(i), this._container = t, this._show = !1, this._hideTimeout;
            var r = this;
            i.onmouseenter = function() { r.enterable && (clearTimeout(r._hideTimeout), r._show = !0), r._inContent = !0 }, i.onmousemove = function(e) {
                if (!r.enterable) {
                    var i = n.handler;
                    l.normalizeEvent(t, e), i.dispatch("mousemove", e) } }, i.onmouseleave = function() { r.enterable && r._show && r.hideLater(r._hideDelay), r._inContent = !1 }, a(i, t) }

        function a(t, e) {
            function i(t) { n(t[he]) && t.preventDefault() }

            function n(i) {
                for (; i && i !== e;) {
                    if (i === t) return !0;
                    i = i.parentNode } }
            l.addEventListener(e, "touchstart", i), l.addEventListener(e, "touchmove", i), l.addEventListener(e, "touchend", i) }
        var o = t(He),
            s = t("zrender/tool/color"),
            l = t("zrender/core/event"),
            c = t("../../util/format"),
            u = o.each,
            h = c.toCamelCase,
            d = ["", "-webkit-", "-moz-", "-o-"],
            f = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
        return r[Ee] = { constructor: r, enterable: !0, update: function() {
                var t = this._container,
                    e = t.currentStyle || document.defaultView.getComputedStyle(t),
                    i = t.style; "absolute" !== i[W] && "absolute" !== e[W] && (i[W] = "relative") }, show: function(t) { clearTimeout(this._hideTimeout), this.el.style.cssText = f + n(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""), this._show = !0 }, setContent: function(t) {
                var e = this.el;
                e.innerHTML = t, e.style.display = t ? "block" : "none" }, moveTo: function(t, e) {
                var i = this.el.style;
                i.left = t + "px", i.top = e + "px", this._x = t, this._y = e }, hide: function() { this.el.style.display = "none", this._show = !1 }, hideLater: function(t) {!this._show || this._inContent && this.enterable || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(o.bind(this.hide, this), t)) : this.hide()) }, isShow: function() {
                return this._show } }, r }), e("echarts/chart/helper/LineDraw", [We, B, "./Line"], function(t) {
        function e(t) { this._ctor = t || n, this.group = new i.Group }
        var i = t(B),
            n = t("./Line"),
            r = e[Ee];
        return r[L] = function(t, e, i) {
            var n = this._lineData,
                r = this.group,
                a = this._ctor;
            t.diff(n).add(function(n) {
                var o = new a(t, e, i, n);
                t.setItemGraphicEl(n, o), r.add(o) })[Te](function(a, o) {
                var s = n[k](o);
                s[L](t, e, i, a), t.setItemGraphicEl(a, s), r.add(s) })[we](function(t) { r[we](n[k](t)) }).execute(), this._lineData = t, this._fromData = e, this._toData = i }, r[Se] = function() {
            var t = this._lineData;
            t[z](function(e, i) { e[Se](t, this._fromData, this._toData, i) }, this) }, r[we] = function() { this.group[J]() }, e }), e("echarts/component/marker/markerHelper", [We, He, h], function(t) {
        function e(t, e, i) {
            var n = -1;
            do n = Math.max(r.getPrecision(t.get(e, i)), n), t = t.stackedOn; while (t);
            return n }

        function i(t, i, n, r, a, o) {
            var s = [],
                l = f(i, r, t),
                c = i.indexOfNearest(r, l, !0);
            s[a] = i.get(n, c, !0), s[o] = i.get(r, c, !0);
            var u = e(i, r, c);
            return u >= 0 && (s[o] = +s[o][m](u)), s }
        var n = t(He),
            r = t(h),
            a = n[ne],
            o = n.curry,
            s = { min: o(i, "min"), max: o(i, "max"), average: o(i, "average") },
            l = function(t, e) {
                var i = t[Ze](),
                    r = t[K];
                if ((isNaN(e.x) || isNaN(e.y)) && !n[re](e.coord) && r) {
                    var o = c(e, i, r, t);
                    if (e = n.clone(e), e.type && s[e.type] && o.baseAxis && o.valueAxis) {
                        var l = r[S],
                            u = a(l, o.baseAxis.dim),
                            h = a(l, o.valueAxis.dim);
                        e.coord = s[e.type](i, o.baseDataDim, o.valueDataDim, u, h), e.value = e.coord[h] } else e.coord = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis] }
                return e },
            c = function(t, e, i, n) {
                var r = {};
                return null != t.valueIndex || null != t.valueDim ? (r.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = i[I](n.dataDimToCoordDim(r.valueDataDim)), r.baseAxis = i.getOtherAxis(r.valueAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0]) : (r.baseAxis = n[R](), r.valueAxis = i.getOtherAxis(r.baseAxis), r.baseDataDim = n.coordDimToDataDim(r.baseAxis.dim)[0], r.valueDataDim = n.coordDimToDataDim(r.valueAxis.dim)[0]), r },
            u = function(t, e) {
                return t && t.containData && e.coord && (null == e.x || null == e.y) ? t.containData(e.coord) : !0 },
            d = function(t, e, i, n) {
                return 2 > n ? t.coord && t.coord[n] : t.value },
            f = function(t, e, i) {
                return "average" === i ? t.getSum(e, !0) / t.count() : t.getDataExtent(e, !0)["max" === i ? 1 : 0] };
        return { dataTransform: l, dataFilter: u, dimValueGetter: d, getAxisInfo: c, numCalculate: f } }), e("echarts/chart/pie/labelLayout", [We, "zrender/contain/text"], function(t) {
        function e(t, e, i, n, r, a, o) {
            function s(e, i, n) {
                for (var r = e; i > r; r++)
                    if (t[r].y += n, r > e && i > r + 1 && t[r + 1].y > t[r].y + t[r][Ae]) return void l(r, n / 2);
                l(i - 1, n / 2) }

            function l(e, i) {
                for (var n = e; n >= 0 && (t[n].y -= i, !(n > 0 && t[n].y > t[n - 1].y + t[n - 1][Ae])); n--); }

            function c(t, e, i, n, r, a) {
                for (var o = a > 0 ? e ? Number.MAX_VALUE : 0 : e ? Number.MAX_VALUE : 0, s = 0, l = t[ye]; l > s; s++)
                    if (t[s][W] !== q) {
                        var c = Math.abs(t[s].y - n),
                            u = t[s].len,
                            h = t[s].len2,
                            d = r + u > c ? Math.sqrt((r + u + h) * (r + u + h) - c * c) : Math.abs(t[s].x - i);
                        e && d >= o && (d = o - 10), !e && o >= d && (d = o + 10), t[s].x = i + d * a, o = d } }
            t.sort(function(t, e) {
                return t.y - e.y });
            for (var u, h = 0, d = t[ye], f = [], p = [], m = 0; d > m; m++) u = t[m].y - h, 0 > u && s(m, d, -u, r), h = t[m].y + t[m][Ae];
            0 > o - h && l(d - 1, h - o);
            for (var m = 0; d > m; m++) t[m].y >= i ? p.push(t[m]) : f.push(t[m]);
            c(f, !1, e, i, n, r), c(p, !0, e, i, n, r) }

        function i(t, i, n, r, a, o) {
            for (var s = [], l = [], c = 0; c < t[ye]; c++) t[c].x < i ? s.push(t[c]) : l.push(t[c]);
            e(l, i, n, r, 1, a, o), e(s, i, n, r, -1, a, o);
            for (var c = 0; c < t[ye]; c++) {
                var u = t[c].linePoints;
                if (u) {
                    var h = u[1][0] - u[2][0];
                    u[2][0] = t[c].x < i ? t[c].x + 3 : t[c].x - 3, u[1][1] = u[2][1] = t[c].y, u[1][0] = u[2][0] + h } } }
        var n = t("zrender/contain/text");
        return function(t, e, r, a) {
            var o, s, l = t[Ze](),
                c = [],
                u = !1;
            l.each(function(i) {
                var r, a, h, d, m = l[D](i),
                    v = l[T](i),
                    g = v[Oe]("label.normal"),
                    y = g.get(W) || v.get("label.emphasis.position"),
                    x = v[Oe]("labelLine.normal"),
                    b = x.get(ye),
                    w = x.get("length2"),
                    M = (m.startAngle + m.endAngle) / 2,
                    S = Math.cos(M),
                    C = Math.sin(M);
                o = m.cx, s = m.cy;
                var A = y === f || "inner" === y;
                if (y === q) r = m.cx, a = m.cy, d = q;
                else {
                    var k = (A ? (m.r + m.r0) / 2 * S : m.r * S) + o,
                        L = (A ? (m.r + m.r0) / 2 * C : m.r * C) + s;
                    if (r = k + 3 * S, a = L + 3 * C, !A) {
                        var z = k + S * (b + e - m.r),
                            P = L + C * (b + e - m.r),
                            I = z + (0 > S ? -1 : 1) * w,
                            O = P;
                        r = I + (0 > S ? -5 : 5), a = O, h = [
                            [k, L],
                            [z, P],
                            [I, O]
                        ] }
                    d = A ? q : S > 0 ? "left" : "right" }
                var R = g[Oe](Q)[Y](),
                    B = g.get("rotate") ? 0 > S ? -M + Math.PI : -M : 0,
                    E = t.getFormattedLabel(i, _) || l[p](i),
                    V = n[U](E, R, d, "top");
                u = !!B, m.label = { x: r, y: a, position: y, height: V[Ae], len: b, len2: w, linePoints: h, textAlign: d, verticalAlign: "middle", font: R, rotation: B }, A || c.push(m.label) }), !u && t.get("avoidLabelOverlap") && i(c, o, s, e, r, a) } }), e("echarts/component/helper/SelectController", [We, "zrender/mixin/Eventful", He, B], function(t) {
        function e(t, e, i) { y.call(this), this.type = t, this.zr = e, this.opt = x.clone(i), this.group = new _.Group, this._containerRect = null, this._track = [], this._dragging, this._cover, this._disabled = !0, this._handlers = { mousedown: b(l, this), mousemove: b(c, this), mouseup: b(u, this) }, w(k, function(t) { this.zr.on(t, this._handlers[t]) }, this) }

        function i(t) { t[oe](function(t) { t.z = C }) }

        function n(t, e) {
            var i = this.group.transformCoordToLocal(t, e);
            return !this._containerRect || this._containerRect[G](i[0], i[1]) }

        function r(t) {
            var e = t.event;
            e.preventDefault && e.preventDefault() }

        function l(t) {
            if (!(this._disabled || t[he] && t[he].draggable)) { r(t);
                var e = t.offsetX,
                    i = t.offsetY;
                n.call(this, e, i) && (this._dragging = !0, this._track = [
                    [e, i]
                ]) } }

        function c(t) { this._dragging && !this._disabled && (r(t), h.call(this, t)) }

        function u(t) { this._dragging && !this._disabled && (r(t), h.call(this, t, !0), this._dragging = !1, this._track = []) }

        function h(t, e) {
            var i = t.offsetX,
                r = t.offsetY;
            if (n.call(this, i, r)) { this._track.push([i, r]);
                var a = d.call(this) ? L[this.type].getRanges.call(this) : [];
                f.call(this, a), this[ge]("selected", x.clone(a)), e && this[ge]("selectEnd", x.clone(a)) } }

        function d() {
            var t = this._track;
            if (!t[ye]) return !1;
            var e = t[t[ye] - 1],
                i = t[0],
                n = e[0] - i[0],
                r = e[1] - i[1],
                a = T(n * n + r * r, .5);
            return a > A }

        function f(t) {
            var e = L[this.type];
            t && t[ye] ? (this._cover || (this._cover = e[Ce].call(this), this.group.add(this._cover)), e[Te].call(this, t)) : (this.group[we](this._cover), this._cover = null), i(this.group) }

        function p() {
            var t = this.group,
                e = t[a];
            e && e[we](t) }

        function m() {
            var t = this.opt;
            return new _.Rect({ style: { stroke: t[o], fill: t.fill, lineWidth: t[s], opacity: t[Z] } }) }

        function v() {
            return x.map(this._track, function(t) {
                return this.group.transformCoordToLocal(t[0], t[1]) }, this) }

        function g() {
            var t = v.call(this),
                e = t[ye] - 1;
            return 0 > e && (e = 0), [t[0], t[e]] }
        var y = t("zrender/mixin/Eventful"),
            x = t(He),
            _ = t(B),
            b = x.bind,
            w = x.each,
            M = Math.min,
            S = Math.max,
            T = Math.pow,
            C = 1e4,
            A = 2,
            k = ["mousedown", "mousemove", "mouseup"];
        e[Ee] = { constructor: e, enable: function(t, e) { this._disabled = !1, p.call(this), this._containerRect = e !== !1 ? e || t[U]() : null, t.add(this.group) }, update: function(t) { f.call(this, t && x.clone(t)) }, disable: function() { this._disabled = !0, p.call(this) }, dispose: function() { this.disable(), w(k, function(t) { this.zr.off(t, this._handlers[t]) }, this) } }, x.mixin(e, y);
        var L = { line: { create: m, getRanges: function() {
                    var t = g.call(this),
                        e = M(t[0][0], t[1][0]),
                        i = S(t[0][0], t[1][0]);
                    return [
                        [e, i]
                    ] }, update: function(t) {
                    var e = t[0],
                        i = this.opt.width;
                    this._cover.setShape({ x: e[0], y: -i / 2, width: e[1] - e[0], height: i }) } }, rect: { create: m, getRanges: function() {
                    var t = g.call(this),
                        e = [M(t[1][0], t[0][0]), M(t[1][1], t[0][1])],
                        i = [S(t[1][0], t[0][0]), S(t[1][1], t[0][1])];
                    return [
                        [
                            [e[0], i[0]],
                            [e[1], i[1]]
                        ]
                    ] }, update: function(t) {
                    var e = t[0];
                    this._cover.setShape({ x: e[0][0], y: e[1][0], width: e[0][1] - e[0][0], height: e[1][1] - e[1][0] }) } } };
        return e }), e("echarts/component/dataZoom/history", [We, He], function(t) {
        function e(t) {
            var e = t[r];
            return e || (e = t[r] = [{}]), e }
        var i = t(He),
            n = i.each,
            r = "\x00_ec_hist_store",
            a = { push: function(t, i) {
                    var r = e(t);
                    n(i, function(e, i) {
                        for (var n = r[ye] - 1; n >= 0; n--) {
                            var a = r[n];
                            if (a[i]) break }
                        if (0 > n) {
                            var o = t.queryComponents({ mainType: "dataZoom", subType: "select", id: i })[0];
                            if (o) {
                                var s = o.getPercentRange();
                                r[0][i] = { dataZoomId: i, start: s[0], end: s[1] } } } }), r.push(i) }, pop: function(t) {
                    var i = e(t),
                        r = i[i[ye] - 1];
                    i[ye] > 1 && i.pop();
                    var a = {};
                    return n(r, function(t, e) {
                        for (var n = i[ye] - 1; n >= 0; n--) {
                            var t = i[n][e];
                            if (t) { a[e] = t;
                                break } } }), a }, clear: function(t) { t[r] = null }, count: function(t) {
                    return e(t)[ye] } };
        return a }), e("echarts/component/helper/interactionMutex", [We], function() {
        function t(t) {
            return t[e] || (t[e] = {}) }
        var e = "\x00_ec_interaction_mutex",
            i = { take: function(e, i) { t(i)[e] = !0 }, release: function(e, i) { t(i)[e] = !1 }, isTaken: function(e, i) {
                    return !!t(i)[e] } };
        return i }), e("echarts/component/dataZoomSelect", [We, "./dataZoom/typeDefaulter", "./dataZoom/DataZoomModel", "./dataZoom/DataZoomView", "./dataZoom/SelectZoomModel", "./dataZoom/SelectZoomView", "./dataZoom/dataZoomProcessor", "./dataZoom/dataZoomAction"], function(t) { t("./dataZoom/typeDefaulter"), t("./dataZoom/DataZoomModel"), t("./dataZoom/DataZoomView"), t("./dataZoom/SelectZoomModel"), t("./dataZoom/SelectZoomView"), t("./dataZoom/dataZoomProcessor"), t("./dataZoom/dataZoomAction") }), e("echarts/chart/helper/Line", [We, "../../util/symbol", Fe, "./LinePath", B, He, h], function(t) {
        function e(t, e, i) {
            var n = e[x](i, "color"),
                r = e[x](i, "symbol"),
                a = e[x](i, "symbolSize");
            if ("none" !== r) { m[re](a) || (a = [a, a]);
                var o = l.createSymbol(r, -a[0] / 2, -a[1] / 2, a[0], a[1], n);
                return o.name = t, o } }

        function i(t) {
            var e = new u({ name: "line", style: { strokeNoScale: !0 } });
            return n(e.shape, t), e }

        function n(t, e) {
            var i = e[0],
                n = e[1],
                r = e[2];
            t.x1 = i[0], t.y1 = i[1], t.x2 = n[0], t.y2 = n[1], t.percent = 1, r && (t.cpx1 = r[0], t.cpy1 = r[1]) }

        function r(t) {
            return "symbol" === t.type && "arrow" === t.shape.symbolType }

        function a() {
            var t = this,
                e = t.childOfName("line");
            if (this.__dirty || e.__dirty) {
                var i = t.childOfName("fromSymbol"),
                    n = t.childOfName("toSymbol"),
                    a = t.childOfName("label"),
                    s = e.pointAt(0),
                    l = e.pointAt(e.shape.percent),
                    u = c.sub([], l, s);
                c.normalize(u, u), i && (i.attr(W, s), r(i) && i.attr(d, o(l, s))), n && (n.attr(W, l), r(n) && n.attr(d, o(s, l))), a.attr(W, l);
                var h, f, p; "end" === a.__position ? (h = [5 * u[0] + l[0], 5 * u[1] + l[1]], f = u[0] > .8 ? "left" : u[0] < -.8 ? "right" : q, p = u[1] > .8 ? "top" : u[1] < -.8 ? ke : j) : (h = [5 * -u[0] + s[0], 5 * -u[1] + s[1]], f = u[0] > .8 ? "right" : u[0] < -.8 ? "left" : q, p = u[1] > .8 ? ke : u[1] < -.8 ? "top" : j), a.attr({ style: { textVerticalAlign: a.__verticalAlign || p, textAlign: a.__textAlign || f }, position: h }) } }

        function o(t, e) {
            return -Math.PI / 2 - Math.atan2(e[1] - t[1], e[0] - t[0]) }

        function s(t, e, i, n) { f.Group.call(this), this._createLine(t, e, i, n) }
        var l = t("../../util/symbol"),
            c = t(Fe),
            u = t("./LinePath"),
            f = t(B),
            m = t(He),
            v = t(h),
            b = s[Ee];
        return b.beforeUpdate = a, b._createLine = function(t, n, r, a) {
            var o = t.hostModel,
                s = t[D](a),
                l = i(s);
            l.shape.percent = 0, f.initProps(l, { shape: { percent: 1 } }, o), this.add(l);
            var c = new f.Text({ name: "label" });
            if (this.add(c), n) {
                var u = e("fromSymbol", n, a);
                this.add(u), this._fromSymbolType = n[x](a, "symbol") }
            if (r) {
                var h = e("toSymbol", r, a);
                this.add(h), this._toSymbolType = r[x](a, "symbol") }
            this._updateCommonStl(t, n, r, a) }, b[L] = function(t, i, r, a) {
            var o = t.hostModel,
                s = this.childOfName("line"),
                l = t[D](a),
                c = { shape: {} };
            if (n(c.shape, l), f[C](s, c, o), i) {
                var u = i[x](a, "symbol");
                if (this._fromSymbolType !== u) {
                    var h = e("fromSymbol", i, a);
                    this[we](this.childOfName("fromSymbol")), this.add(h) }
                this._fromSymbolType = u }
            if (r) {
                var d = r[x](a, "symbol");
                if (d !== this._toSymbolType) {
                    var p = e("toSymbol", r, a);
                    this[we](this.childOfName("toSymbol")), this.add(p) }
                this._toSymbolType = d }
            this._updateCommonStl(t, i, r, a) }, b._updateCommonStl = function(t, e, i, n) {
            var r = t.hostModel,
                a = this.childOfName("line"),
                o = t[T](n),
                s = o[Oe]("label.normal"),
                l = s[Oe](Q),
                c = o[Oe]("label.emphasis"),
                u = c[Oe](Q),
                h = v.round(r.getRawValue(n));
            isNaN(h) && (h = t[p](n)), a[H](m[be]({ stroke: t[x](n, "color") }, o[Oe]("lineStyle.normal").getLineStyle()));
            var d = this.childOfName("label");
            d[H]({ text: s.get("show") ? m.retrieve(r.getFormattedLabel(n, _), h) : "", textFont: l[Y](), fill: l[X]() || t[x](n, "color") }), d.hoverStyle = { text: c.get("show") ? m.retrieve(r.getFormattedLabel(n, y), h) : "", textFont: u[Y](), fill: u[X]() }, d.__textAlign = l.get("align"), d.__verticalAlign = l.get("baseline"), d.__position = s.get(W), f[g](this, o[Oe]("lineStyle.emphasis").getLineStyle()) }, b[Se] = function(t, e, i, r) {
            var a = t[D](r),
                o = this.childOfName("line");
            n(o.shape, a), o.dirty(!0) }, m[te](s, f.Group), s }), e("echarts/component/dataZoom/typeDefaulter", [We, "../../model/Component"], function(t) { t("../../model/Component").registerSubTypeDefaulter("dataZoom", function() {
            return "slider" }) }), e("echarts/component/dataZoom/DataZoomModel", [We, He, "zrender/core/env", b, "../../util/model", "./AxisProxy"], function(t) {
        function e(t) {
            var e = {};
            return l(["start", "end", "startValue", "endValue"], function(i) { e[i] = t[i] }), e }

        function i(t, e, i, n) { null != i[e] && null == i[t] && (n[t] = null) }
        var n = t(He),
            r = t("zrender/core/env"),
            a = t(b),
            o = t("../../util/model"),
            s = t("./AxisProxy"),
            l = n.each,
            h = o.eachAxisDim,
            d = a.extendComponentModel({ type: "dataZoom", dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", me], defaultOption: { zlevel: 0, z: 4, orient: null, xAxisIndex: null, yAxisIndex: null, angleAxisIndex: null, radiusAxisIndex: null, filterMode: "filter", throttle: 100, start: 0, end: 100, startValue: null, endValue: null }, init: function(t, i, n) { this._dataIntervalByAxis = {}, this._dataInfo = {}, this._axisProxies = {}, this.textStyleModel;
                    var r = e(t);
                    this.mergeDefaultAndTheme(t, n), this.doInit(r) }, mergeOption: function(t) {
                    var i = e(t);
                    n.merge(this[u], t, !0), this.doInit(i) }, doInit: function(t) {
                    var e = this[u];
                    r[Pe] || (e.realtime = !1), i("start", "startValue", t, e), i("end", "endValue", t, e), this.textStyleModel = this[Oe](Q), this._resetTarget(), this._giveAxisProxies() }, _giveAxisProxies: function() {
                    var t = this._axisProxies;
                    this.eachTargetAxis(function(e, i, n, r) {
                        var a = this.dependentModels[e.axis][i],
                            o = a.__dzAxisProxy || (a.__dzAxisProxy = new s(e.name, i, this, r));
                        t[e.name + "_" + i] = o }, this) }, _resetTarget: function() {
                    var t = this[u],
                        e = this._judgeAutoMode();
                    h(function(e) {
                        var i = e.axisIndex;
                        t[i] = o.normalizeToArray(t[i]) }, this), "axisIndex" === e ? this._autoSetAxisIndex() : "orient" === e && this._autoSetOrient() }, _judgeAutoMode: function() {
                    var t = this[u],
                        e = !1;
                    h(function(i) { null != t[i.axisIndex] && (e = !0) }, this);
                    var i = t.orient;
                    return null == i && e ? "orient" : e ? void 0 : (null == i && (t.orient = "horizontal"), "axisIndex") }, _autoSetAxisIndex: function() {
                    var t = !0,
                        e = this.get("orient", !0),
                        i = this[u];
                    if (t) {
                        var r = "vertical" === e ? { dim: "y", axisIndex: "yAxisIndex", axis: "yAxis" } : { dim: "x", axisIndex: "xAxisIndex", axis: "xAxis" };
                        this.dependentModels[r.axis][ye] && (i[r.axisIndex] = [0], t = !1) }
                    t && h(function(e) {
                        if (t) {
                            var n = [],
                                r = this.dependentModels[e.axis];
                            if (r[ye] && !n[ye])
                                for (var a = 0, o = r[ye]; o > a; a++) r[a].get("type") === w && n.push(a);
                            i[e.axisIndex] = n, n[ye] && (t = !1) } }, this), t && this[c][ve](function(t) { this._isSeriesHasAllAxesTypeOf(t, "value") && h(function(e) {
                            var r = i[e.axisIndex],
                                a = t.get(e.axisIndex);
                            n[ne](r, a) < 0 && r.push(a) }) }, this) }, _autoSetOrient: function() {
                    var t;
                    this.eachTargetAxis(function(e) {!t && (t = e.name) }, this), this[u].orient = "y" === t ? "vertical" : "horizontal" }, _isSeriesHasAllAxesTypeOf: function(t, e) {
                    var i = !0;
                    return h(function(n) {
                        var r = t.get(n.axisIndex),
                            a = this.dependentModels[n.axis][r];
                        a && a.get("type") === e || (i = !1) }, this), i }, getFirstTargetAxisModel: function() {
                    var t;
                    return h(function(e) {
                        if (null == t) {
                            var i = this.get(e.axisIndex);
                            i[ye] && (t = this.dependentModels[e.axis][i[0]]) } }, this), t }, eachTargetAxis: function(t, e) {
                    var i = this[c];
                    h(function(n) { l(this.get(n.axisIndex), function(r) { t.call(e, n, r, this, i) }, this) }, this) }, getAxisProxy: function(t, e) {
                    return this._axisProxies[t + "_" + e] }, setRawRange: function(t) { l(["start", "end", "startValue", "endValue"], function(e) { this[u][e] = t[e] }, this) }, getPercentRange: function() {
                    var t = this.findRepresentativeAxisProxy();
                    return t ? t.getDataPercentWindow() : void 0 }, getValueRange: function(t, e) {
                    if (null != t || null != e) return this.getAxisProxy(t, e).getDataValueWindow();
                    var i = this.findRepresentativeAxisProxy();
                    return i ? i.getDataValueWindow() : void 0 }, findRepresentativeAxisProxy: function() {
                    var t = this._axisProxies;
                    for (var e in t)
                        if (t.hasOwnProperty(e) && t[e].hostedBy(this)) return t[e];
                    for (var e in t)
                        if (t.hasOwnProperty(e) && !t[e].hostedBy(this)) return t[e] } });
        return d }), e("echarts/component/dataZoom/SelectZoomModel", [We, "./DataZoomModel"], function(t) {
        var e = t("./DataZoomModel");
        return e[be]({ type: "dataZoom.select" }) }), e("echarts/component/dataZoom/dataZoomProcessor", [We, b], function(t) {
        function e(t, e, i) { i.getAxisProxy(t.name, e).reset(i) }

        function i(t, e, i) { i.getAxisProxy(t.name, e).filterData(i) }
        var n = t(b);
        n.registerProcessor(Ge, function(t) { t[ze]("dataZoom", function(t) { t.eachTargetAxis(e), t.eachTargetAxis(i) }), t[ze]("dataZoom", function(t) {
                var e = t.findRepresentativeAxisProxy(),
                    i = e.getDataPercentWindow(),
                    n = e.getDataValueWindow();
                t.setRawRange({ start: i[0], end: i[1], startValue: n[0], endValue: n[1] }) }) }) }), e("echarts/component/dataZoom/DataZoomView", [We, "../../view/Component"], function(t) {
        var e = t("../../view/Component");
        return e[be]({ type: "dataZoom", render: function(t, e, i) { this.dataZoomModel = t, this[c] = e, this.api = i }, getTargetInfo: function() {
                function t(t, e, i, n) {
                    for (var r, a = 0; a < i[ye]; a++)
                        if (i[a].model === t) { r = i[a];
                            break }
                    r || i.push(r = { model: t, axisModels: [], coordIndex: n }), r.axisModels.push(e) }
                var e = this.dataZoomModel,
                    i = this[c],
                    n = [],
                    r = [],
                    a = [];
                return e.eachTargetAxis(function(e, o) {
                    var s = i[M](e.axis, o);
                    if (s) { a.push(s);
                        var l = s.get("gridIndex"),
                            c = s.get("polarIndex");
                        if (null != l) {
                            var u = i[M]("grid", l);
                            t(u, s, n, l) } else if (null != c) {
                            var u = i[M]("polar", c);
                            t(u, s, r, c) } } }, this), { cartesians: n, polars: r, axisModels: a } } }) }), e("echarts/component/dataZoom/SelectZoomView", [We, "./DataZoomView"], function(t) {
        return t("./DataZoomView")[be]({ type: "dataZoom.select" }) }), e("echarts/chart/helper/LinePath", [We, B], function(t) {
        var e = t(B),
            n = e.Line[Ee],
            r = e.BezierCurve[Ee];
        return e.extendShape({ type: "ec-line", style: { stroke: "#000", fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function(t, e) {
                (null == e.cpx1 || null == e.cpy1 ? n : r)[i](t, e) }, pointAt: function(t) {
                var e = this.shape;
                return null == e.cpx1 || null == e.cpy1 ? n.pointAt.call(this, t) : r.pointAt.call(this, t) } }) }), e("echarts/component/dataZoom/dataZoomAction", [We, He, "../../util/model", b], function(t) {
        var e = t(He),
            i = t("../../util/model"),
            n = t(b);
        n.registerAction("dataZoom", function(t, n) {
            var r = i.createLinkedNodesFinder(e.bind(n[ze], n, "dataZoom"), i.eachAxisDim, function(t, e) {
                    return t.get(e.axisIndex) }),
                a = [];
            n[ze]({ mainType: "dataZoom", query: t }, function(t) { a.push.apply(a, r(t).nodes) }), e.each(a, function(e) { e.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue }) }) }) }), e("echarts/component/dataZoom/AxisProxy", [We, He, h], function(t) {
        function e(t, e) {
            var i = [1 / 0, -1 / 0];
            return s(e, function(e) {
                var n = e[Ze]();
                n && s(e.coordDimToDataDim(t), function(t) {
                    var e = n.getDataExtent(t);
                    e[0] < i[0] && (i[0] = e[0]), e[1] > i[1] && (i[1] = e[1]) }) }, this), i }

        function i(t, e, i) {
            var r = i.getAxisModel(),
                a = r.axis.scale,
                c = [0, 100],
                u = [t.start, t.end],
                h = [];
            return e = e.slice(), n(e, r, a), s(["startValue", "endValue"], function(e) { h.push(null != t[e] ? a.parse(t[e]) : null) }), s([0, 1], function(t) {
                function i(e) {
                    return Math[0 === t ? "floor" : "ceil"](1e12 * e) / 1e12 }
                var n = h[t],
                    r = u[t];
                null != r || null == n ? (null == r && (r = c[t]), n = a.parse(o.linearMap(r, c, e, !0))) : r = o.linearMap(n, e, c, !0), h[t] = i(n), u[t] = i(r) }), { valueWindow: l(h), percentWindow: l(u) } }

        function n(t, e, i) {
            return s(["min", "max"], function(n, r) {
                var a = e.get(n, !0);
                null != a && (a + "")[Ve]() !== "data" + n && (t[r] = i.parse(a)) }), e.get("scale", !0) || (t[0] > 0 && (t[0] = 0), t[1] < 0 && (t[1] = 0)), t }

        function r(t, e) {
            var i = t.getAxisModel(),
                n = t._percentWindow,
                r = t._valueWindow;
            if (n) {
                var a = e || 0 === n[0] && 100 === n[1],
                    s = !e && o.getPixelPrecision(r, [0, 500]),
                    l = !(e || 20 > s && s >= 0),
                    c = e || a || l;
                i.setRange && i.setRange(c ? null : +r[0][m](s), c ? null : +r[1][m](s)) } }
        var a = t(He),
            o = t(h),
            s = a.each,
            l = o.asc,
            d = function(t, e, i, n) { this._dimName = t, this._axisIndex = e, this._valueWindow, this._percentWindow, this._dataExtent, this[c] = n, this._dataZoomModel = i };
        return d[Ee] = { constructor: d, hostedBy: function(t) {
                return this._dataZoomModel === t }, getDataExtent: function() {
                return this._dataExtent.slice() }, getDataValueWindow: function() {
                return this._valueWindow.slice() }, getDataPercentWindow: function() {
                return this._percentWindow.slice() }, getTargetSeriesModels: function() {
                var t = [];
                return this[c][ve](function(e) { this._axisIndex === e.get(this._dimName + "AxisIndex") && t.push(e) }, this), t }, getAxisModel: function() {
                return this[c][M](this._dimName + "Axis", this._axisIndex) }, getOtherAxisModel: function() {
                var t, e, i = this._dimName,
                    n = this[c],
                    r = this.getAxisModel(),
                    a = "x" === i || "y" === i;
                a ? (e = "gridIndex", t = "x" === i ? "y" : "x") : (e = "polarIndex", t = "angle" === i ? O : "angle");
                var o;
                return n[ze](t + "Axis", function(t) {
                    (t.get(e) || 0) === (r.get(e) || 0) && (o = t) }), o }, reset: function(t) {
                if (t === this._dataZoomModel) {
                    var n = this._dataExtent = e(this._dimName, this.getTargetSeriesModels()),
                        a = i(t[u], n, this);
                    this._valueWindow = a.valueWindow, this._percentWindow = a.percentWindow, r(this) } }, restore: function(t) { t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null, r(this, !0)) }, filterData: function(t) {
                function e(t) {
                    return t >= a[0] && t <= a[1] }
                if (t === this._dataZoomModel) {
                    var i = this._dimName,
                        n = this.getTargetSeriesModels(),
                        r = t.get("filterMode"),
                        a = this._valueWindow,
                        o = this.getOtherAxisModel();
                    t.get("$fromToolbox") && o && o.get("type") === w && (r = "empty"), s(n, function(t) {
                        var n = t[Ze]();
                        n && s(t.coordDimToDataDim(i), function(i) { "empty" === r ? t.setData(n.map(i, function(t) {
                                return e(t) ? t : 0 / 0 })) : n.filterSelf(i, e) }) }) } } }, d }), e("zrender", ["zrender/zrender"], function(t) {
        return t }), e("echarts", ["echarts/echarts"], function(t) {
        return t });
    var qe = t("echarts");
    return qe.graphic = t("echarts/util/graphic"), qe.number = t("echarts/util/number"), qe.format = t("echarts/util/format"), t("echarts/chart/bar"), t("echarts/chart/line"), t("echarts/chart/pie"), t("echarts/component/grid"), t("echarts/component/title"), t("echarts/component/legend"), t("echarts/component/tooltip"), t("echarts/component/markLine"), t("echarts/component/toolbox"), t("zrender/vml/vml"), qe
});
